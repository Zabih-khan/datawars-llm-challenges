[
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_0",
        "text": "Hey there. How's it going everybody? In this video, we're gonna continue learning more about Pandas, and specifically, we're gonna be learning about the data frame and series data types. So like I said in the last video, these are basically the backbone of Pandas and are the 2 primary data types that you'll likely be using the most. So in this video, we're gonna go over how we can think of data frames and series data types in a different way, and then we'll look at the basics of getting information from these data types. Now I would like to mention that we do have a sponsor for this series of videos, and that is brilliant.org. So I really wanna thank Brilliant for sponsoring the series, and it would be great if you all can check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a Okay. So first, let's look at what a data frame is, and then we'll learn more about how we can think about this in terms of a Python object"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_1",
        "text": ". So we saw data frames briefly in our last video when we checked to make sure that our data was loaded in correctly. So these, were the objects that were displayed in Jupyter as rows and columns, basically a table. So let's take a look at what this looks like. So if you were following along with the last video, this is basically, the same Jupyter Notebook that I had before, except this is just cleaned up a bit. So we're importing pandas here. We are reading in our CSV files. So one is just our main data frame for our survey results. One is our schema data frame for the, schema results. And then we are setting some options here where we have the max column set to 85, so we can see all the columns, and the max row set to 85, so that we can see all of the schema. Now if you haven't been following along with the video so far, then I do have a link in the description section below that links to where you can download this data and follow along with this. Okay. So, this is a data frame here"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_2",
        "text": ". So where we are printing out df.head, this is what this returns. So this here is the first five rows of our data frame. So you can see that a data frame frame is made up of multiple rows here, and we also have multiple columns. So in the case of this data, these are survey results, but your data can be, you know, whatever your data is. But it's most likely gonna be in rows and columns, kinda like a table. So for this data, with these being survey results, each row is a survey is one person who answered the survey, and each question was their answer for that question on the survey. So for example, this respondent number 1 here, they answered that, yes, they were a hobbyist. And if you wanna know what hobbyist means, then we just like we saw in the last video, we can look at our schema data frame. So let me go ahead and print this out here. And let's look at this"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_3",
        "text": ". So if I look at what a hobbyist is, then we can see that that question was, do you code as a hobby? So that's what this data is, and that kinda gives us an idea of what a data frame is. Basically, a data frame is just rows and columns. But now let me explain how I like to think of DataFrames using native Python. So if we were only using Python and not using Pandas to store information in rows and columns, then how would we do this? Well, for those of you familiar with dictionaries, you might think that it's a good idea to store information that way. So let me pull up a new notebook here, that I have open here, with some snippets, and let's take a look at this. Okay. So let's look at this first cell here. So a lot of us are probably familiar with Python dictionaries where we have keys and values. So if I'm representing some data, in this example, it's a person, then we can use a dictionary. So first off, I have a key of first, which is gonna be the first name, and then, that has a value of Corey"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_4",
        "text": ". And then we also have keys and values for the last name and the email as well. Okay. So this dictionary here, represents data for a single person. But how would we represent data for multiple people? Well, there are probably a couple of different ways that we could do this, but the way that I like to think of this in terms of learning Pandas, is to make all of our values and our dictionaries a list. So let's take a look in the second cell here to see what this would look like. So here in the second cell, now we can see that we have a pretty similar dictionary, to what we had above. But now, instead of just a single string here for the values, I instead have a list, and our list currently just has one person. But now since this is a list, we can add more first names and information in here. So the first value of our list is going to be our first person. So if I go to the 3rd cell down here at the bottom, then now we can use this as an example to see what this would look like, with multiple people"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_5",
        "text": ". So the second value in our list will be our second person, and the third value in the list will be our third person. So if we look here, we have people, we have a key of first. So if we want the second person here, we go to the second value, that's Jane. The last name is Doe. And the email, go to the second value here, is janedoe@email.com. If you want the 3rd person, that would be John, and then 3rd value and last would be doe, then 3rd value in email is johndoe@email.com. So we can kinda think of this like rows and columns. The keys are the columns and the values are the rows. Now if you look up the definition of a Pandas data Frame online, then you'll see a lot of definitions that just say something like it's a 2 dimensional data structure. Now that might sound a little confusing, but in layman's terms, that basically just means rows and columns. Okay. So like I said here, the key for email here would be our email column and contain all of the email values"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_6",
        "text": ". And if we wanted to see, the email column, then we can just access that key. So if I come down here, into actually, let me run all of these really quick here. I think I opened this up without running these, so I wanna make sure that we have this registered. Okay. So if I wanted to see that email column, then I could simply say people and then access that email key. If I run that, then we can see that we got all of the emails. Now the reason that I wanted to show you this is because I feel like this really helped me in terms of how I think about data frames. So data frames are very similar to this, but with more functionality than what we have here in standard Python. Now, we can actually create a data frame from this dictionary and see what this looks like. So let's do that and look at some basic, dataframe functionality, and then we'll look at this more using the Stack Overflow data from the last video"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_7",
        "text": ". So here in this bottom cell, in order to create a data frame from the information that we have here, I'm gonna go ahead and import pandas. So I'm gonna say import pandas as pd, and now we can create a data frame actually using this dictionary, that we have up here. So to do that, I can just say df is equal to pd.dataframe and check the casing there, that's a capital d and a capital f, and then we'll just pass in, that dictionary that has, values as list. So if I run this, and that seemed to run okay without any errors, and now let me just print out df here. And And if I print that out, then we can see that now our data frame is, representing this in a way to where we do have rows and columns that we can visualize. So we get these people printed out in a nice table of rows and columns. Now we also have these over here, to the far left that don't have column names, this 0, 1, and 2. Now, this is an index"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_8",
        "text": ". Now, I'm not going to go much into indexes right now, because that's what the next video is going to cover, but, basically, it's a unique value for our rows. Now it doesn't need to be unique, but, again, we'll talk more about that in the video specifically on indexes. So now that we have a bit of an idea of how to think about data frames, now let's take a look at how to access information here within the data frame. So first, let's just access the values of a single column. So just like we did with the dictionary, we can access a single column just like we were accessing, the key of a dictionary. So just like I did people and email up here, I can do very similar down here and just say that I want that email column of my data frame. Now that's not actually a key, that is going to access the column of a data frame, but we can see here, that we get all of the emails back from that data frame"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_9",
        "text": ". So again, I do wanna emphasize that I only use the pure Python example so that we could get an idea of how to think about a data frame. But like I said, a data frame is much, much more than just a dictionary of lists. So, for example, we can see that when, we displayed the email column here, it doesn't look the same as when we displayed, the list of values from that dictionary, And that's because this is actually returning a series, and we can see this if we check the type. So if I check the type of this, email column here, so let me run that, we can see that this is pandas.core.series.series. So this is a series object. So what is a series? So a series is still basically a list of data, but just like with a data frame, it has a lot more functionality than just that. Now if you look up the definition of a series online, then you'll see a lot of definitions that just say it's a 1 dimensional array"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_10",
        "text": ". And that might sound a little confusing, but in layman's terms, that basically just means that it's rows of data. So again, you can think of a DataFrame as being rows and columns, and a series as being rows of a single column. So a DataFrame is basically a container for multiple of these Series objects. So again, that's important, so let me go over that one more time. So we can see that a data frame here is 2 dimensional, because it has rows and columns. So we can see here that it has, you know, first name, last name, email. Now whenever we access just the email, then we can see that we get all these emails here. Now this is a series, and I said that a data frame basically contains is a container for multiple series objects. So we can think of this email column here as a series, this last column here as a series, and this first column as a series. And also we can see where we printed out this series here for the emails, we can see that this series also has an index as well, just like our data frame did"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_11",
        "text": ". So this index is over here on the left, the 0, 1, and 2. Okay. So we can access a single column of a data frame, like we're accessing a key, just like we did here, in this cell. But you might also see some people use dot notation to do the same thing. So you might see some people do it like this. So, they might do df.email. And if I run this cell, then we can see that let me get rid of this cell here and just so we can compare these 2. We can see that this gives us the same thing. Whether we access this like a key or whether we use dot notation, this returns, the same Series object of the email values. Now whichever way that you wanna do this is really just a personal preference. I actually prefer the first way of using the brackets, and there are a couple of reasons that I prefer to use that over dot notation. First is that I like using the brackets because there is a chance that one of your columns is named the same thing as one of the attributes or methods of a data frame"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_12",
        "text": ". And if that's the case, then using the dot notation might give you some errors. So for example, if a data frame, a data frame has a method called count. So if you had a column named count, and you did and you were trying to access that count column using dot notation, then that's actually, going to access the count method from data frame instead of that count column. So that actually wouldn't work, how we did it here if you wanted to access the actual column called count, which we don't have one in this specific data frame, but if we did, then we would have to access it like this. So that's kinda why I prefer, brackets. So I'm going to be using, brackets throughout this series, but I wanted you to know about dot notation. Because if you're working with other people using Pandas, then you might see them, access columns in, using dot notation. So you need to know that it's at least a possibility. And, again, that doesn't mean that they're doing it wrong. It's just a personal preference"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_13",
        "text": ". I just prefer using the brackets. Okay. So I said that data frames have a lot more functionality than what we saw using, you know, standard Python. So let's look at some other stuff that we can do here. So let's say that we wanted to access multiple columns. Now, in order to access multiple columns, we can use the bracket notation and pass in a list of columns that we want. So if I wanted both the Last Name and Email columns, then we could say df and use our brackets just like we saw before. But now I'm going to put in a set of inner brackets here as a list of columns that I want to access. So for the first value, I'll put last for the last name. And for the second value, I'll put email for the email. So if I run this, then we can see that now, we have a data frame returned here of the last column and the email column. Now I want to emphasize again here, that I passed a list inside of these brackets here. So there are 2 pairs of brackets"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_14",
        "text": ". You can't leave off the inner brackets, because you will likely get a key error, because Pandas will think that you are passing in both of those strings as a single column name. And another thing that I want to point out here is that now that we're getting multiple columns, this can no longer be a series, Because remember, a series is basically a single column of rows. So when we get multiple columns like this, it's just returning another data frame. And in this case, it's a filtered down data frame, with just these specific columns. So we filtered out the first name column here, and we just have the last and the email. Okay. So that's how we get a specific column or multiple columns, and we can slice these as well, similar similar to how we slice a list. But I'll show that on our larger Stack Overflow dataset here in a second. Now, if you have a lot of columns and want to see all of them easily, then we can just grab the columns specifically by saying df.columns"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_15",
        "text": ". And we can run this, and we can see here, that this gives us all of our columns here. So our columns are an index of first, last, and email. Okay. So now we've seen how to get a column, but how would we get a row? So in order to get rows, we can use the loc and iloc indexers. So that is loc and iloc. So let's take a look at these. So first, let's take a look at iloc. So iLook allows us to access rows by integer location, hence the name. ILook is integer location. So if I wanted to get the first row, then we can just say d f dot iloc and then use brackets here to since this is an indexer. Use brackets and pass in a 0, and that will give us the first row. So if I run this, then we can see that the first row has a first name of Corey, last name of Shaffer, and email of coreymshaffer@gmail.com. So what that did is it returns a series that contains the values of that first row of data, which, like I said, is the first name, last name, and email, of the first person in this example"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_16",
        "text": ". And again, we haven't discussed, indexes yet, that will be in the next video, but the index here is the column names, so that we know what those values are. So up here, our index was 0, 12. But whenever we're actually accessing a row, it's gonna set that index to the column name so that we know what those values are. Because if this just said 0, 1, and 2, then we might not know what these are. And just like when we selected multiple columns, we can select multiple rows as well by passing in a list of integers. So if I want the 1st and second row, then we can just say and again, this is gonna be a pair of brackets within these brackets, because we're passing in a list to our index here. And I'm just gonna pass in a list of 0 and 1. So if I run this, then we can see that now we get the first two rows of data. And again, be sure to pass in an inner list, inside those brackets so that it does what you expect it to do. And also, we can see that now we're getting a data frame with these multiple rows"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_17",
        "text": ". Now with these iloc and loc indexers, we can also select columns as well, and that is going to be the second value that we pass into these outer brackets. So if we thought of iloc and loc as functions, then we can think of the rows that we want as the first argument and the columns as the second argument. So let me show you what this looks like. So here, we have our inner bracket. Those are the rows that we want. But now after that list, we can put a comma, and now we can specify the column that we want. Now with iloc, we can't specify an actual column name because these use integers, integer locations, so these are for integers only. So remember, our first name is the first column, the last name is the second column, and the email is the 3rd column. So if we wanted to grab the email address of the first two rows, then we can grab the column at index 2, which will be the 3rd column since all of these start at 0"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_18",
        "text": ". So if I was to pass in a 2 here and run that, then we can see that now we get the email addresses of these first two rows. Okay. So that's iloc. So now let's look at loc. So with iloc, we were searching by integer location. With loc, we are going to be searching by label. And when we are talking about labels for rows, these will be the indexes. And again, we don't have custom indexes right now, so this index is just a default range of integers. So at the moment, this will somewhat be similar with Iloc, the Iloc indexer, but we'll look at, uses or use cases with loc with actual labels in the next video when we cover indexes. So real quick, let's look at our entire data frame again. So I'm just going to print that out down here. So like I said, over here on the far left, these are our indexes. So these are the labels for that row. So if I want the 1st row, then by default, this just has a label of 0. So I can say, df.loc and pass in a 0 there"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_19",
        "text": ". And if I run that, then we can see that we get that row with that label of 0. And again, I know that that looks similar to iloc at the moment, but we'll see how to use indexes with labels in the next video. And just like with EyeLOC, we can also pass in a list to specify multiple rows. So if I wanted the 1st and second row, then just like with EyeLock, I can pass in an inner list here. So let's say that I want the 1st row and the 2nd row. So I'll run that. We can see that now we get the 1st and the second row. And again, now we can see that we are getting a data frame back, with now that we have multiple rows. And just like with iloc, we can also pass in a second value into our indexer to select specific columns for these rows. Now with iloc, we used integers, to select the columns, but now that we're using loc, we can use labels. So if we want the email column of these first two rows, then now we can just pass in a value of email"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_20",
        "text": ". So if I run that, then we can see that now, we get the email value of these first two rows. Now I didn't show this with EyeLook, but we can also pass in a list for the columns as well. So if I want the last name and the email for these rows, then instead of just passing in a string as this second value here, then we can pass in a list of strings of the columns that we want. So I'm gonna wrap this in brackets here. I know that this can get a little confusing with all these inner brackets, but let's say that we want email and we want last name. So if I run this, then now we can see that we got these specific columns here, email and last name, for these specific rows, the row with label 0 and the row with the label of 1. And also notice that the, columns display in the order that we used in our list up here within loc, which is a different, order from our original data frame. So up here, it's first, last, email. But we asked for email and last, and it gave us back in that order of email and last. Okay"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_21",
        "text": ". So now that we've seen the basics of grabbing certain rows and columns from a small dataset, now let's go back to our dataset from the last video and see how we grabbed some rows and columns from the Stack Overflow dataset. So I am going to go over here to, back to our Pandas demo here. And again, just a quick overview of the data that we have here. We're importing pandas. We have df as our main survey results here, our schema df as our schema results. We are setting some options here. This is what our main data frame, head looks like, which is the first five rows, and then this is what our schema looks like. So I'm gonna go down below our schema here, and now let's mess around with this a little bit. So let s go over a bit of what we learned and pluck out certain rows and columns. But first, let s see how many rows and columns that we have in this data frame. Now, we saw a couple of different ways to do this in the last video, but the easiest way to do this is to use the shape attribute"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_22",
        "text": ". So if I say df dot shape and run this, then we can see that we have 88,000 rows and 85 columns. So let's grab all of the responses for the hobbyist column. So again, what I'm trying to do here is if we look at our main data frame, I wanna grab all of the responses for this column right here, hobbyist. Okay? So how would we do that? Now if you remember, if you want to see what columns are available, then you could just say df dot columns to see all of these. We can see that these are kind of long. We have 85 here. But here, we have hobbyist, which is the one that we want. And that is the question where people answered if they code as a hobby or not. And in the next video, we're going to, cover indexes. I'll show how we can, you know, search, a schema data frame to find exact questions, so that we can, see what questions are what specific columns in the data frame. But right now, let's just grab those hobbyist responses"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_23",
        "text": ". So if you remember from that small dataset that we just saw, in order to grab that hobbyist column, we can just access that like a key. So if I say d f and then pass in hobbyist there, then we get a series of all of those responses. And luckily, that doesn't display the entire 89,000 rows in our browser here, but we do get the head and the tail of that data to get an idea of what those responses look like. Now real quick, let me show you something that we will cover more of further into the series, but I want to give you an idea of how powerful something like Pandas is. So let's say that we wanted to know how many of these responses were answered yes and how many were answered no. Now if we were using regular Python, then we might import the counter class or write a quick function or a loop to do this, but pandas has so much of this stuff already built in. So to get the count of unique values in this column, I can just use this value counts method to calculate this"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_24",
        "text": ". So right up here, I can just tack on a method of value_ counts. Now, again, this is going to be for a future video, but I just want to give you an idea of what Pandas can do. So whenever I add this value counts method, we can see that out of this series that we returned here for all of our answers for this hobbyist question, the value counts are 71,000 people said, yes, they do code as a hobby, and about 18,000 said, no, they don't code as a hobby. And again, we'll cover more of this in future videos when we learn more about analyzing data in-depth, but I wanted to give you a quick taste as to why it's beneficial to even learn Pandas like we're doing here. It makes this type of stuff really easy, and we could go further and plot that out and everything. Okay. But with that quick sidetrack out of the way, let s keep going and, go over the other things that we learned earlier. So we got a column here. So let me get rid of that value counts. So we have our column here"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_25",
        "text": ". So now, let's let's grab a specific row and a specific column. So let's grab the 1st row, and we'll also grab that same hobbyist column for that row. So how do we grab rows? So remember, if we wanna grab rows, that we use the loc or iloc or indexers. So I'm going to go ahead and use loc because remember that that's the one that allows me to use labels, and I'm going to use a label instead of an integer, for the hobbyist column name. Now, again, since we're just using a default index, and we can see the indexes here, 01234, since we're just using a default index instead of a custom one, our current labels for our indexes are just a range of values from 0 to 88,000 something. So in order to get the first row, I can say df.loc and pass in that label of that first index, which in this case is just a 0, and these are all of the responses from the first respondent. So this is one person's entire, survey results here"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_26",
        "text": ". Now if we wanted to see their results for just that hobbyist question, then remember, within the brackets here, I can pass in a second value, for the columns that I would like. So if I pass in hobbyist, then we can see that their answer to that whether they code as a hobby is yes. And, also, like we saw earlier, I can also pass in a list of multiple rows or multiple columns, to get the exact rows and columns that we want to see. So to get the first three responses for the hobbyist column, then instead of just passing in a single value here, then I can put in some inner brackets here and pass in a list of multiple rows. So if I pass in a list of 3 rows here and run this, then these are the first three results for that hobbyist column. Now one thing that we haven't seen yet is that we can also use slicing to grab multiple rows and columns as well. Now if you're familiar with list slicing, then this is pretty much the same thing"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_27",
        "text": ". The only difference is that our last value is going to be inclusive, at least with loc. So if we wanted the first three rows, then we could say that we want from 0 and then slice to the index of 2. And if I run this whoops. And I accidentally made a mistake here. Actually, whenever we're using slicing, we do not wrap these in brackets, So I'm gonna take that out. So for our first value, we're just saying we're no longer passing in a list of values, we're just passing in the slice of 0 and then colon 2. So if I run that, then we can see that now we get the same result that we got before. And we can do this with the columns as well. So right now, we're only getting the hobbyist column, but let's go back and look at our columns and see what columns come after the hobbyist column. So up here, these are all of our columns here where we printed them out. So let's look at a few columns after Hobbyist here. So we have open sourcer, open source, Employment"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_28",
        "text": ". So let's say that we wanted to get all of the columns from Hobbyist all the way up to this Employment column. So to do that, I'm just going to copy that. We can come down here and we can just pass in a colon and then employment, and that will do a slice from hobbyist to employment. Now I also want to point out that this is the reason that, slicing is inclusive, for these values, because imagine how much of a pain it would be if we wanted all of the columns from hobbyist to employment, but the last value here wasn't inclusive. And we had to come up here and say, well, if I went from hobbyist to employment, then I really need to pass in, you know, hobbyist to country, and country is not inclusive. That would just be way too confusing. So it's so much easier for this to be, inclusive here. So if you are wondering why they did that, then that's why they do it. So if I run this, then we can see that now for, we get these first three rows here"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_29",
        "text": ". And for the first three rows, we get all of those, responses for the columns of hobbyist, open sourcer, all the way up to employment. So now we've seen an overview of everything that we've learned about exploring our data frames and series objects so far, and how we can pluck some, you know, basic information out of these. Now there's still tons to learn about data frames and series objects, and we'll continue learning more, learning more about these throughout the Pandas series, since these two data types are the main data types that we'll be using in Pandas. So we'll be learning more about advanced filtering, queries, how to see which data type each column of our data contains, and a lot more. Now before we end here, I do want to mention that we have a sponsor for this video, and that is brilliant.org. Brilliant is a problem solving website that helps you understand underlying concepts by actively working through guided lessons"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_30",
        "text": ". And Brilliant would be an excellent way to supplement what you learn here with their hands on courses. They have some courses and lessons on data science that do a deep dive on how to think about and analyze data correctly. So if you're watching my Panda series because you're getting into the Data Science field, then I would highly recommend also checking out Brilliant and seeing what other data science skills you can learn. They even use Python in their statistics course and will quiz you on how to correctly analyze the data within the language. Their guided lessons will challenge you, but you'll also have the ability to get hints or even solutions if you need them. It's really tailored towards understanding the material. So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/ cms to sign up for free. And also, the first 200 people to go to that link will get 20% off the annual premium subscription. And you can find that link in the description section below"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_31",
        "text": ". Again, that's brilliant.orgforward/cms. Okay. So I think that's gonna do it for this Pandas video. I hope you feel like you got a good introduction to the data frame and series objects, and how to navigate through some of your data. Now, like I said, there's a lot more to learn about these data types, and some advanced filtering that we'll learn in future videos, so be sure to stick around for that. Now in the next video, we are going to be learning more about indexes. So we saw basic default indexes in this video, but we'll learn how to set the index to specific columns and the benefits of doing that in the next video. But if anyone has any questions about what we covered here, then feel free to ask in the comments section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that"
    },
    {
        "chunk_id": "ebdcb0e7f8fe49ce424b530758a9309a47e97cae00443e134c39e401df5ea8e6_32",
        "text": ". The easiest way is to simply like the video and give it a thumbs up, and also it's a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute through Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    }
]