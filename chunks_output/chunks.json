[
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": "Hey there. How's it going everybody? In this video, we're going to be learning how to alter existing rows and columns in our data frames. So in the last video, we learned how to filter out specific information, and we can use those techniques here to also modify our data. So we'll learn how to update the data for our rows and our columns, and then in the next video, we will also learn how to add and remove rows and columns from our data frames. Now, I would like to mention that we do have a sponsor for this series of videos, and that is brilliant.org. So I really wanna thank Brilliant for sponsoring this series, and it would be great if you all could check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay. So let's look at how to update data within our rows and columns"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay. So let's look at how to update data within our rows and columns. The last couple of videos, we have already seen how we can filter specific data, but now let's take a look at those same concepts and use them to make changes to our data. So let's look at updating columns first, and then we'll update some rows. So I currently have my snippets file open here that we've seen in previous videos so that we can see what this looks like on a smaller dataset before seeing how to do this on our larger dataset, with that Stack Overflow survey data. Now before we modify the columns, let's take a look at these first using the columns attribute that we have seen in previous videos. So let me add a new cell here down at the bottom. We can look at the columns just by saying df dot columns and we can see that we just have 3 columns here. So our column names are first, last, and email"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". We can look at the columns just by saying df dot columns and we can see that we just have 3 columns here. So our column names are first, last, and email. So let's say that we wanted to update the columns to be a little more specific. So let's say that I wanted this to be First Name instead of First. So there's a couple of ways that we can do this. So first, if we want to rename all of the columns, then we can simply do an assignment using the columns attribute that I just used. So in order to do this, I could just use an assignment here and just pass in a list. So I could just pass in a list of all the different columns that I want these to be. So I'll call this, First Name, Last Name, and I'll just keep Email the same. So if I run this, let's now look at these columns again. And now we can see that those column names have changed. And if I actually look at the data frame here, then they show up, changed in the data frame as well"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". And now we can see that those column names have changed. And if I actually look at the data frame here, then they show up, changed in the data frame as well. Now, I almost never use this because, this is used for when you're passing in different names for all of your columns. I usually only need to change the names of a few different columns. Now one thing that is a lot more common is the need to change something, specific about each column in our data frame. So for example, maybe, your columns are all uppercase and, you want them to be lowercase or vice versa. Or maybe your column names have spaces, and you want to replace the spaces in the column names with an underscore. In this case, we can use a list comprehension. So for example, let's say that I wanted to upper case all of the column names here. So in order to do this, I could use a list comprehension, and I could just say df columns is equal to, and now we'll just say, like, x dot upper 4xndf.columns"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So in order to do this, I could use a list comprehension, and I could just say df columns is equal to, and now we'll just say, like, x dot upper 4xndf.columns. So if I print out that data frame after making that change, then we can see that now all of our column names, have been translated to uppercase. Now, another thing that you might wanna do is remove spaces and replace them with underscores, especially if you like using the dot notation to access a column name. That doesn't work if there are, you know, spaces in the column name because that's, just not correct syntax. So if you wanted to replace spaces with, underscores instead, then what you could do is just do something similar here and say df columns is equal to df dot columns dot str, we're using the str method on this columns series here, and then we can use the replace method, from that stream class. So I can just, pass in a space and say that we wanna replace all those spaces with underscores"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So I can just, pass in a space and say that we wanna replace all those spaces with underscores. Now, this isn't gonna make any changes in our specific data frame because all of ours already have underscores. If I reverse this and I did an underscore and then a space, then we can see that now, we replaced all those underscores with spaces. That's probably not what you want though. I would rather have underscores instead of spaces. So if we do it this way, then that's how you replace all of those. But let me go ahead and set these columns back to the way that they were, before. I like lowercase, so I'm gonna change those back to lowercase there. And now, everything that we've seen so far applies to every one of our columns. But what if we only wanted to change some columns? Well, in this case, we can use the rename method and just pass in a dictionary of the columns that we want to change"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". But what if we only wanted to change some columns? Well, in this case, we can use the rename method and just pass in a dictionary of the columns that we want to change. So if I want to set the first name and last name back to what they were before, then I could say df. Rename. And now we can just pass in the columns, and we're going to pass in a dictionary of what we want here. So the key is going to be the old value, so I'll set first name back to first. So the value is going to be the new value for that column name. So we're going to map first name to first, and then I will map last name here to last. So I just have to put that in as a value there. And now if I run this now, then it might look like it worked. But if I look at my data frame, then those changes actually didn't go through"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So I just have to put that in as a value there. And now if I run this now, then it might look like it worked. But if I look at my data frame, then those changes actually didn't go through. This is another one of those methods where if we actually, want that place to or if we want that change to take place, then we have to say in place is equal to true, because it'll just let us kinda see what it would look like if it worked, but it's not actually gonna change it. So saying in place equals to true, will make that change go through. So now if I rerun this again, then we can see that those column names are set back to the way that they were. Okay. So that's a quick look at updating our columns. Now, let's take a look at updating the data in our rows, and we'll spend the majority of video learning how to update data in our rows since there is so much more that we can do here. So first, let's look at how to update a single value"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So first, let's look at how to update a single value. Now in the previous video, we saw how we can lookup values using loc and iloc and we'll use that as our starting point for setting values as well. So let's grab the row for John Doe, right here. It's row number 2. Let's grab that row and change his last name to Smith. So in order to grab that row, we can simply grab that row with the index labeled 2. So we can say df dot loc of 2. If I run that, then we can see that we get that row of first name, John, last name, Doe. And if you wanted to use a conditional, like we saw in the last video to grab that row, then that's definitely possible too. You can do that as well. Now we could have said, you know, give me rows where the first name is equal to John and the last name is equal to Doe if we wanted to do that as a conditional. So now in order to update this information, there are a couple of ways that we can do this"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So now in order to update this information, there are a couple of ways that we can do this. We can just pass in all of the new values for this row by passing in a list. So I could just say that this row I want to set this equal to, and then pass in all the new values. So I'll say that I want to keep John the same, I want his last name to be equal to Smith, and then let's also change his email as well, so johnsmith@email.com. So if I run this and then we look at our data frame, then we can see that now that last row has a new last name and a new email address. Now what if we had a lot of columns, but we only wanted to change a couple of values? So imagine, you know, with our survey data, we have, 85 different columns. So it would be a pain if we wanted to change a single row and we had to pass in or a single column, and we had to pass in this huge list of 85 different values. You know, that would really suck to need to pass in that entire list just to change those couple of values"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". You know, that would really suck to need to pass in that entire list just to change those couple of values. So in this case, we can just specify the exact columns using loc. And again, we saw this before when learning how to use the, loc to filter data. So if I wanted to just change the last name and email, then first, let's just grab those specific values. So I can say df.loc, and then I can pass in a 2 for the rows. Then if you remember that we can also pass in a list as the second value here for the columns that we want. So I'll say that I want the last and I want the email. So if I run this, then we can see that we just get the last name and we just get the email. And now we can change this as well, using the same method that we used here above, but we don't need to pass in this, the values that are staying the same. So I don't need to pass in that John value anymore since we're not changing that. So let's change this back to dough just to make sure that this worked"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So I don't need to pass in that John value anymore since we're not changing that. So let's change this back to dough just to make sure that this worked. So johndoe@email.com. So now if I run this, that should have made the assignment. And now if I look at our data frame, then we can see that those were set back. So now we have johndoejohndoe@email.com. Okay. And finally here, now let's just look at how to change a single value. You might be able to guess how it'd be done, but what we can do is just pass in a single row and a single column and just change that value. We don't need to pass in a list. So just to change that one value, I will copy this line here, but now I don't want a list of these columns. Let's just change the last name. So this won't be a list anymore. Now I'm just saying that I want row 2, the column of last, and we'll just set that equal to Smith. Whoops. Let me put that in the, string there"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So this won't be a list anymore. Now I'm just saying that I want row 2, the column of last, and we'll just set that equal to Smith. Whoops. Let me put that in the, string there. So if I run that, then we look at our data frame, then we can see that it only changed that one value. Now pandas does have another indexer called at, and this is specifically meant for changing or looking up a single value. Now honestly, I just use dot loc, from these most of the time, but the option is there if you want it. I'm assuming it's there for performance reasons. So if I wanted to change this, back since this is just a single value, then instead of using dot loc, then I could all you also use dot at. So I'll do this exact same assignment here, and I'll change this back to dough. But instead of dot loc, I'm gonna say dot at, and let's just set that back. And then if I look at the data frame, then we can see that that worked as well. And I'll be honest here. I'll have to look at the documentation"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". And then if I look at the data frame, then we can see that that worked as well. And I'll be honest here. I'll have to look at the documentation. I'm not really sure, why we would use dot at instead of dot loc when we only need to get or set a single value. Maybe it's, for performance reasons, but I personally find myself using loc and iloc even for single values. I actually did look it up in the Pandas documentation, but all it says there is that, it's there and that it's similar to dot loc. It doesn't provide any actual justification as to why we'd use it, but I wanted you to know that it's available since it's obviously there for a reason and hasn't been deprecated yet. Okay. So now, let me show you one mistake, that is very common, and that is when people try to change a value without using one of these indexers, without using .loc or .at. So, let me show you what this error or this warning would look like"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ".loc or .at. So, let me show you what this error or this warning would look like. So let's say that we have a large data frame where we want to find this John Doe person and change their last name to Smith. So one way that we could do this is to use a filter to grab that specific row. So I will come down here to the bottom, and I'll just create a filter here, and I will say that the email column of the data frame equals equals, John Doe at email.com. That is the filter that we're looking for. So if I apply this filter to my data frame, just you passing it in directly to the brackets like this, then we saw in the last video oops. And this is filt, not filter since filter is a built in, Python keyword. So if I pass in that filth variable there directly into the brackets, again, we saw this in the last video, If I run this, then we can see that that works for looking up these values. So that actually returned a data frame there that just has a single row"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So that actually returned a data frame there that just has a single row. So we could grab that last name column just by accessing, that last name from that dataframe that was returned. So if I run this, then that works as well. We can see that we got that doe value. And finally, you might think that in order to change this last name to Smith, that we could just come up here and say, okay, we got that value. Now I want to set that equal to Smith. So if I run this, then you can see that this big warning pops up here. And if we look at this warning, it says that we get this setting with copy warning. Okay. So we got a warning, but did it actually make that change to our data frame? So let's look at our data frame here. Okay. So we tried to change that last name to Smith. I've know we've I've know we've been going back and forth between these last names here, but it was Doe, and then we tried to change it to Smith, and that did not work"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". I've know we've I've know we've been going back and forth between these last names here, but it was Doe, and then we tried to change it to Smith, and that did not work. So it didn't make that change when we did the assignment this way. Now the reason that it didn't work here is a little complicated. Essentially, it's because the way that we're doing it here requires multiple operations in the background which can determine whether Pandas returns a view or a copy of our DataFrame. So when our value isn't getting set, it's because it's getting set on a temporary object that's just getting tossed out immediately after. So Pandas does a lot better job of explaining this, specific warning, and they have a little link here down to the documentation, directly within the warning itself. So if you want to learn more about this, then you can just click on that warning or go to this link, and it explains it in a lot more detail"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So if you want to learn more about this, then you can just click on that warning or go to this link, and it explains it in a lot more detail. But the moral of the story here is that when you're setting values, just use dot loc or the dot at indexers that we've already seen, and you shouldn't have any problems. So we could rerun this same operation up here, at the top. And actually, let me just copy this, so that if anybody, I will put this notebook out here on after I'm done with this. And if people wanna see this exact error, then I will leave that cell there. So we could rerun this exact same operation, but instead of using these brackets directly here, I can just say d f dot loc, and then I want to apply those filters to my rows, and then I wanna grab the, last name column, as well. So if I run it this way instead and then we look at our data frame, then we can see that that change did go through"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So if I run it this way instead and then we look at our data frame, then we can see that that change did go through. So we were able to apply that filter and then set that last name equal to Smith in that data frame. So if you ever get these warnings like this that just pop up, then definitely don't ignore them because, you know, in this case, it didn't even set the value that we thought that we were setting, so you really need to be careful with stuff like that. Okay. So that's how we would update a single row of data, but how would we update multiple rows of data? Well, there's a couple of different ways that we could do this. So for our, for our first example, let's just assume that we wanna change all of the email addresses so that they are lowercase. So this might be something that you wanna do to make the, email addresses easier to search. So to do this, we could just assign that column to the lowercase value of itself"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So this might be something that you wanna do to make the, email addresses easier to search. So to do this, we could just assign that column to the lowercase value of itself. So first, let me grab those lowercase values, and to do this we could just say, df and then we could access that email column, and then that's gonna return a series. And then we can just use this dot str class on the series, and use the lower method on that string class. So if I run this, then we can see what this returns is a lowercase version of all these emails. If I look up here in the original data frame, then these have mixed casing in there, and now these are all lowercase. Now this just returns the lowercase values of these emails. It didn't actually make that change. Now in order to make that change, we can simply assign that column to this value. So what I could do here is I could just say, d f email is equal to d f email dot string dot lowercase"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". Now in order to make that change, we can simply assign that column to this value. So what I could do here is I could just say, d f email is equal to d f email dot string dot lowercase. So if I run this, and then we look at our data frame, now those changes actually did go through and all of our emails are now lowercase. So that's one way that we can change multiple rows at once, but maybe we want to do something a little more advanced. So there are several ways that we can do this, and we'll go over all 4 popular methods, in order to do this. And a lot of people get these 4 methods confused, so let's go over each one individually and try to explain them in detail. And there's definitely a good reason, why people get these confused, because they're very similar in what they do. So the 4 methods that I'm gonna be talking about are apply, and map, and apply map, and replace. Oops. Let me spell that correctly. Replace. So first, let's take a look at apply"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So the 4 methods that I'm gonna be talking about are apply, and map, and apply map, and replace. Oops. Let me spell that correctly. Replace. So first, let's take a look at apply. So apply is used for calling a function on our values, and apply can work on either a data frame or a series object, and the behavior might be a little different than you expect for each of those different objects. So first, let's look at how apply works for a series. So when we use this on a series, it can apply a function to every value in our series. So for example, let's say that I wanna see the length of all of our email addresses. Maybe we have a website, and we wanna make sure that none of the email addresses are too long or something like that. So I I can apply the len, the length function, to each value in our series by doing something like this. I can say df and access that email column, and then I can say dot apply lin. So we'll apply that lin function"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". I can say df and access that email column, and then I can say dot apply lin. So we'll apply that lin function. And when I run that, what we can see what it's doing here is it's saying, okay, the lin of the first row email addresses was 23, So I've never actually counted up the characters in my email address, but it's telling me it's 23. And then this one says it's 17, and then then it says this one is 17. So that's a quick little way that we can use apply to grab some information about our data, but we can also use this to update values as well. So in this example, I'm just going to create a simple function that returns the upper case version of our email, but the function can be as complicated as you want it to be. So let me write a simple function here, that does what I want it to do. So I'm gonna say, let's see. I'll call this function update email, and this will take in an email value here. And then I'll just return that email in uppercase. So email dot upper. So let me run this"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". I'll call this function update email, and this will take in an email value here. And then I'll just return that email in uppercase. So email dot upper. So let me run this. Now again, this is a super basic example here. If I really wanted to uppercase the email addresses, then I would just do the same thing that we did before when we made them lowercase. But I just I'm using this as an example here. So when we apply functions, it's usually to do some more advanced updates, than what we're doing here. But let's apply this function to our email column. So to do this, we could say, df and access that email column dot apply, and then we can pass in that update email function that we just wrote. Now we don't want to execute this function, so you don't wanna put parenthesis here. You just wanna pass in, the function without parenthesis so that we're passing in the function itself and not an executed version of itself. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". You just wanna pass in, the function without parenthesis so that we're passing in the function itself and not an executed version of itself. Okay. So let me run this cell, and we can see that now we're getting back a series here of our email addresses in, uppercase. Now if, this doesn't actually change our values or change our rows like we saw before. So to do this, we can just assign that to our column. So I can just take what we wrote here, and then I can just set that series equal to, that series with that applied function. So if I run that and then we look at our data frame, then we can see that now our email addresses are all upper case. Now again, this was a pretty simple function here. All we did was return this email dot upper. Now for simple for simple functions like this, you might see people use Lambda functions as well"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". Now again, this was a pretty simple function here. All we did was return this email dot upper. Now for simple for simple functions like this, you might see people use Lambda functions as well. Now if you're not familiar with Lambda functions, basically they are anonymous functions with a specific name or without a specific name that we can use for things like this. So here's what it would look like in this example. So let's say that I wanted to convert these back to lowercase. So what I could do is I will just grab this here. Now I'm gonna use a pass in a Lambda function here to dot apply instead of passing in, that other function that we wrote. So I'll say Lambda. And the if you're not familiar with Lambda functions, then the syntax can be a little weird here. But basically, we just have a no name function here and then what we want to return. So I wanna return, x dot lower of that argument that we get passed in"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". But basically, we just have a no name function here and then what we want to return. So I wanna return, x dot lower of that argument that we get passed in. So if I run that and then look at our data frame again, then now we can see that we have the lower case version of our email. So if you're more comfortable writing regular functions, then you can do it this way. But if you are comfortable writing Lambda functions and your function isn't too complicated, then you can always do it this way like we did here. Now we're working with strings here, but you can also use this with numbers where we can run any type of calculations that we want as well. Okay. So this is how apply works on series objects. So now let's look at how apply works with data frames. So far, we've only been using this, with a series. So anytime we access a column like this, that returns a series. And again, when we ran apply on the series, it ran a function on all of the values in that series"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So anytime we access a column like this, that returns a series. And again, when we ran apply on the series, it ran a function on all of the values in that series. Now, when we run apply on a data frame, it runs a function on each row or column of that data frame. So let's see what this looks like and it should make more sense. So let me grab the example above where we ran the lin, function right here. And let me copy this and paste this down here, and then we'll take a look at what this looks like on a data frame. So again, what this gave us was the length of each value in that email series. So you might think that you can run this same apply method on the entire data frame, and it will give us the length of each value in the data frame, but that's not what it does. So let's see what that gives us. So instead of accessing a specific column, let's just say df dot apply and pass in that lin function. So if I run this, then we get this response that you might not expect"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So instead of accessing a specific column, let's just say df dot apply and pass in that lin function. So if I run this, then we get this response that you might not expect. So what's going on here is that it's not applying the length function to every value in the data frame. It's actually applying the length function to each series in the data frame, specifically the columns. So basically what this is telling us is that our first name column has a length of 3. So if we look up here at first, we can see that first has 3 values. It's telling us that last has 3 values and email has 3 values. So that's just the number of rows in each column, and we can get that same result for a specific series if we manually check the length of one of these. So if I was to say, lin, and access one of these columns, and ran this, then we can see that gives us 3. So that's basically what apply is doing here on the data frame, but it's doing it for every column"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So that's basically what apply is doing here on the data frame, but it's doing it for every column. And you can also have this apply to rows as well if you change the axis. So we can change the axis here and say, no, I wanna do this on the rows. Whoops. And I put row. I meant to put rows. So if I run this oh, and I made another mistake here. Actually, didn't need to put rows. Rows is the default. I meant to put columns. So if I put columns, then we can see that now, we get 3 as well. But now what it's doing here is it's counting it this way. So it's saying, okay, 1 or row 0, has 3 values, but it's saying, okay, those values are Corey, Shaffer, and then the email. It's not counting it downward. So basically, we wanna use functions that will make sense, to be used on a Series object when using a ply on an entire DataFrame. So for example, let's say that we wanted to grab the minimum value from each column"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So for example, let's say that we wanted to grab the minimum value from each column. Well, series objects have a min method, so we could pass that into apply and see the minimum value for each series. Now, in our sample data frame, we have all string values. So if we grab the minimum value from a series of strings, then it'll just return the 1, the first one in alphabetical order. So let's see what this would look like. So we can come down here and we can say df dot apply, and now let me pass in that series min method. So I could say pd is what we imported pandas as, pd.series.min. So if I run this, then we can see, okay, it's saying that the, one that comes first in the alphabet in the first category is Corey. The one that comes first in the last names is Doe, so that is, you know, that's a d. These two are s's. That makes sense. And then my email comes before these other two emails"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". The one that comes first in the last names is Doe, so that is, you know, that's a d. These two are s's. That makes sense. And then my email comes before these other two emails. Now it probably would have been better to take a look at this using a series of, numerical data instead, because with numerical data, this stuff, you know, obviously makes more sense. So if we used, series dot min on numerical data, then that would obviously give us the minimum values for each of those numbers. And we can use Lambda functions with this as well, but you just have to remember that the Lambda will be working on a series object. So if I come down here, I can say df dot apply, and now let's pass in a Lambda. Now this x here this x is going to be a series, it's not going to be a value. So what methods do a series have? Well, a series has a min method. So let's return the minimum value and run that, and we can see that, that gives us the same response that this one up here gave us"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So what methods do a series have? Well, a series has a min method. So let's return the minimum value and run that, and we can see that, that gives us the same response that this one up here gave us. Now, like I said, this is kind of a contrived example because we could get these same results by using the data frames min method, but I just wanted to point out how this actually works. So this is way more useful when your data frame contains numerical data. So for example, we could use NumPy to apply the square root for all of our series objects, or any type of numerical analysis like that. Okay. So running apply on a series, applies a function to every value in the series, and running apply to a data frame like we did here applies a function to every series in the data frame. But you might be wondering if there is a way that we can apply a function to every individual element in the data frame, and that's what apply map is used for. And apply map only works on data frames"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". And apply map only works on data frames. Series objects don't have the apply map method. So let me show you how this is different. So again, let's use that same built in length function and pass that into apply map. So I'll say df dot apply map, and now let's pass in that built in length function. So if I run this, then we can see that what this does is that it's now applying that length function to each individual value in our data frame. So the first name had these many characters, so first name mine was Corey, so c o r e y, that's 5 characters, and then Jane, and then John, so those are 4 characters. And we saw the length of the emails before, 23/17/17. So that's what this is doing here. It's applying that function to every individual element of our data frame. So this might be, how some of you expected the apply method to work on a data frame, but instead, we use apply map for this"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". It's applying that function to every individual element of our data frame. So this might be, how some of you expected the apply method to work on a data frame, but instead, we use apply map for this. Now, I know that this can be a bit confusing, but hopefully after seeing those differences, it makes a little bit more sense of when we would want to use which. So for example, since we have an entire data frame full of strings in this example, if I wanted all of them to be lowercase, then I could just do something like this. I could say, df dot apply map, and then I can just pass in the string dot lower method. So if I run this, then we can see that now all of the values in that data frame are lower case. Now if you had numerical data in your data frame, then you would get an error here since you can't run string methods on numbers, so you'd need to pass in a more complicated function that handles that appropriately. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". Okay. So now we've looked at apply and apply map, and hopefully those make more sense to you now. So now let's look at the map method. Now, the map method only works on a series. So map is used for substituting each value in a series with another value. So for example, let's say that we wanted to, substitute a couple of our first names. So to do this, I could say, df and access that First Name column, which is also a series, and then I can use the map method on this, And now I'm gonna pass in a dictionary of the values that we want to substitute. So let's say instead of Corey, I wanna pass in, Chris, and instead of Jane, I wanted to pass in a value of Mary. So if I run this, then we can see that that returns a series where those first names were substituted out. So Corey was the first value here, now it's Chris. Jane is now Mary. Now one thing that I do wanna point out here is that the values that we didn't substitute were converted to n a n values, not a number values"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". Jane is now Mary. Now one thing that I do wanna point out here is that the values that we didn't substitute were converted to n a n values, not a number values. Now that may or may not be what we want, and I'll show an example of this when we look at, some real world Stack Overflow examples. Now in this example, we likely wouldn't wanna get rid of these other names. So you might be thinking, okay. Well, what if I wanted to keep John, but just substitute these other names? So if that's the case, then instead of using map, we can instead use the replace method. So instead of doing what we did here, I'll just copy this, paste this in here, instead of using map, I can use replace. And if I run this, then now we can see that it's basically the exact same result here, except now we actually have, it didn't replace John with an NAN value. And again, everything that we've done here doesn't actually, change the data frame"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". And again, everything that we've done here doesn't actually, change the data frame. If we wanted to set this to the actual column, then we would have to do something like this. We could say that that df first column is equal to that replaced version of the data frame. So if I run this, and then I look at our entire data frame, then now we can see that those values were substituted. Okay. So now that we have looked at a lot of different ways of updating information in our rows and columns, Now let's go over to our larger dataset and look at some real world examples of how we can apply what we have learned here. So let me go over to my Stack Overflow survey data here. So we have our Stack Overflow survey notebook open here, that we've been using throughout this series. And again, if you would like to download these notebooks or the Stack Overflow data in order to follow along, then the links for all of this are in the description section below. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". And again, if you would like to download these notebooks or the Stack Overflow data in order to follow along, then the links for all of this are in the description section below. Okay. So let's apply some of what we learned here to this dataset. So in the last video where we covered filtering, we looked at filtering salaries over a certain amount, and the column name for salary, it is over here somewhere. It is this one here, converted comp. Now, I'm assuming that's short for converted compensation, and that is converted to United States dollars. So let's say that we wanted to rename that column to where it was a bit more clear. So instead, I'm going to rename this column to Salary USD instead of Converted Comp. So if we remember from earlier in the video, we can do this with the rename method. So if I come down here, then I can say df dot rename, and then we can just pass in the columns that we want to rename"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So if I come down here, then I can say df dot rename, and then we can just pass in the columns that we want to rename. So I'll pass in a dictionary here, but this is only going to have one value. So we want to change converted comp, and we want to set that to I'll call this salary USD. So if I run this, then let me go over here and see if this looks good. Okay. So that looks good. That changed. Now after you make sure that it made the change that you wanted it to make and that it's not a mistake, then we can actually apply that to our data frame by setting in place is equal to true. Now that's why in place equal to true is actually a good idea, because sometimes, you know, when you're working in pandas, we're always doing these different types of renames and filters and things like that, and sometimes we're gonna do things wrong"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". So it's always better to check and make sure that it made the change that you meant to make first, and then apply that change to your data frame to actually make the solidify those changes. So now, let's see if we have access to that salary USD column. And if I look at that, then we can see that we do have a salary USD column in this data frame, so that change did work. Okay. So what is something else that we can do here, to see what we have already learned? Okay. So here's an example here. So we've looked at this hobbyist column a few times in this series. This is a column where people answered on the survey whether they code as a hobby in their free time. And let's look at this column real quick. We can kinda see it here. It has a bunch of yes yes, no values. Let me actually print this out down here. So I will access that hobbyist column, and we can see that this is a bunch of yes no values here"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". It has a bunch of yes yes, no values. Let me actually print this out down here. So I will access that hobbyist column, and we can see that this is a bunch of yes no values here. So let's say that we wanted to convert these values and map all of the yes responses to a true boolean value and the no's to false. So how would we do this? Well, one way that we could do this is with the map method that we just learned about. So what we could do is we could say dphobbyist.map, and then pass in a dictionary here of the substitutions that we want to make. So for the yes values, I will convert this to a boolean of true, and for the no values, I will convert this to a boolean of false. So if I run this, then if we compare the results that we got up here and the results that we're getting down here, we can see that all the yeses are mapped to true and all the noes are mapped to false"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". Now I don't believe there is actually an in place argument, for map, so what we can do here is we can just set that series and set that equal to the mapped version of that series. So now if I run this and look at our data frame, now we can see that that entire column is now true false values instead of yes no values. Now remember, when we use map, then anything that isn't in, our dictionary here, so anything outside of a yes or no answer, would be converted to an NAN value. I think there are other columns in this survey where there are yes, no, and not sure answers or something like that. So if we only wanted to replace the yes or no values and leave the others untouched, then instead, we could use the, replace method instead. But map works for this example because I know that this column only has yes and no. Okay. So that is a quick review of some of what we learned in this video"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". But map works for this example because I know that this column only has yes and no. Okay. So that is a quick review of some of what we learned in this video. I'm not going to go over everything again since this video is already getting a little long, but I did want to show you some examples of how updating values, works when and how this can be applied to real world data like this survey. Okay. So before we end here, I would like to mention that we do have a sponsor for this video, and that sponsor is brilliant.org. So So in this series, we've been learning about Pandas and how to analyze data in Python. And Brilliant would be an excellent way to supplement what you learn here with their hands on courses. They have some excellent courses and lessons that do a deep dive on how to think about and analyze data correctly"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". They have some excellent courses and lessons that do a deep dive on how to think about and analyze data correctly. For data analysis fundamentals, I would really recommend checking out their statistics course, which shows you how to analyze graphs and determine significance in the data. And I would also recommend their machine learning course, which takes data analysis to a new level where you'll learn about the techniques being used that allow machines to make decisions where there's just too many variables for a human to consider. So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/cms to sign up for free. And also, the first 200 people that go to that link will get 20% off the annual premium subscription, and you can find that link in the description section below. Again, that's brilliant.orgforward/cms. Okay. So I think that's gonna do it for this Pandas video"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". Again, that's brilliant.orgforward/cms. Okay. So I think that's gonna do it for this Pandas video. I hope you feel like you got a good idea for how we can update the information within our rows and columns. We started off a bit simple, making changes in specific spots, and then going a little more advanced when we learned about apply, map, and apply map. Now I know that those can be confusing to some people, but hopefully you feel like you got, an understanding of how each of those work. Now originally, I was also going to show how to add and remove rows and columns in this video, but this is getting a bit long, so I'm just going to save that for our next video. So in the next video, we'll learn how to add and remove rows and columns from our data frame, and that should be a much shorter video. But if anyone has any questions about what will be covered in this video, then feel free to ask in the comments section below, and I'll do my best to answer those"
    },
    {
        "title": "Python Pandas Tutorial (Part 5): Updating Rows and Columns - Modifying Data Within DataFrames",
        "text": ". But if anyone has any questions about what will be covered in this video, then feel free to ask in the comments section below, and I'll do my best to answer those. If you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up, and it's always a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute through Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": "Hey there. How's it going everybody? In this video, we're gonna be plotting data that's continuously being generated in real time. So these real time plots would be great for plotting data that is changing frequently subscriber counts or maybe you're reading in data from a sensor and want that immediate feedback. No matter what you're doing, you're likely gonna find a use for something like this. So first, we're gonna look at a basic example where I plot some data that's directly in my Python script so that we can wrap our heads around how this is working, and then we'll look at a real world example where we're actually monitoring a CSV file. Now if you're pulling data from a real time API or a sensor of some kind, then it's pretty common to write those results to a CSV file. So we'll monitor that for changes and make updates to our plot when there's new data available. Now I would like to mention that we do have a sponsor for this series of videos, and that is brilliant.org"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". Now I would like to mention that we do have a sponsor for this series of videos, and that is brilliant.org. So I really wanna thank Brilliant for sponsoring the series, and it would be great if you all could check them out using the link in the description section below and support our sponsors. And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay. So I've got some sample code pulled up here in my script. So first, we'll look at these real time plots using this list of data directly in my script, and then we'll look at a real world example with data that I'll load in from a CSV file. Now if you've been following along with the series, then you'll likely recognize the other matplotlib code that I have here at the moment. But if not, let me go over this real quick just in case. Okay. So I have a few imports here at the top. I'm importing the random module, the count function from Iter Tools"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". But if not, let me go over this real quick just in case. Okay. So I have a few imports here at the top. I'm importing the random module, the count function from Iter Tools. We'll go over how we're using those here in just a second. I'm importing pandas here. We're importing pyplot from matplotlib. We are setting our plot styles to use the 538 style just so these look a little nicer. Now this entire section here is just the data that we're gonna be plotting just to get get our heads wrapped around how this is working right now. We'll look at that here in a second. And finally, here at the bottom, we are doing plt.tightlayout to add some automatic padding to our plots, and plt.show will just show us our plots. And as usual, I'm gonna have a link in the description section below to all of this code here if you would like to download that or copy and paste it into your editor so that you can follow along with this, video. Okay"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". Okay. So first off, we're used to using static plots that we've already seen in this series before. So for example, I have, an x and a y list here with values, and I'm plotting this with the plt.plot method, which is just going to make a basic line chart. So if I run that, then we can see that works. So that is pretty simple. But now let me delete the current data that we have in these lists, and I'll uncomment out this function that I have right here and explain what our desired outcome is. So let me remove, plt. Plot And for our x and y values, I'm just gonna set these to be empty lists. And now let me uncomment out our index and our function here. So for anyone who has never used the count function from the iterativeools library, basically, by default, it just counts up one number at a time, and each time we get the next value. So I have a function here called animate, and with this within this function, we are appending to our x values list and also our y values list"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". So I have a function here called animate, and with this within this function, we are appending to our x values list and also our y values list. Now x values is just going to append a value that is just going to count up by 1, so it's just going to be sequential. And y values is appending a random number here between 15 or between 5. So let's say that we wanted to run this function every second and plot these values that are getting appended to our list. Well, how would we do that? So to do that, we can use the func animation class from the matplotlib animation module. So let me import that and we'll take a look at how this is done. So below our other imports here, I'm gonna say from matplotlib.animationimport func animation. And now down here below our function let me make sure I spelled all that correctly. Yep. So down here below our animate function, let's tell matplotlib that we want to run that function on a specific interval so we can plot that new data"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". Yep. So down here below our animate function, let's tell matplotlib that we want to run that function on a specific interval so we can plot that new data. So to do this, I can simply say, create a variable called Annie, and I'll say Annie is equal to func animation. And now we need to pass in a few arguments. So first, we need to pass in the figure that we want to animate. Now we'll learn more about figures in the next tutorial when we learn about subplots, but basically, we just need to pass in the figure from our current plot. And to do that, we can just say plt.gcf, which is get current figure. Okay. And next, we need to pass in the function that we want to run for our animation. So that was the animate function and also the interval for how often we want to run this function. The interval is in milliseconds, so if you want one second, then you can pass in 1,000. And I think one second would be good for us in this video, but you can change that depending on your data"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". The interval is in milliseconds, so if you want one second, then you can pass in 1,000. And I think one second would be good for us in this video, but you can change that depending on your data. So I'm gonna pass in an interval equal to 1,000, which is one second. Okay. So now matplotlib is going to run this animate function every second, but currently, we aren't plotting the data. So within the animate function, we're going to plot our x and our y lists. So I'm gonna say plt.plot, and we will plot out those x values, and we will also plot out those y values. Now if we run it like this, then it will somewhat work, but there's going to be one big problem. So let me run this, and I'll show you what that problem is. So if we run this, we can see that we get an updating chart, but you can see here that this is weird. We're getting all kinds, of different colors here. So let me close this and I'll explain what's going on here"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". We're getting all kinds, of different colors here. So let me close this and I'll explain what's going on here. So the reason it's doing that is because our plot method is actually plotting a brand new line every time, but it's not clearing out, the old lines. So there are actually multiple lines getting stacked on top of each other there, but they're just being covered up, so you can't really tell. So one way we could solve this is to simply clear out our axis. And if we, do that, then every time it plots that new line from scratch, we won't have that issue with the different colored lines because it's always gonna plot the same color. So to clear the axis, we can simply run the CLA method, which I'm assuming stands for clear axis. So I'm gonna put that right above our plot. So I'm gonna say plt.cla. And now if I run this, then we can see that this looks better. It's updating our plot with those, random values each time our animate function is run. Okay"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". So I'm gonna say plt.cla. And now if I run this, then we can see that this looks better. It's updating our plot with those, random values each time our animate function is run. Okay. So that's nice, but using random data, directly within our animate function doesn't really give us an idea of how this would help us plot real world data that's coming from an outside source. So let's take a look at how we would do that. So to do this, I'm going to plot data that's from a CSV, and this CSV is going to be constantly updated by an outside source. Now this source could be data that you pulled down from an online API and put it into a CSV file. It could be data that you're saving from a sensor, anything like that. It's very common, to save data from sources like that to a CSV file"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". It could be data that you're saving from a sensor, anything like that. It's very common, to save data from sources like that to a CSV file. Now the source for my CSV data is going to be a simple Python script that's going to be continuously adding values, but it doesn't really have much to do this with this video, so I'm not gonna go into a lot of detail, how that's adding that data. But if you'd like to see how I'm doing this, then I can open this script up really quick and just give a quick overview. So let me go over this really quick and show how I'm writing random data to a CSV file, in real time. So I'm importing the CSV module, random and time. We're setting some starting values here of 0 and then total 1 and total 2 equal to a 1,000. And then we're just using the built in CSV module for this stuff. So the field names here are gonna be the headers for the CSV file. We are opening that up and writing those headers"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". And then we're just using the built in CSV module for this stuff. So the field names here are gonna be the headers for the CSV file. We are opening that up and writing those headers. And then we're saying while true, so this is just gonna continuously run. We are opening up that data in append mode, so it's going to keep appending to the CSV. And we are creating a dictionary writer, and we are writing out this info here. And the info is all of the data for those headers. So we're writing that row. And then we're also printing this out to the console so that we can get some real time feedback in the console as well. And then lastly, we're updating the values. So I'm just incrementing by x values by 1 every time. Now your x values could be anything. They could be dates. They could be, you know, anything. And now for total 1, we are saying total 1 is equal to its old value, plus a random integer between negative 68. So I just wanted some variation there"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". They could be, you know, anything. And now for total 1, we are saying total 1 is equal to its old value, plus a random integer between negative 68. So I just wanted some variation there. It can either go down or it can go up, but it's got a better chance of going up. Total 2 is equal to total 2's old value at, plus or minus negative 5 to 6. So it can also go down or up, but it's more likely to go up as well. But there's also not as much variance in these random datas here. So that'll just kinda mix up the data for those two totals there. So that's how I'm writing in real time to our data dot CSV file. So that's the live data that we're gonna be monitoring, but, again, that could be live data from any source. It doesn't matter that it's coming from a Python script. It could be anything. So now let's see how to do this. So I've got some code commented out down here at the bottom, and this just reads in all of the data from that CSV file that we're gonna be monitoring"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". So now let's see how to do this. So I've got some code commented out down here at the bottom, and this just reads in all of the data from that CSV file that we're gonna be monitoring. And if you've been following along with this series, then we've done this several times. But just in case, let me uncomment out this, and I will, show how to do this. So first, I'm gonna put this into our animate function, and then I will describe what's going on here. So I'm just gonna replace these old values that we were using, just to do some testing there. And now our new values here, we are reading in data. Csv, and that's going to be the data. Csv file that is getting live data written to it on a continuous basis. For our x value, we are grabbing the x value row. So that's gonna be all of the data for the x values in that CSV. Same for y one, we are just grabbing the total 1. For y 2, so we're gonna have 2 lines on this plot that we are monitoring. That is gonna be the total 2 column"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". Same for y one, we are just grabbing the total 1. For y 2, so we're gonna have 2 lines on this plot that we are monitoring. That is gonna be the total 2 column. So now since this is going to run that animate function every second, that means that it's also reading in the data from that CSV every second. Now we can simply plot that out. And when we plot this out, let's also give these labels so that we know which one is which using a legend. So let's pretend that these are, you know, YouTube subscriber counts and we're plotting the live counts of 2 different channels or something like that. So below our clear axis there, I'm going to plot out first, I'm gonna plot out our y one. So pass in x for our x axis, y one for our y axis. Then I'm gonna give this a label, and I'll just call this channel 1. And now I'm going to copy this and also plot out a line for y 2, and I will call this channel 2. Now when we clear our axis, it's also going to clear our legend"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". And now I'm going to copy this and also plot out a line for y 2, and I will call this channel 2. Now when we clear our axis, it's also going to clear our legend. So we're going to need to recreate that, and I will just do that down here at the bottom by saying plt.legend. And make sure you actually have that, indented here within your animate function. Now with live data coming in, I think it's usually best to specify an exact location for the legend. I've had it, you know, switch spots on me several times because, the data is being updated and it's a bit distracting. Because this tries to pick the best location by default, but if the data is constantly being updated, then it could be switched around on you. So I'm just gonna set a location here, and I'm gonna set this equal to the upper left of our plots, and you can change that based on your data. And, also, I usually put my tight layout method in here as well, so that each time it plots, it takes that into consideration"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". And, also, I usually put my tight layout method in here as well, so that each time it plots, it takes that into consideration. So I'm also going to put that here within my animate function as well. So I'll do tight layout and run that. Okay. And that should be all we need to monitor our CSV file. Now this file isn't created yet. So let me open up my terminal and I'm gonna run that script that's going to generate data for that CSV file. So I've got my terminal pulled up here. So now I'm going to, say Python and that script was called datagen.py. So I'm going to run that. And when I run that, it creates that CSV file. And now this is writing data to that CSV file, and it's gonna continue as long as we don't kill our operation here. So if we go back to our script, now that CSV is being updated with live data. So let's go to the script and see if this is picking up those real time changes. So I'm going to run our code here"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". So if we go back to our script, now that CSV is being updated with live data. So let's go to the script and see if this is picking up those real time changes. So I'm going to run our code here. And when I run this, you can see that that's already been running for some time and that these have already taken off. Now, so we can see that it's actually updating as that data is being written to that CSV file. Now let me, close this down for a sec and pull this back up in the terminal and stop this. And let me start this back over because, it was already kind of far along whenever we checked that last time. So now let me run this again, and now it's basically just started. So we can see that it just started writing data out to this CSV file. So it's picking up those live changes from that CSV file and plotting that data as it comes out. And this can be updated on any interval that you'd like"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". So it's picking up those live changes from that CSV file and plotting that data as it comes out. And this can be updated on any interval that you'd like. So if your data is only updated every 5 seconds or something like that, then you can change your interval so that it's only updating when you expect new data. That way, you don't have to check every second. So I was thinking that in the near future, maybe I'll put together a YouTube API tutorial using Python, and maybe we can actually see how to build a working version of something like this with real YouTube data. That would be a cool little project to do. So we can see here, I think, I gave my channel 1 a better chance of having better random values. And it was behind for the longest time, and now it's just constantly been going up. Okay. So we can close this down, but it's kind of fun to watch these, live plots, take off like this"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". And it was behind for the longest time, and now it's just constantly been going up. Okay. So we can close this down, but it's kind of fun to watch these, live plots, take off like this. So this was a pretty basic animation that we put together here using this live data, but there's a lot more that you can do depending on your needs. So for example, if you needed to run an initialize function for your animation, that sets things up one time before your animation, first runs. And then, to do that, the func animation class has an init func argument that you could pass in to do that. Or if you needed to pass in additional arguments to our animate function, then our, f or func animation class also has an f args argument to do that. So there's a lot more that you can do with this, and some of these animations can get pretty complex. I've seen some people use these for, drawings and math simulations and gravity simulations and all kinds of neat stuff"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". I've seen some people use these for, drawings and math simulations and gravity simulations and all kinds of neat stuff. Now there is a way that we could have updated our plot, without totally clearing out the axis, but it takes a bit more code since we'd have to also manually check our x and y limits and things like that, but it is possible to not clear out our axis here and just update the lines on the axis with the live data. So there's more than one way to do things like this, but I thought that this was, you know, good enough for this video. I think that this works well with the amount of data that we were looking at. Now Now if anyone wants to see the other more manual way, then I can also try to include that in the snippets for, this video when I upload those to GitHub. So you probably find those there if I don't forget. Okay. So that is the basics of running these cool little live plots"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". So you probably find those there if I don't forget. Okay. So that is the basics of running these cool little live plots. And we can see that now, when I run this, since we haven't cleared that out for a while, that, that data dot CSV file has just been continuously getting updated. So every time I run this, it's just, updating with the newest ones, but we still have over let's see. I think that updates that every second, so we have over 200 seconds of data here already. Okay. So we're just about finished up here. But before we end, I would like to mention the sponsor of this video, and that is brilliant dot org. So in this series, we've been learning about matplotlib and how to plot data in Python, and Brilliant would be an excellent way to supplement what you learn here with their hands on courses. They have some excellent courses covering the fundamentals of statistics, and these lessons do a deep dive on how to think about and analyze data correctly"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". They have some excellent courses covering the fundamentals of statistics, and these lessons do a deep dive on how to think about and analyze data correctly. They even use Python in their statistics courses and will quiz you on how to correctly analyze the data within the language. Their guided lessons will challenge you, but you also have the ability to get hints or even solutions if you need them. It's really tailored towards understanding the material. They've also recently released a programming with Python course, and they even have a coding environment built into their website so that you can run code directly in the browser. And that is a great way to compliment watching my tutorials because you can apply what you've learned in their active problem solving environment, and that helps to solidify that knowledge. So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/cms to sign up for free"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/cms to sign up for free. And, also, the first 200 people that go to that link will get 20% off the annual premium subscription, and you can find that link in the description section below. Again, that's brilliant.orgforward/cms. Okay. So I think that is gonna do it for this video. I hope you feel like you got a good idea for how these animations work and how you can use that to plot real time data. I definitely think this is one of the coolest things that we can do with Matplotlib. It opens up a lot of possibilities in terms of how we can plot data from APIs or sensors and get immediate feedback like this. Now in the next video, we're gonna be going over subplots. So so far in this series, we've simply been creating our plots with the pyplot object, and that works great for what we've done so far"
    },
    {
        "title": "Matplotlib Tutorial (Part 9): Plotting Live Data in Real-Time",
        "text": ". Now in the next video, we're gonna be going over subplots. So so far in this series, we've simply been creating our plots with the pyplot object, and that works great for what we've done so far. But if you want additional plots or subplots, then it's best to create your plots with the subplots method. So definitely be sure to check out that video. But if anyone has any questions about what we covered in this video, then feel free to ask in the comment section below, and I'll do my best to answer those. If you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up. And, also, it's a huge help to share these videos with anyone who you think would find useful. And if you have the means, you can contribute through Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": "Hey there. How's it going everybody? In this video, we're going to be learning how to add and remove columns from our data frames. We'll also take a look at how we can combine information from multiple columns into 1. Now in my last video on updating rows and columns, that one was pretty long, but this one should be a lot shorter. Now I'd like to mention that we do have a sponsor Brilliant for sponsoring this series, and it would be great if you all could check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Now like I said, in the last video, we saw how to update information within our rows and columns. Now we're going to see how we can add and remove rows and columns. First, let's look at adding columns. Now adding columns is going to be pretty easy for us because it's basically the same thing that we did when we were updating values"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". First, let's look at adding columns. Now adding columns is going to be pretty easy for us because it's basically the same thing that we did when we were updating values. We can simply create a column and pass in a series of values that we want that column to have. So I currently have my snippets file open here that we've seen in previous videos, so that we can see what this looks like on a smaller dataset. And as usual, if you wanna follow along, then I'll have links to the code and the notebooks and the data that I'm using, in the series in the description section below. So for example, let's say that we wanted to combine our first name and last name column into a single column and simply call that column first name. So first, in order to get a series of the first name and last name combined, we could simply say when I come down here to the bottom, We can simply grab that first column, and then we can just add these together. And I'm putting a space between there"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". And I'm putting a space between there. And then I will add in the last name. And if I run this whoops. And I missed my second plus symbol there. Now if I run this, then we can see that we get the first name and then a space, that's what this section is doing here, and then the last name. So now that we have this series of values here, we can see that we have 3 values. In order to add these to a new column with these values, we can simply say, df and then the name of what we want our new column to do to be. I'm gonna call this full name. And then I'm just gonna copy this that gave us that series before and assign this full name column to that returned series. So if I run that and then we look at our data frame, then now we can see that our data frame here has this new column, that is the first and the last name combined"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". So if I run that and then we look at our data frame, then now we can see that our data frame here has this new column, that is the first and the last name combined. And again, I'm using strings here, but you could also create a new column using the apply method that we saw in the last video to have a new column for some mathematical analysis for another column in the data frame as well. Now I do want to point out that you can't use the dot notation when assigning a column like this. We have to use the brackets like we did here, in order to make these assignments. Because if you use dot notation, then Python is going to think you're trying to assign an attribute onto the dataframe object and not a column. Okay. So, that's how we'd add a column to our data frames. Now let's look at removing columns. So now that we have our full name column, let's say that we no longer need or want our first and last name columns. So to remove these, I can use the drop method on our dataframe"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". So now that we have our full name column, let's say that we no longer need or want our first and last name columns. So to remove these, I can use the drop method on our dataframe. So it's as easy as just saying df dot drop. And now what do we want to drop? We want to drop columns, and the columns are gonna be equal to, and I'm going to pass in a list because we want to, delete multiple columns here. So I want to delete the 1st column and the last column. So if I run this, then we can see that it returns a data frame without those columns. And like we've seen before, this just gives us a view of what our data frame would look like, but it doesn't actually apply those changes. If we're happy with those changes, then we can set the in place argument to true so that it changes our data frame in place. So I can come over here and just say in place equal to true within our drop method"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". So I can come over here and just say in place equal to true within our drop method. And if I run that, and then we look at our data frame, then now we can see that our data frame no longer has that first and last name column. Now if we wanted to reverse that process and split that full name column into 2 different columns, then that's a little more complicated, but still pretty simple. So we've seen the, string split method a few times in the series so far. So let's run that on our full name column and see what we get. So I'm going to say, df and access that full name column, and now I'm gonna use that string class on our series, and then we will do a split. And we'll just split this on a space. Now split, splits on spaces by default, but I just want to be explicit here. So if we run this, then the result of that split method is that we get the first name and the last name in a list. So the first name is the first value and the last name is the second value"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". So if we run this, then the result of that split method is that we get the first name and the last name in a list. So the first name is the first value and the last name is the second value. Now if we want to assign these to, 2 different columns, then we need to expand this list so that they are actually in 2 different columns. So to do this in Pandas, we can use the expand argument. So let's see what this looks like. So this is within the split method here, and we can just pass in another argument and say expand is equal to true. So if I run this, then we can see that the results are pretty similar, but now everything that was in our list is split up into columns. So now we have 2 columns here of those split results. So now all we need to do is set 2 columns in our data frame to those 2 columns that were just returned. So we can say, I'm going to if we remember from earlier in the series, if we want to access multiple columns, then within the brackets, we can pass in a list"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". So we can say, I'm going to if we remember from earlier in the series, if we want to access multiple columns, then within the brackets, we can pass in a list. So we're gonna have 2 pairs of brackets here. The inner bracket is our list of columns. So I wanna add a 1st column and a last column, and we're gonna set that equal to this what we did here with the split method. So if I run this, then now our first and last column should have been assigned to these columns here. So let's take a look at our data frame and see if that worked. So we can see that now we added a first and a last column with the values that we returned up here. Okay. So that's how we would add and remove columns. So now let's look at adding and removing rows of data. So there are a couple of different ways that we might want to add rows to our data frame. So first, we might just want to add a single row to our data frame of new data"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". So there are a couple of different ways that we might want to add rows to our data frame. So first, we might just want to add a single row to our data frame of new data. And second, maybe we want to combine 2 data frames together into a single data frame by appending the rows of 1 to another. So first, let's look at adding, a single row of data. So we can do this with the append method. So if I want to add a single row, then I can just say df dot append, and now we can pass in our values here. So I'm just going to pass in a dictionary here and we'll pass in a first name of Tony. So if I run this, then we can see that we get an error. Now this is because this currently doesn't have an index. Now, it can sometimes be difficult to read these Pandas errors and figure out what the problem is, but in this case, it tells us exactly what to do. It says down here at the bottom, can only append a series if ignore index is equal to true or if the series has a name"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". It says down here at the bottom, can only append a series if ignore index is equal to true or if the series has a name. So let's just ignore the index and our existing data frame will automatically, assign this new row, an index itself. So up here at the top, we can simply pass in an argument of ignore underscore index and set that equal to true. Now if I run this, then we can see that that worked. We're no longer getting an error. And also down here at the bottom, we can see that this new name was appended. Now we only assign this row a first name value. So we can see here that we assign that as Tony, and all of the other column values are set to n a n, which is not a number, which is used for missing values. So you can pass in an entire series or a list of information there in order to add a single row of data of any information that you want. Now if we have a data frame that we'd like to append to our existing data frame, then we can do that as well"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". Now if we have a data frame that we'd like to append to our existing data frame, then we can do that as well. So let me create a new data frame here from our existing values up here at the top. So I'm just gonna scroll up here, and I'm gonna grab our first dictionary here of the data that we originally created our Data Frame with. And I'm going to modify this a bit. So I'm going to just have this be two names here. So I'm gonna take out these 3rd values, and then we will go ahead and up these so update these. So for the first name, I'll do Tony and Steve. And for the last name, I'll do Stark and Rogers. And for the email addresses, let's see. I'll do ironmanat avenge.com, and for the second one, I'll do cap at avenge.com. So now I'm going to create a new data frame here from this new dictionary. Now I'm going to call this df 2. So now I can just say pd dot data frame and pass in that people dictionary there, and now we should have a second data frame. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". Now I'm going to call this df 2. So now I can just say pd dot data frame and pass in that people dictionary there, and now we should have a second data frame. Okay. So now let's say that we wanna add this to our existing data frame. So one way we can do this is to simply append, the one data frame to the other. Now these have conflicting indexes and they also have columns that are not in the same order. So again, we're going to want to ignore indexes when appending these so that they are assigned indexes properly. So I'm going to say df dot append and I'm going to pass in df 2 so that it appends it to our original data frame, and then I'm going to say ignore underscore index is equal to true. And if I run this here, then we can see down here at the bottom that it added these new rows. Now if you got a warning here, then the reason for this is because we didn't pass in, all of the columns in the same order when appending these"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". Now if you got a warning here, then the reason for this is because we didn't pass in, all of the columns in the same order when appending these. So it's given us a warning here, that there are different ways that it could have sorted the columns. So don't worry too much about that, but in the future version of Pandas, it's going to set the sort to false by default, and actually Pandas version 1 was just released as I was recording this series, so this may have already been done. But we can ignore this for now, but if we wanted to, then we could pass in the value of sort equal to false and get rid of this warning. So if I went back up here and I passed in sort is equal to false, and also when I run this, it's no longer going to sort these columns here. So if I run this, then we can see that we no longer get that warning, and now it's not, sorting the columns anymore. Now unlike the drop method, if we want to make these changes permanent, then we don't have an in place method to use"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". Now unlike the drop method, if we want to make these changes permanent, then we don't have an in place method to use. Instead, we'd have to just set the data frame to this returned data frame, by copying this, and then we can say df is equal to, and then just pass in that returned data frame there. So if I run that, then we look at our original data frame, then we can see that those rows were added on there. Now, I'll be honest, some of you might wanna ask in the comment section below why some of these have an in place argument and others don't. But honestly, I'm not really sure. I'm sure there's a reason, but I'd have to do some more digging around to find out exactly why. But this append method doesn't have an in place argument like the drop method has, so we have to do it this way. Okay. So lastly, let's look at removing rows. So let's say that you're an Ironman fan, and you want to remove Steve Rogers here from our data frame"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". Okay. So lastly, let's look at removing rows. So let's say that you're an Ironman fan, and you want to remove Steve Rogers here from our data frame. Now, we can do that in almost the same way that we dropped our columns, but instead of specifying the columns that we want to drop, we can simply pass in the indexes that we want to drop. So I can come down here and say df.drop, and we can see here on the far left if you've watched my video on indexes, this has an index of 4. So let's just say we want to drop an index to of 4. So if I run this, then we could see that we still have Iron Man and Tony Stark here, but we no longer have Steve Rogers. So that 4th index was deleted. And, again, if you want to actually apply, that to the data frame, then you'll need to set the in place argument to true. Now, you might want to do something a little more complicated and drop rows using a conditional"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". Now, you might want to do something a little more complicated and drop rows using a conditional. Now, I'd probably do this using loc, like we saw in the previous video where we were learning about, filtering data from our data frame, but we can also do this using drop. So if I wanted to drop all of the rows where the last name is equal to Doe, so we have 2 of those values here, then I can pass in the indexes of that filter. So let me show you what this means and it won't be as complicated. So I can say df dot drop, and now I am going to say index is equal to, and now I am going to put in my conditional. So if you remember from the filtering video, we can actually pass the conditional here inside of our brackets. So now I can say, okay, I want a conditional where the last name of that column, equals equals doe. Now the only difference here is that we have a conditional here, but we want the indexes since we're saying index is equal to"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". Now the only difference here is that we have a conditional here, but we want the indexes since we're saying index is equal to. So just here at the end, I'm gonna use, this method and just say dot index. So if I run this, then we can see that it removed those values with the last name of Doe. Now like I said in that filtering video, I don't really like all of this being bunched up together because I think that it's hard to read, and you always want your code, to be easy to read by other developers. So I would pull the conditional out into its own variable, and instead, I would say something like this. I would say, filt for filter is equal to, and then I'll just grab our conditional here and cut that out and paste that here. And now we can say that we want our, filter applied to that data frame and then grab the index of that. So if I run this, then we can see that that gives us, the exact same result, but that's a little bit easier to read. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". So if I run this, then we can see that that gives us, the exact same result, but that's a little bit easier to read. Okay. So that's been an overview of adding and removing rows and columns from our data frames. Now before we end here, I'd like to mention the sponsor of this video, and that sponsor is Brilliant. So in this series, we've been learning about Pandas and how to analyze data in Python. And Brilliant would be an excellent way to supplement what you learn here with their hands on courses. They have some excellent courses and lessons that do a deep dive on how to think about and analyze data correctly. For data analysis fundamentals, I would really recommend checking out their statistics course, which shows you how to analyze graphs and determine significance in the data"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". For data analysis fundamentals, I would really recommend checking out their statistics course, which shows you how to analyze graphs and determine significance in the data. And I would also recommend their machine learning course, which takes data analysis to a new level where you'll learn about the techniques being used that allow machines to make decisions where there's just too many variables for a human to consider. So to support my channel and learn more about Brilliant, you can go to brilliant.org forward slash c m s to sign up for free. And also, the first 200 people that go to that link will get 20% off the annual premium subscription, and you can find that link in the description section below. Again, that's brilliant.orgforward/cms. Okay. So I think that's gonna do it for this Pandas video. I hope you feel like you got a good idea for how to add and remove columns and rows from your data frame and feel comfortable doing that"
    },
    {
        "title": "Python Pandas Tutorial (Part 6): Add/Remove Rows and Columns From DataFrames",
        "text": ". Okay. So I think that's gonna do it for this Pandas video. I hope you feel like you got a good idea for how to add and remove columns and rows from your data frame and feel comfortable doing that. In the next video, we will be learning about different ways to sort our data, but if anyone has questions about what we covered in this video, then feel free to ask in the comments section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up, and also it's a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute through Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": "Hey there. How's it going everybody? In this video, we're going to be learning how to handle missing values and also how to clean up our data a bit. Now, almost every dataset that you're going to be working with is likely going to have some missing data or data that we'd like to clean up or convert to a different data type. So we'll learn how to do all of that here. Now towards the end of the video, we'll combine what we learn here to be able to look at our Stack Overflow survey data and calculate the average years of experiences of developers who answer the survey. So be sure to stay around for that, and it's going to be great practice for what we learned here. Now, I would like to mention that we do have a sponsor for this series of videos, and that is Brilliant"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". Now, I would like to mention that we do have a sponsor for this series of videos, and that is Brilliant. So I really want to thank Brilliant for sponsoring the series, and it will be great if you all can check them out using the link in the description section below and support the sponsors, and I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay. So first, let's talk about how to drop missing values. So I have my snippets file open here, and we've seen this in previous videos. And again, if anyone wants to follow along, then I'll have a link to all of these notebooks and the data in the description section below. And as we've seen in previous videos, we'll learn how to do some of this in our smaller snippets data frame first, and then we'll see how to do some interesting stuff on our larger Stack Overflow dataset, to get this working on some real world data"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So for this video, I've added some null values here into our snippets data frame, that we didn't have before. So I added some extra first names here, and we can see that I just have one that is, a numpy dot n a n, which is a not a number value. I also imported NumPy up here at the top. This and this one here is just a none value, and then I also have some custom missing values as well. This one is just a string of NA, and this one is just a string of missing. So I have some NANs, some nones, and stuff like that thrown throughout this data so that we have some missing values. So you're going to see this a lot, that when we work with Pandas, we're going to have some missing data. And depending on what it is you're trying to do, you might want to handle this in different ways. So one thing you might want to do with missing data is to simply remove it"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". And depending on what it is you're trying to do, you might want to handle this in different ways. So one thing you might want to do with missing data is to simply remove it. So for our small data frame here, let's say that we're going to do some analysis with these people in the data frame, but if they don't have their first name, last name, and email address, then we can't do what we're trying to do, so we'll just remove the rows that don't have those values. So in order to do this, we can use the drop in a method. So let's do this, and then I'll explain the results, and go over those. So all I'm going to do down here with my data frame is I'm going to say df.dropna, and we're going to run that without any arguments right now. So when we run this, we can see that now we only get 4 rows of data here. And up here we had, let's see, 4, 5, 6, 7. So we got these 4 rows here, because they didn't have any missing values"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So when we run this, we can see that now we only get 4 rows of data here. And up here we had, let's see, 4, 5, 6, 7. So we got these 4 rows here, because they didn't have any missing values. Now we do still have our bottom row here, which has some of our custom missing values, but we'll see how to deal with these in just a second. But for now, let's go over what drop NA is actually doing here. Now what's going on in the background is that drop na is using some default arguments. So I'm going to manually fill in these default arguments and it might make more sense why we got this specific result. So by default, I'll leave that one here, and now I'm gonna fill in drop in a again, but I'm gonna put the default arguments that it already has. And the default arguments of what this is doing in the background is it has an axis set to index, and it has a how variable set to any"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". And the default arguments of what this is doing in the background is it has an axis set to index, and it has a how variable set to any. So since this is what the method was using by default anyway, we should go ahead and get the same results here, and we can see that we do. We get the same results as we did when we ran this up here. But now let me actually explain these arguments here. So first, we have the axis argument. So this can either be set to index or set to columns. That is going to tell Pandas that we want to drop NA values when our rows are missing values when it is set here to index. If we set this to columns, then it would instead drop columns if they had missing values, and we'll look at that in just a second. Now the second argument here is how, we want to drop these. Or I guess a better way to frame that is this is the criteria that it uses for dropping a row or a column. So by default, this is set to any"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". Or I guess a better way to frame that is this is the criteria that it uses for dropping a row or a column. So by default, this is set to any. So we're looking over our rows since this is set to index, and this is set to any here, so it will drop rows with any missing values. But this might not be what you want. Maybe, with this kind of analysis that we're doing, it's okay to have, you know, missing email or last name or something like that, but there just has to be something. It can't just be an entire row of missing values. So if that's the case, then we can instead change this how argument to all. And this will then only drop rows when all of the values in that row are missing. So now if I run this, then we can see that now we get back more rows than we did before because it kept the rows that had some missing values, but not all missing values. So we can see here we have an email missing, but there were some other, columns filled in"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So we can see here we have an email missing, but there were some other, columns filled in. Now, we can see that everything was missing here, but they did have an email. So all of the values have to be missing in order for, this to actually drop those. So it looks like we are missing index of 4. If I go up to my original data frame here, we can see that that index had all missing values there. Okay. Now, if I instead change this axis to columns instead of index, then it will drop columns that have all missing values. We don't have any columns that have missing values all the way down, so it should just return our original DataFrame. So, if I say columns here and run this, then we can see that that's what we get because none of these columns have missing values all the way down"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So, if I say columns here and run this, then we can see that that's what we get because none of these columns have missing values all the way down. Now if I set this back to the default and drop columns with any missing values, then we'll actually get an empty dataframe returned because we have one row that is completely empty, that we saw here, this, index of 4. So for that row, each column is going to have at least one missing value. And if we set this to any, then any column, which is even a single missing value, will be dropped, which in this case is all of them. So if I change this to any, then since we have all missing values in one of these rows, that's just gonna give us an empty data frame. Now at this point, you might be wondering, okay. Well, my data is a bit more complicated than this, and I'm doing some analysis where I want to drop some missing values, but I only want to drop but I only want to drop rows that are missing values in a specific column"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So for example, let's say that we're doing some analysis on our data, and it's fine if they don't have a first name or a last name, but we really need the email address. And if they don't have an email address, then we need to just drop those rows. So in order to do this, we can pass in a subset argument. So first, I'm gonna set our, axis here back to index so that we're dropping rows. And now, we want to pass in a subset argument. And this subset will be the column names that we are checking for missing values. So in this case, it's just going to be a single column. So I'm going to say subset is equal to, and I'm still going to pass in a list, even though this is just a single column, and I'll say email. So if I run this, then we can see that the data frame that we get back is full of rows that have, at least their email address filled in"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So if I run this, then we can see that the data frame that we get back is full of rows that have, at least their email address filled in. And again, this one down here with these NA values, that is our custom missing values, and I'll show you how to treat those as missing values in just a bit. Now in this case here, since we're only passing in a single column for our subset, our how argument here, isn't really doing much because it's only going to look at the email address for missing values. So if an email address isn't filled in, then passing in either any or all for our argument here, would trigger that row to be removed. So even if I put this as all, it should give us the same results because we're only checking one value. But we can also pass in multiple columns to our subset. So what if we said, okay, well, in order for my data to be useful, I need either their last name or their email address, but I don't need both. So in order to do this, we could just say, okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So what if we said, okay, well, in order for my data to be useful, I need either their last name or their email address, but I don't need both. So in order to do this, we could just say, okay. They need, all of the values in last name and in email. Or I'm sorry there that, I got that reversed. They don't need their last name in the email. It just can't be that all of those values are missing. So as long as the last name or the email is there, then it shouldn't drop those rows. So if I run this, then we can see that we get some values that don't have an email, but they did have a last name. And also, we would get back some values that didn't have a last name but do have an email, just like this anonymous one here. It has an email, but it doesn't have a last name. And again, that's because we passed in all for our how argument, which means for a row to be dropped, both of the subset columns needed to be missing"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". And again, that's because we passed in all for our how argument, which means for a row to be dropped, both of the subset columns needed to be missing. Now, like we've seen in previous videos, this isn't permanently changing our data frame values. If we want to permanently change our data frame, then we'd have to add the in place argument and set that equal to true, here within this method. But we've seen that a bunch throughout the series so far, so I don't think I'll go over that again here. Okay. So now let's get to these custom missing values. We can see down here, that we have a row here that has some customized missing values. So for example, maybe the people who you got our data from, didn't know what to do with missing values, so instead, they just passed in a string of NA, or they passed in, you know, a string of missing, like we have here. So how would we actually handle these? Well, it depends on how we load in our data"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So how would we actually handle these? Well, it depends on how we load in our data. In this case, we've created our data frame from scratch by, creating a dictionary and then creating our data frame here. So what we can do here is just simply replace those values with an NaN value. Now if we instead loaded in our data from a CSV file, then we could do something different. But first, I'll show this, and then we'll take a look at the CSV file later whenever I go over to the Stack Overflow data. So right here at the top where we created our data frame, I'm going to replace these values with a proper NumPy n a n value. So to do this, I'm just going to go a couple of lines down here, and we've seen this in previous videos, but we can use this replace here, and I'm replacing all the values in the entire data frame. So anytime we see a string of na, I'm going to replace that with numpy.na n, and again, I am importing numpy up here as MP. So that's where I'm getting, I'm able to use NumPy"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So anytime we see a string of na, I'm going to replace that with numpy.na n, and again, I am importing numpy up here as MP. So that's where I'm getting, I'm able to use NumPy. And then I want to say in place equal to true because we actually want to modify that data frame. So if I run that, then that would replace those values, but I'm also gonna place, replace this string of missing as well with np.nanvalues, and I want to do that in place as well. So let's go ahead and run this. That should replace those values. And now, if I look at our data frame here, then we can see that we no longer have that string of missing or NA. These are now all NA values. And now, if we go back through and we run our cells where we dropped NA values, then these custom values should have been replaced, and it should treat those as missing values. So right here, we can see what our previous result was where we got this index of 6 with those custom values. If I rerun this now, we can see that that's gone"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So right here, we can see what our previous result was where we got this index of 6 with those custom values. If I rerun this now, we can see that that's gone. And the same with here, if I rerun this, then that is gone as well. Now if you don't actually want to make any changes, and we just want to see if certain values would or wouldn't be treated as NA values, then we could just run the NA or is NA method, and get a mask of values, as to whether or not these classify as NA or not. So let me just show you what I mean here. So I could say df. Is NA, and this is just going to give us a mask here of values that, are whether or not they are classified as an NA value. So we can see that our row 4 here, was all NA values, and so same thing with our row 6, and we can see some other missing values throughout here as well"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So we can see that our row 4 here, was all NA values, and so same thing with our row 6, and we can see some other missing values throughout here as well. Now sometimes, especially when we're working with numerical data, we might want to fill our NA values with So So for example, let's assume that we were calculating grades for assignments or something like that, and you had some assignments that were NA because the student never turned in the assignment. Well, at that point, you could just decide if you wanted to score all missing assignments as zeros so that you could properly calculate up the grades. So to do something like this, we can use the fill in a method. So for example, I could say something like this. If I do a df.fillna, and then pass in a value, just to show you exactly what this is doing, I'm gonna fill all of our missing values with this capitalized missing string here"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". If I do a df.fillna, and then pass in a value, just to show you exactly what this is doing, I'm gonna fill all of our missing values with this capitalized missing string here. And if I run this, then we can see that all of those missing or all of those NA values were filled with this string capitalized as missing. Now, like I said before, I don't do this a lot with certain strings. I found this, to be most useful for numerical data, depending on how you're doing your calculations, but you might want to give n a values a value of 0 or negative one or something like that. So if it would make sense with your data and you had numerical data to replace your missing values with a 0, then you could just run df dot fillna 0. And if I go ahead and run this, then we can see that that works on our data frame as well"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". And if I go ahead and run this, then we can see that that works on our data frame as well. And again, just like with our other methods, if you want those changes to your data frame to be permanent and carry over into other cells, then simply just add that in place argument and set that to true to make that change permanent. Okay. So now let's look at another common thing that we're likely going to need to do with a lot of our data, and that is casting data types. So I have another column in my snippets here that I didn't have in previous videos. And I have up here, if we look, this is this age column. So let's say that we wanted to get the average age of all the people in this sample data frame. Well, right now, these might look like numbers when we print them out in our data frame down here, but the these are actually strings, and we can see this if we look at our data frame data types. So to do this, we can say dfdot d types, and that's not a method, it's just an attribute"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So to do this, we can say dfdot d types, and that's not a method, it's just an attribute. So if I run this here, then we can see that it says all of these columns are objects. And when it says it's an object, it likely means it's a string or a mix of different things. So in the latest version of Python or Pandas, I'm sorry, they actually updated it so that there's actually a string data type now, but I'll do a video on those Pandas version updates at the end of this series since they actually released that updated version, as I was writing this course. But don't worry, there's not a lot that has changed to where, what you learned here will be outdated or anything like that. It's still mostly the same. But we can see here that our age column is a string because it's, this object data type. So if we wanted the average age, then it wouldn't work as it is now. So let's just see what this error looks like"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So if we wanted the average age, then it wouldn't work as it is now. So let's just see what this error looks like. So I'm going to grab the mean of that age column, and if I run this, then we can see that right now we get an error. And if I scroll down to see what this error was, it says can only concatenate, str not int to string. Now that might not be the most easy to understand error right there, but basically it's telling us that because that column is strings and not integers. So we need to convert that column to numbers instead of a string. Now there's a caveat, when doing this and this might throw some people off. So when we have n a n values in a column that we're trying to convert to numbers, then you need to use the float data type, and that's because the n a n value is actually a float under the hood. Let me go ahead and show this just to show you what this looks like. So I'm gonna look up the type of np.nan, and we can see that that is a float"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". Let me go ahead and show this just to show you what this looks like. So I'm gonna look up the type of np.nan, and we can see that that is a float. So if we try to convert this column to integers, then it's going to throw an error when it runs into those n a n values because it can't convert those. So if I was to say, d f and of age is equal to, and now let's try to convert these to integers. So the way that you cast data types here is we can just say, okay, I want the age column as type, and now we want to pass in the type that we want. If I try to convert these to integers, then this is going to give us an error because we have some NaN values. So we can see here, int argument must be a string, not none type. So when you're trying to convert these to numbers and you have those NaN values, you basically have 2 options here. If your column didn't have any missing values, then this would just work fine. We wouldn't even run into this error"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". If your column didn't have any missing values, then this would just work fine. We wouldn't even run into this error. But if it does have missing values, then you can either convert those missing values to something else, like a 0 using the fill in a method that we saw before, or you can just cast that column to a float instead. Now, I think this would be a bad idea to convert those missing values to a 0 or some other number, because we're trying to compute the average in this case. But depending on your data, that might be what you wanna do. But I'm gonna go ahead and just convert these to floats, so those NaN values stay missing values. So instead of an int here, I'm just gonna convert this to a float, and if I run this, then that seemed to have worked. So now, we can look at the data types again. So I'll say, d f whoops. Sorry. I wasn't typing in that cell. I can say, d f dot dtypes. And if we look at this, then we can see that now our age is a float object here"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So I'll say, d f whoops. Sorry. I wasn't typing in that cell. I can say, d f dot dtypes. And if we look at this, then we can see that now our age is a float object here. So now, let's see what happens when we try to take the average of that column. So I'll say df dot mean, and if I run that, then we can see that we get the average value for those ages. Now if you have an entire data frame of numbers or something like that that you are trying to convert all at once, then the data frame object has an as type method as well. So you could just say, df. As type, and then pass in whatever data type you're trying to cast everything to, and just convert everything in the DataFrame at once. But we have some mixed columns here, so we don't want to do that. Okay. So we've been looking at our small dataset right now to test this stuff out, but now let's take what we learned here and learn how this applies to real world data and do some analysis on our Stack Overflow survey data. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". Okay. So first of all, I mentioned earlier that if we had custom values for missing data, then it's a little bit easier to handle these when loading in a CSV. And what I'm talking about up here is up here at the top where we replaced these custom missing values. Let me show you how we would do this same thing, but loading in a CSV instead. So I'm gonna switch over here to my Stack Overflow survey data. Let me go ahead and rerun this just to make sure that, all of this stuff is running. Okay. So this notebook is still running. That's good. And again, this is that Stack Overflow data that we have been using throughout the series. And if you would like to follow along, then I do have a download link for this in the description section below. Okay. So if I wanted to ignore those custom values when loading in a CSV, then we can simply pass in an argument of a list of values that we want to be treated as missing. So here's how we would do this"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So if I wanted to ignore those custom values when loading in a CSV, then we can simply pass in an argument of a list of values that we want to be treated as missing. So here's how we would do this. If we had some custom missing values here in this CSV file, then I could simply create a list here of those missing values, and I will just call this NA Vals, and now I'll pass in a list of those. So let's say that we have some values that are a string of n a and a string of missing. So now what we could do here is just add in an argument and say n a values is equal to, and then that list that we just created. And if we run that, then we shouldn't get any errors. And when it reads in that CSV, then it will treat that list of values, as missing values and give them an NaN result. Now in this survey here, they did a good job of not having any weird occurrences like that, so that actually shouldn't change anything. Okay. So now, let's look at an interesting problem with casting some values"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". Okay. So now, let's look at an interesting problem with casting some values. So let's say that for the developers who answered this survey, we wanted to calculate the average number of years of coding experience among all of them. Now, that might be a good thing to know to compare your experience against the average. But let's look at what this or why this might be difficult to calculate with this dataset. And us calculating this solution is actually going to apply several concepts that we've learned so far throughout this series. So the column to view the answer for, this question in the survey is called year's code. So let's look at some of these answers. So I'm just going to look at the top ten answers for year's code. So I will do a dot head, and let's look at the top ten. So if I run this, then at first glance, this doesn't really look like it'll be a problem. We just have a bunch of integers and the number of years that different respondents have been coding"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So if I run this, then at first glance, this doesn't really look like it'll be a problem. We just have a bunch of integers and the number of years that different respondents have been coding. So you might think that we can just grab the mean, of this column simply by saying, okay, if we just have a bunch of integers here and some NaN values, that's fine. Let's just grab the mean of that column. But if I run this, then we get an error. And if I scroll down here, then it says can only concatenate string, to string. And we saw this same error in our smaller dataset where the column was actually being loaded in as a string instead of numerical data, and we should know how to handle this by now since we did it in the smaller dataset. So let's try that. So let's try to convert this to floats and then take the average. So let me go back up here to the top where we ran this, and instead of running the mean here, I'm gonna say, okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So let's try that. So let's try to convert this to floats and then take the average. So let me go back up here to the top where we ran this, and instead of running the mean here, I'm gonna say, okay. Well, let's convert this to a float so that we can grab that average. So I will say as type, and we wanna convert this to a float since there are NaN values. So if I run this, then we still get an error. So we didn't get an error in our smaller dataset here. So if I scroll down, then it says, could not convert string to float, and the string that it couldn't convert was less than 1 year. So this might be something that we didn't expect here. So obviously, we don't just have numbers and n a n values in this column. There is actually a string value that respondents could select that is equal to this string of less than 1 year for coding experience"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". There is actually a string value that respondents could select that is equal to this string of less than 1 year for coding experience. So let's look at all the unique values of this of this column so that we can see exactly what's in here in case there are more strings like this, and I don't believe we've actually seen this in the series yet. Maybe we have. I can't really remember. But if we want to view unique values of a Series, then we can simply use the unique method. So we could also use the value counts method that we've seen several times before if we wanna count all the unique values, but we don't really wanna count them. We just wanna see all the unique values in this column. So to do this, I'm gonna say df and then access that years code column dot unique, Dot unique, that is a method. So if I run this whoops. And I spelled this wrong. Sorry. Having a hard time typing today. Okay. So if I run this, then this gives us all of the unique values of that column"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So if I run this whoops. And I spelled this wrong. Sorry. Having a hard time typing today. Okay. So if I run this, then this gives us all of the unique values of that column. And as we'd expect, there are a lot of numbers, but we see that, we also have some strings that are mixed throughout these numbers. Now we also have NaN values here, but we're not gonna worry about those. We just want to ignore the NaN values because that's just people who didn't answer the question. But we can see that the strings that we have throughout here are less than 1 year and more than 50 years of coding experience. Okay. So those are our only string values. So I am going to replace those with numbers so that we can get an idea of the average years people have been coding. So let's go ahead and replace less than 1 year here with a 0 since that's basically the same thing. If somebody has been coding for less than a year, then they've been coding for basically 0 years. So to do this, I can say df"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". If somebody has been coding for less than a year, then they've been coding for basically 0 years. So to do this, I can say df.yearscode and access that column, and then we can just replace that value of less than 1 year, and let's replace that with a 0. And we also want these to be in place equal to true, because we actually want to modify that data frame. So if I run that, then it should make that replacement. And now I'm also going to replace the value for more than 50 years here. And this is going to skew our results a bit depending on how we wanna do this. I'm simply going to replace this with the value of 51. There may be some people who have several more, more years of coding experience than 51 years, but I can't imagine that it would be that many people who have, you know, coded many years greater than 50. So I'm just gonna fill this in with 51, but like I said, depending on what we pick here, it could affect our results slightly, but not by a lot in this case"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So I'm just gonna fill this in with 51, but like I said, depending on what we pick here, it could affect our results slightly, but not by a lot in this case. So I'm just going to grab this same replace value here, and instead, I want to replace more than 50 years, and I'm gonna replace that with a value of 51. So now let me go ahead and run this. And if we want to look at these unique values again, then we could look at these, and now it doesn't look like we have any strings in here. But we can see here that this is still a dtype of object, which means that it's not actually reading this in as floats. So if we scroll back up here a bit oh, actually, I think I overwrote that line. Yes, I did. So let's just try that again. So what I wanna do here is I want to convert this to a float, and this is what, gave us an error before because we had these strings in here and it didn't know how to convert these to a float"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So what I wanna do here is I want to convert this to a float, and this is what, gave us an error before because we had these strings in here and it didn't know how to convert these to a float. But now, we should just be able to see say, okay, I want to convert that as type, set that to a float. So let's run that, and we didn't get an error this time, so that's good. And now we should be able to view the average numbers of or average number of years of coding experience of the developers who filled out this survey. So to do this, I'm just going to say, okay, def data frame, access that column, and grab the mean of that column. So if I run this, then we can see that now we get that average back. So the average that we got here was about 11 and a half years of coding experience, as the average years for developers who answered this survey. And now you can do other analysis on this as well"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So the average that we got here was about 11 and a half years of coding experience, as the average years for developers who answered this survey. And now you can do other analysis on this as well. So for example, if we wanted to see the median, then I could run that, and the median comes back as 9 years of coding experience. So hopefully, that real world example helped explain why it's important to know how to cast these values and understand understand what's going on there. There's always going to be data that is messy or not in the format that we want it in, so knowing how to handle these missing values and cast these values to different data types is really going to be essential, when working with Pandas. Okay. So before we end here, I'd like to thank the sponsor of this video and mention why I really enjoy their tutorials, and that is Brilliant"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". Okay. So before we end here, I'd like to thank the sponsor of this video and mention why I really enjoy their tutorials, and that is Brilliant. So in this series, we've been learning about Pandas and how to analyze data in Python, and Brilliant would be an excellent way to supplement what you learn here with their hands on courses. They have some excellent courses and lessons that do a deep dive on how to think about and analyze data correctly. For data analysis fundamentals, I would really recommend checking out their statistics course, which shows you how to analyze graphs and determine significance in the data. And I would also recommend their machine learning course, which takes data analysis to a new level where you'll learn about the techniques being used that allow machines to make decisions where there's just too many variables for a human to consider. So to support my channel and learn more about Brilliant, you can go to brilliant.org forward slash c m s to sign up for free"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". So to support my channel and learn more about Brilliant, you can go to brilliant.org forward slash c m s to sign up for free. And also, the first 200 people that go to that link will get 20% off the annual premium subscription, and you can find that link in the description section below. Again, that's brilliant.orgforward/cms. Okay. So I think that's gonna do it for this Pandas video. I hope you feel like you got a good idea for how to handle these missing values and cast our data to different data types, so that we can do exactly what we want to do in terms of analyzing our data. Now in the next video, we're going to be learning how to work with dates and time series data. Now, I've been using the Stack Overflow survey data for this entire series, because I love being able to show you all real world examples of how these concepts apply"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". Now, I've been using the Stack Overflow survey data for this entire series, because I love being able to show you all real world examples of how these concepts apply. But our Stack Overflow survey data doesn't have any time series data that we can actually work with, so I'm going to be using a different dataset for the next video. And I still haven't narrowed down exactly what I'll be using, but I'll be sure that it allows us to do some analysis on some real world data like we've been doing. So maybe we'll use time series data to, you know, analyze cryptocurrency rates over time or something like that. But if anyone has any questions about what we covered in this video, then feel free to ask in the comments section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that"
    },
    {
        "title": "Python Pandas Tutorial (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Values",
        "text": ". And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up, and also it's a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute through Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": "Hey there. How's it going everybody? In this video, we're gonna go over the basics of filtering data from DataFrames and Series objects. So for example, if we wanted to look at our survey data and only look at people who know Python, then we can filter that data out. Or maybe we only want to see results from a country, or people that have a specific salary range, anything like that. We can do all of that by filtering out data from our Series and DataFrame objects, and we'll learn how to do that in this video. So filtering is one of the main things to learn with Pandas because it's basically how we begin every project, by filtering the data that we want from the data that we don't. Now, I'd also like to mention that we do have a sponsor for this video, and that is brilliant.org. So I'd really like to thank Brilliant for sponsoring this series, and it would be great if you all could check them out using the link in the description section below and support the sponsors"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ".org. So I'd really like to thank Brilliant for sponsoring this series, and it would be great if you all could check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay. So first of all, let me show you something that's going to be the basis for our filters. If we perform some basic comparisons using our data frames, then we'll get back some interesting results. So let's see what this looks like. So right now, I have my Snippets notebook open that we've seen a couple of times throughout the series. And at the bottom here, I'm going to make a basic comparison and see what the result looks like. So let's say that I wanted everyone that has the last name of Doe from our data frame. There should be 2 since we have a Jane Doe and a John Doe here in our data frame"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". So let's say that I wanted everyone that has the last name of Doe from our data frame. There should be 2 since we have a Jane Doe and a John Doe here in our data frame. So in our bottom cell here, I'm going to put a comparison that says d f, and then we want to access that last name column. And now we can just say if that last name equals equals Doe. So if I run this, then what we get back is a series object. And this might not be what you expected. So maybe you thought, we would just get a data frame back with all of the values that met our, criteria. But what we got back is a series with a bunch of true false values. Now these true false values actually correspond to our original DataFrame. And the true values are the rows that met our filter criteria, and the false values are the rows that didn't meet our filter criteria. So you can basically think of this like a mask"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". And the true values are the rows that met our filter criteria, and the false values are the rows that didn't meet our filter criteria. So you can basically think of this like a mask. So So we can see here up here in our simple data frame, the last name of Shaffer is false, and these two last names here with Doe are true. So this is a filter mask when, and when you apply it to a Data Frame, it will give you all of the rows that meet that filter criteria. So now let's apply this filter to our data frame. So first, I'm going to assign this, this return series here to a variable, and I'm just going to call this variable filth. So I'll say filth is equal to, and then this comparison here. Now filter is a built in Python keyword, so be sure to use something else. Anytime, I assign these to variables, I usually, just use, this field, keyword here. Or not keyword, but variable name. Now I also usually like to wrap my entire filter in parentheses because I find it easier to read"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". Or not keyword, but variable name. Now I also usually like to wrap my entire filter in parentheses because I find it easier to read. So this isn't gonna change anything, but I'm just gonna put this entire thing here within parentheses, so that I can see that this, assignment here is separate from this equal sign. Okay. So now we have this filter here. And remember that this, this filled variable here is equal to this series here of true and false values. And now let's apply this filter to our data frame. And we can do this in a couple of ways. So you might see some people do it like this. We can just pass that directly in, like we are searching for a column. We can pass in a filter there. And if I run this oops. And I got an error there because I did not run this cell to set that variable. So I'll rerun that. And now if I run this, then now we can see that we get a data frame back where it returned all of the rows that have the last name of Doe"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". So I'll rerun that. And now if I run this, then now we can see that we get a data frame back where it returned all of the rows that have the last name of Doe. Now, we only assigned the filter on a different line because I think that's easy to read, but you might see some people, put these comparisons directly in the brackets for the data frame. So you might see something like this. So I'm just going to, comment that out right now and just grab this entire filter here. You might see some people do it like this and just paste it or put it directly in there. And we can see that that works too. Now, I think that that's a little more difficult to read than just assigning this to a variable. So I'm just going to, use that as a variable. But, you should know that it is a possibility, since you will see some people, put the filter directly in there. Okay. So that's one way of narrowing down those rows"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". But, you should know that it is a possibility, since you will see some people, put the filter directly in there. Okay. So that's one way of narrowing down those rows. Now another way that you can do this, and the way that I prefer to do it, is to use the dot loc indexer that we've seen a few times now. Now. And I'll talk a bit, about why I prefer this in a second, but if we pass in that series of booleans into dotloc, then it should give us the same results that we currently have. So if I say df dotloc and pass in that same filter, then we can see that we get the exact same thing. This here gave us the same results as our dotloc down here. So this is one reason why Pandas can be a bit confusing to people because there are multiple things that you can pass into these different brackets, to get different results. So like I said before, .loc is used to look up rows and columns by label, but if you pass in a series of booleans, like we did here, then you can also filter data out"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". So like I said before, .loc is used to look up rows and columns by label, but if you pass in a series of booleans, like we did here, then you can also filter data out. Now the reason that I like using .loc for this is because we can still grab the specific columns that we want as well. So for example, if I wanted the email column, then I could simply say, pass in a second value here into dot loc and just say that we want that email column. If I run that, then we can see that we get the emails, that match those last names. So remember, the first value to dotloc are the rows that we want, and the second value here, are the columns that we want. So since I wanted the email column, it gives me a series of those emails where the last name is equal to Doe. Okay. So real quick, let's go over some other ways to filter data out here. So first, let's go over the and and or operators"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". Okay. So real quick, let's go over some other ways to filter data out here. So first, let's go over the and and or operators. Now we can't use the Python built in and and or keywords for our filters, so we're going to be using some other symbols. And the symbolmultiplymiddles that we're going to use here are the ampersand for and, let me write these out here, the ampersand for an and, and this vertical bar for an or. So these symbols carry over from other programming conventions, so you may have seen them before. So, for example, let's say that we wanted our filter to get all of the rows where the last name is Doe and the first name is John, which should only return this one result. So in order to do this, we can go back up to our filter here, and I'm just going to get rid of, this cell here, because I'm just going to be using dot loc from now on"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". So in order to do this, we can go back up to our filter here, and I'm just going to get rid of, this cell here, because I'm just going to be using dot loc from now on. So now with our filter here, let's say that we want a last name equal to doe, and, which we're going to use the ampersand, and we want the first name equal to John. So I will put that in here. And I also, let me actually separate these out as well. I like to each one wrapped in parentheses. I think it makes it a bit easier to read. So now if I rerun that filter and then rerun our dot loc, then we can see that now we're just getting, that single email address. And that email again is where all of the last names were equal to Doe and the first names were equal to John. So in this case, it's just one result. So now let's look at an example using the OR operator. Now for this we can use the vertical bar character. So let's say that I wanted a filter where the last name is equal to Shaffer or the first name is equal to John"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". Now for this we can use the vertical bar character. So let's say that I wanted a filter where the last name is equal to Shaffer or the first name is equal to John. Okay? So if I wanted the last name to be equal to Shaffer, or the first name is equal to John, for the or, we're gonna do a vertical bar character there. So now if I rerun this, then we can see that we get back all of the rows or all of the email addresses, where the last name is equal to Shaffer OR the first name is equal to John. So in this case, it was these two rows here. Now we can also get the opposite of a filter. So let's say that I wanted to get the complete opposite of this filter, where we want all of the rows where the last name isn't Shaffer and the first name isn't John. Now I could go in here and fiddle around with this query that I currently have, trying to get everything right, or I could simply add in a tilde at the beginning of this filter and it will give me everything that didn't match that filter"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". So if I just come in here and put a tilde there, then that is going to, negate that filter and give me the opposite of those results. So we you we can see here that we get Jane Doe, because that are that is all the results where the last name was not Shaffer or the first name wasn't John. So this goes back to truth tables that some of us may have studied in school. Now if anyone is unfamiliar with truth tables, then let me know and maybe I can make a future video on that subject. But it's more mathematical related than programming related, although the 2 do overlap very frequently. Okay. So that kinda covers the basics of filtering on a small data frame, But now let's go back to our larger dataset of survey data and look at some real world examples of some filters that we might want to take a look at. So I'm gonna bring up my other notebook here, and here we have the Stack Overflow, survey data that we've been using throughout the series"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". So I'm gonna bring up my other notebook here, and here we have the Stack Overflow, survey data that we've been using throughout the series. And again, if you would like to follow along, then you can find a link to this code and the data in the description section below. Okay. So now that we've learned about some basic filtering, let's see if we can run some filters on our survey data here. So for example, let's say that we wanted to look at the data for people who are making a salary over a certain amount. Now maybe we wanna wanna take a look at what languages are earning the higher salaries or something like that. So in order to do that, I'm going to first create a filter. Now if you don't know which column in the DataFrame gives the salary, then you can always find that using the schema DataFrame that we've seen throughout the series that tells us what what, each of these columns here, means"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". But for the sake of time here, I'll just tell you that the column for salary, if I go over here, I think I can find it here pretty quick. It is this converted comp, right here. So if we scroll down through some of these survey results, we can see that this person says that they make, about 9,000. This person makes 61,000, and these are converted to, USD. And real quick, let me reload this page here, just to make sure that I have, run all of these cells and that I'm, that all of these variables here, have been, initialized. Okay. So if we wanted to get a filter, with all of the high salaries, then let me come over here and, again, I will copy this column name here. And now let's make a filter. And I'll call this filter, High Salary. And I'll set this equal to, a conditional here where we're saying that we want the df of, this converted comp column of our data frame. We want that to be over, let's say a high salary is over 70,000"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". We want that to be over, let's say a high salary is over 70,000. You know, this is, kind of, subjective, but we'll do that as a filter here. Now let's apply that filter to our data frame. So just like we saw before, I can say df.loc and I can pass in that high salary filter there. And now we can see that, we'd get some results here, and this isn't all of our respondents. We can see that now it's respondent 6 and 9 and 13. So if I scroll over to our, to our converted comp, then all of these salaries here should be over 70,000, and it looks like they are. Now in order to narrow these columns down a bit, let's just grab a certain number of columns. So I'll grab the country, the programming languages, and the salary. So to do this, remember we can just pass these into dot loc. So up here, where we are doing dot loc, I'll put in a comma here. And now I'll put in a list for the columns that we want. And let's say that we wanna get the country"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". So up here, where we are doing dot loc, I'll put in a comma here. And now I'll put in a list for the columns that we want. And let's say that we wanna get the country. We also wanna get the programming languages that they that the, these people have worked with. And this, here and like I said, you can look all of these up in, the schema, but this is under languages worked with. We can see that this person knows Java, R, SQL, and so on. So I'll paste that in as one of the columns that we want, And, also, I will get the converted comp. So I will paste that in as well. And now let's run that. Now we can see that we get, not only the people who, meet this high salary standard, filter that we set, but also we're getting the we're only getting the country, the languages that they know, and their salary. So our filter does seem like it is being applied correctly, and that this is working nice"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". So our filter does seem like it is being applied correctly, and that this is working nice. So now that I'm actually seeing, the countries here, that reminds me that we might wanna do some filtering with multiple values. So for example, you know, my YouTube audience comes mainly from the United States, India, the United Kingdom, Germany, and Canada. Well, that's where the largest, percentages of the audience of people who are watching the videos come from. So let's say that I wanted to filter out the survey results here so that I only see the results from those 5 countries that I mentioned. Now I could create a super long filter up here, where I say, you know, if the country is equal to the United States, or if the country is equal to India, or if the country is equal to the United Kingdom, but that would take up a lot of space. Instead, let's just create a list of those countries, and then I'll show you a neat trick that we can do, to filter those out"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". Instead, let's just create a list of those countries, and then I'll show you a neat trick that we can do, to filter those out. So now up here instead of using this high salary, filter here, I'm just going to call make a list of countries here. And I'll set this equal to I'm kind of a slow typer here, so let me type these out really quick. Okay. So now if we want all of the survey results, where, the respondents said that they were from one of these 5 countries, then I can simply say I'll set a new filter here. Actually, let me do that up here. I'll set a new filter and I'll set this equal to, d f of country, so, where the country dot is in, and we want the country to be in this list of countries here. So I'm going to run that cell, and now let's apply that filter to our data frame. So if I run this, and just to narrow down these results to make sure, to where we can see the country United Kingdom, United States, Canada, India. So it looks like that applied, correctly as well"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". So if I run this, and just to narrow down these results to make sure, to where we can see the country United Kingdom, United States, Canada, India. So it looks like that applied, correctly as well. Now let me show you one more common filter operation that you'll probably use a lot. So we can actually use string methods within Pandas as well to do some alterations to our data frame, or in this case, to help with a conditional. So let me show you what I mean. So let's say that we only want to look at people who answered that they knew Python as a programming language. So let's see how we do this. So first of all, the column that lists the programming languages that each person said that they know is that language worked with column. So let's see what this looks like. So in this here, I'm just going to grab that language worked with column. Oops. And I spelled, language wrong. So language worked with. Is that right? Yep. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". So let's see what this looks like. So in this here, I'm just going to grab that language worked with column. Oops. And I spelled, language wrong. So language worked with. Is that right? Yep. Okay. So we can see that we get, some programming languages here, and each different language is separated by a semicolon. So we can't just do a query where we say, you know, if the language worked with equals Python, because the actual value of that column will be any combination of the languages listed on the survey. So one way that we could do this is to instead use a string method and see if Python is within, this string of these languages that they know. So to do this, I'm going to, rewrite my filter here. And I'm just gonna say that my filter is going to be equal to and we want to grab the languages worked with for each person and then we're going to use some string methods. So I'm going to say dot str dot contains, and then I will pass in Python"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". So I'm going to say dot str dot contains, and then I will pass in Python. Now also we can see that we have some, NaN values here, but not a number. Now we need to also set a fill value for those or else we're gonna probably get an error. So, that is part of the contains method here. I can just say n a is equal to false. We're just, not gonna do anything with those. So let me explain this one more time here. So this filter that we're putting in place here, it's saying, okay, for this column here, the languages worked with, which are all of these results here, we are saying the string in that column, does it contain Python? So that's my filter. I'm going to run that cell. And now let's apply that filter to our data frame by saying dot loc and I will pass in that filter. And now let's also just grab the languages worked with column to make sure that that worked correctly"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". And now let's also just grab the languages worked with column to make sure that that worked correctly. So if I run that, then all of these results here or all of these rows that it gave us back should have Python in their languages known. So we can see that we have Python there, there, there. So, yes, it does seem to be in all of these results. Now this one here, number 8, we can't actually see it here, but we have these ellipses here, so it's probably, just being truncated here. Now in my last video, I kept saying that these were being concatenated. I meant truncated. A few people pointed that out in the comments. So, yeah, these are being truncated here, so we just can't see the Python value there, but they are there. And I'll probably do a complete video on, string methods here in the future, since there's so much more that we can do with these. We can use them to replace text, to split values, and all kinds of different stuff"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". We can use them to replace text, to split values, and all kinds of different stuff. So it's, very these string methods are extremely useful in Pandas. So that's a basic overview of doing some filters with our data frames. Again, the key takeaways are that we can do these conditionals here, and and have them as a filter. And again, let me print out just the filter without applying it to the data frame. We can see that the filters return a series of true false values. And when we apply that to our data frame, those true false values where we get all of the true values back and not the false. So if I look down here, we have, respondent 1, 2, 4, and 5 as true, and 3 was false. So if I look at my data frame here, we can see that we get 1, 2, 4, and 5, and 3 is not there because that value was false. So that's how filters work, and again, it's an essential, part of Pandas because this is what the one of the first things that we do with our data whenever we are loading it into Pandas. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". So that's how filters work, and again, it's an essential, part of Pandas because this is what the one of the first things that we do with our data whenever we are loading it into Pandas. Okay. So before we end here, I would like to mention that we do have a sponsor for this video, and that is brilliant dot org. Brilliant is a problem solving website that helps you understand underlying concepts by actively working through guided lessons. And Brilliant would be an excellent way to supplement what you learn here with their hands on courses. They have some excellent courses and lessons on data science that do a deep dive on how to think about and analyze data correctly. So if you're watching my Panda series because you're getting into the Data Science field, then I would highly recommend also checking out Brilliant and seeing what other Data Science skills you can learn"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". They even use Python in their statistics course and will quiz you on how to correctly analyze the data within the language. Their guided lessons will challenge you, but you'll also have the ability to get hints or even solutions if you need them. It's really tailored towards understanding the material. So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/cms to sign up for free. And also, the first 200 people to go to that link will get 20% off the annual premium subscription, and you can find that link in the description section below. Again, that's brilliant.orgforward/cms. Okay. So I think that's gonna do it for this Pandas video. I hope you feel like you got a good idea for how to filter the data within our data frames to find the information that you're looking for. Like I said, this is a fundamental skill in Pandas, which is usually one of the first things that we do with our data"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". Like I said, this is a fundamental skill in Pandas, which is usually one of the first things that we do with our data. In the next video, we'll be learning how to alter the data in our data frames and make changes. So we'll learn how to make changes to specific values and also how to make multiple changes at once across the entire data frame. So for example, maybe you want to make it so that email addresses are all cast to lower case so that they are easier to search. Or maybe you want to take out any spaces of your column names and replace them with underscores. So all of that will be covered in the next video, so be sure to stick around for that. But if anyone has any questions about what we covered in this video, then feel free to ask in the comment section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that"
    },
    {
        "title": "Python Pandas Tutorial (Part 4): Filtering - Using Conditionals to Filter Rows and Columns",
        "text": ". And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up, and also it's a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute through Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": "Hey there. How's it going everybody? In this video, we're gonna be learning how to create pie charts. And pie charts are pretty simple to use. They're similar to bar charts that we looked at in the last video. But instead of plotting certain values for each category, it's instead going to show us the proportion that each category contributes to a whole. So, basically, just like the name implies, you can think of our chart as a pie, and each category will be a slice of that pie. And the larger the slice means that category has, more of whatever values we're measuring. So let's go ahead and jump into this and see some examples. But real quick, I'd also like to mention that we do have a sponsor for this series of videos, and that is brilliant.org. So I'd really like to thank Brilliant for sponsoring this series, and it would be great if you all can check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a bit"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. So first, I'm gonna go over a very basic example to see how this works, and then we'll look at some more real world data where we plot popular programming languages using a pie chart. So I have a little bit of starting code here that you might recognize if you're continuing from the previous videos. But if you're not, then let me quickly go over the starting code that we have here. So I'm simply importing pie plot from matplotlib. We are setting the style to be 538 just so that this looks a little nicer. And currently, all we have is a title, of my awesome pie chart, and we are making the tight layout, which will get some default padding in there that looks nice. And then we are doing plot dot show, which will actually show our plot for us. And I've also got some colors commented out down here, but we don't have to worry about that right now"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". And then we are doing plot dot show, which will actually show our plot for us. And I've also got some colors commented out down here, but we don't have to worry about that right now. Now this code will be available for download. I have a link in the description section below that takes you to my GitHub. So if you wanna follow along, then you can download this code and follow along. Okay. So like I said, pie charts are pretty simple and straightforward. So first of all, we need the values that we want to represent in our pie chart. And, again, we can think of these as slices of the pie. So for example, let's start off easy, and say I wanted to just represent two numbers in a pie chart. So I'm gonna say slices is equal to, and this will be a list. So I'll do a list of 6040. And that's actually all we need to create a very basic pie chart. So to plot that, I can just say plt.pie, not plot, sorry. Plt.pie, and we want to make a pie chart of those slices"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". And that's actually all we need to create a very basic pie chart. So to plot that, I can just say plt.pie, not plot, sorry. Plt.pie, and we want to make a pie chart of those slices. So if I run that, then we can see that it plots out our values of 6040. And the 60 value takes up 60% of our plot, and the 40 value takes up 40% of the plot. But this isn't very useful right now since we don't have any labels or any indication of what we're plotting. So let's add some of that. So I'm gonna go back to the code here. Okay. So we have our slices, but let's also add labels for our slices so so that we know what's what when we look at our chart. So to do this, we can just add labels as a list, and these will correspond to the slices that we want them to be a label for. So underneath the slices here, if I was to say labels is equal to, and I'll just pass in a list here. So the first one, I want to label as 60. The second one, I want to label as 40"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". So underneath the slices here, if I was to say labels is equal to, and I'll just pass in a list here. So the first one, I want to label as 60. The second one, I want to label as 40. And then we can add those labels to our pie chart simply by saying, labels is equal to that labels variable that we just created. And also, just a quick side note, our values actually don't need to add up to a 100%. They can be anything, and the pie chart will calculate their proportions accordingly. So if I were to double these values, then we'd still get a chart that looks the same. So if I was to double this to 120 and double this to 80, then those are still gonna take up the same proportions of the pie chart. So if I run that, then we can see that our 120 here takes up 60%, and that's labeled 60, and our 80 here still takes up 40%, and that's labeled 40"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". So if I run that, then we can see that our 120 here takes up 60%, and that's labeled 60, and our 80 here still takes up 40%, and that's labeled 40. Now I don't know about you, but I like to have some separators on the edges here of these colors, instead of these colors just bumping up against each other. So to do this, we can pass in some wedge properties. So back in our code, after labels, this is going to be in the py method. We can say wedge props for wedge properties, and this is gonna be a dictionary of values. And we just wanna change the edge color. So I'm gonna type in edge color, and let's just set that to black. So if I run that, then now we can see that we have a black edge, when before these were just a solid color here. Now if you're wondering how I knew to change the, edge color property there for that wedge property, that's something that I looked up in the documentation"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". Now if you're wondering how I knew to change the, edge color property there for that wedge property, that's something that I looked up in the documentation. And if you Google matplotlib wedge, then it'll take you to their documentation page with all of the customizations that you can make. Okay. So lastly, let's look at how we can specify our own colors for these slices. And after we do that, then we'll take a look at a more real world example where we create a plot for popular programming languages. So to change the colors of these slices, we can do the same thing that we did with the labels and just create a new list corresponding, with the colors that we want for each slice. So I'll just add a few extra colors here and also let me add a few extra slices. So I'm going to pass in, 30 and 20 here and then I will also pass in labels for these, so just extra 1 and extra 2. Now these aren't gonna take up 6040 anymore, but that's okay. We're just doing a demonstration here"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". Now these aren't gonna take up 6040 anymore, but that's okay. We're just doing a demonstration here. And now we wanna pass in a list of corresponding colors. So I'll pass in, let's see, blue, red, yellow, and green as the last color there. And now we can pass those colors into our chart by passing those into the pie method here. So right after the labels, I'll pass in colors is equal to, and we call that list colors. So I'll save that. And now if we run that, then we can see that we have more slices here, all of these are labeled, and we have some custom colors. Now I almost never use just the color names like we did here, because I think that looks kinda like something you'd see in an elementary school textbook or something like that. I just think it's, kind of bright. So you also have options of using hex color values to select your colors as well, and I almost always use hex values to get the exact color that I want, or I'll let Matplotlib's styles choose default colors for me"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". But that's why I have these colors commented out down here in my code, because I'd like to use those for this example instead. So instead, if I were to copy all of these here let me grab all of these, and I'm just gonna paste these in as my colors. So now we have that blue color. This is a blue hex color. This is a hex red color, a hex yellow, and a hex green. And I just found these on a color palette online that I thought looked good. So if I run this, then we can see that now those colors are a bit more muted, and I think that looks a lot more professional than using those built in named colors. Okay. So now that we've gone over the basics of pie charts, now let's look at a real world example and plot popular programming languages. Now I have the have these available here in a snippets file that I have open. Here, let me delete those color comments right now so that we can see everything"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". Now I have the have these available here in a snippets file that I have open. Here, let me delete those color comments right now so that we can see everything. So in my snippets here, and I'm gonna have this available, in the description section below as well if you wanna go along with these snippets. But I'm gonna copy and paste all of these, and then I'll explain what this data is. And I'm just gonna paste this over top of our custom colors here and also our slices and labels. So if I save that, now that we don't have those custom colors, I'm also gonna have to remove colors from the, pie method here since we're no longer using that. And now let me explain this data here. So I grab this data 2019 Stack Overflow developer survey, and these slices here represent how many respondents said that they use a particular language, and the labels here are the language that they said that they knew"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". So the first value of 59,000 here is how many people said they knew JavaScript, and 55,000 is how many people said they knew HTML and CSS and so on. Now we've got a lot of languages here. These are the top 15. There were around 30 languages here before, before we narrowed this down a bit. So this is one mistake that I see sometimes when people are creating pie charts. Pie charts don't really look good when you have this much data. They're really best for comparing, you know, 5 things or something like that. So let's see what this looks like if we run this with all 15 of these values. So we can see here that this just gets extremely crowded, and it might take us some time to find out exactly what we are looking for. And it's also hard to get a good comparison from language to language. Like, if we were to try to compare SQL to JavaScript here, then it looks like JavaScript has a larger chunk here, but it's really hard to tell by how much because there's so much data"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". Like, if we were to try to compare SQL to JavaScript here, then it looks like JavaScript has a larger chunk here, but it's really hard to tell by how much because there's so much data. So if you wanted to plot this many items, then I would definitely recommend using a bar chart like we used in the last video instead of a pie chart. I wouldn't use a pie chart unless you have, you know I wouldn't use a pie chart if you have more than 5 items. But if you have less than 5 items, then I think a part, pie chart would work fine. So with that said, let's strip down our data to only include the top 5 programming languages. So I'm gonna go back to our code here, and now I'm just going to delete all of these up until the 5th item. So 1, 2, 3, 4, 5. So Java is the 5th. And then I will delete all the way up until the 5th item here. So 1, 2, 3, 4, 5. Okay? Okay. So now if we run this, then we can see that that looks a lot better than all of that clutter that we had before. Okay"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". So 1, 2, 3, 4, 5. Okay? Okay. So now if we run this, then we can see that that looks a lot better than all of that clutter that we had before. Okay. So now let's see a few more things that we can do with this pie chart. So a lot of the times, you'll see some pie charts that have an emphasis on one piece of the chart. So for example, let's say that I, that we were preparing a talk for a Python conference, and we wanted to emphasize, the Python slice on this chart. So to do this, we can pass in an explode argument, and this will be a list of values that will offset the slice. So to do this, I'm going to create a an explode list here underneath our labels. We'll set that to an empty list. Okay. And these values will represent, will be a list of floats which represent how much we want to emphasize that slice. So a 0 will keep that slice how it is, and any number besides 0, will represent the fraction of the radius that we'd like to explode the value"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". So a 0 will keep that slice how it is, and any number besides 0, will represent the fraction of the radius that we'd like to explode the value. Now that might not make sense right now, but let's go ahead and take a look at an example here, and I think it'll make more sense. So if we want to explode Python, that is the 4th item of this list. So I'm just gonna say 0, and now on Python, I'll just say 0.1, and then we'll put 0 for Java as well. And now we can add explode here to our arguments. So I'm gonna say explode is equal to that explode list. Okay. So now if I run this, then we can see here that Python is now exploded out here a little bit, and we have some emphasis on Python here. Now that point one that we passed in to that explode, whenever I said that represents how far it is from the radius, that point one just means that it is 10% of the radius, exploded out here"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". Now that point one that we passed in to that explode, whenever I said that represents how far it is from the radius, that point one just means that it is 10% of the radius, exploded out here. If we were to do, like, a point 5, then that would be really big, and that would be half of the radius that it is exploded out. So I'll do a point 5 and run that. We can see that now it's exploded out by half of the radius. The point here is at half. But I think that's way too large, so let's go back to point 1. I think point 1 looks pretty good. So let me close both of those down. Okay. So there are a few more arguments that we can pass into our PY method that you might find useful. So let's take a look at some of these. Now one of these is just for aesthetics, but we can add a shadow to our chart by passing in an argument of shadow equals true. So right after explode here, I'll just say shadow equals true. And if we run that, then we can see that now this looks a little, 3 d here"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". So right after explode here, I'll just say shadow equals true. And if we run that, then we can see that now this looks a little, 3 d here. We have a little shadow along the edges, along our, slice that's exploded out here. It just kinda makes it pop out a little bit. Now another argument that we can pass in is the starting angle. And if you want to change exactly how the chart is rotated, then you can play around with this. So for example, if I was to say, start angle is equal to, let's say, 90 degrees. So I will save that and run it. And now we can see that this chart was rotated a little bit. I think it picks an arbitrary angle, to plot at first. But when we set this equal to 90, we can see that now our first value of JavaScript here starts at a 90 degree angle here, and then this goes all the way around to the last item in our list here, which is Java. So if we really wanted to emphasize Python, then we could play around with that angle and get it to show up exactly how we like"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". So if we really wanted to emphasize Python, then we could play around with that angle and get it to show up exactly how we like. So that's what start angle does. Okay. And lastly, if we want to actually display the percentage that each slice is taking up in our pie chart, then we can add in an argument for that as well. Now, this syntax is going to look a little strange. I always need to look this up in the documentation when I do this. But to do this, we can say let me, actually go on a new line here. So to do this, we can say auto pct, so auto percent is equal to, and now we're passing in a format string here. So this is going to be a percent sign, 1.1 f%, percent percent. And again, I know that syntax looks a little bit strange there, but that is the format string for how we specify a percentage. So if I save that and run it oops. And I forgot my comma there, so we had a syntax error"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". So if I save that and run it oops. And I forgot my comma there, so we had a syntax error. If I save that and run it, then now we can see that we have the percentages here within our pie chart telling us how big of a piece of the pie, each of these values takes up. So that's pretty much the basics of a pie chart. They're really nice for just getting a quick overview of the data like this and what values take up what percentage of the whole. But like I said, if you have more values than 5, then I would recommend using a horizontal bar chart or any or a vertical bar chart, depending on your data. But the pie chart is definitely, an option that you have. Okay. So we're just about finished up here. But before we end, I'd like to also mention the sponsor of this video, and that is brilliant.org. So in this series, we've been learning about matplotlib and how to plot data in Python, and Brilliant would be an excellent way to supplement what you learn here with their hands on courses"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ".org. So in this series, we've been learning about matplotlib and how to plot data in Python, and Brilliant would be an excellent way to supplement what you learn here with their hands on courses. They have some excellent courses covering the fundamentals of statistics, and these lessons do a deep dive on how to think about and analyze data correctly. They even use Python in their statistics courses and will quiz you on how to correctly analyze the data within the language. Their guided lessons will challenge you, but you also have the ability to get hints or even solutions if you need them. It's really tailored towards understanding the material. They've also recently released a programming with Python course, and they even have a coding environment built into their website so that you can run code directly in the browser"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". They've also recently released a programming with Python course, and they even have a coding environment built into their website so that you can run code directly in the browser. And that is a great way to compliment watching my tutorials because you can apply what you've learned in their active problem solving environment, and that helps to solidify that knowledge. So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/cms to sign up for free. And, also, the first 200 people that go to that link will get 20% off the annual premium subscription, and you can find that link in the description section below. Again, that's brilliant.orgforward/ cms. Okay. So I think that pretty much covers it for pie charts. I hope you feel like you got a good understanding of when you might use these and also how to customize these a bit to visualize your data exactly how you'd like"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". I hope you feel like you got a good understanding of when you might use these and also how to customize these a bit to visualize your data exactly how you'd like. And in the next video, we're gonna be covering, stack plots, and some people call these area charts. It's very similar to a pie chart, but instead of looking at how things are proportioned at a single time, stack plots will allow us to see these, different proportions over time. So definitely be sure to check that out. But if anyone has any questions about what we covered in this video, then feel free to ask in the comments section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is simply like the video and give it a thumbs up. And, also, it's a huge help to share these videos with anyone who you think can find them useful"
    },
    {
        "title": "Matplotlib Tutorial (Part 3): Pie Charts",
        "text": ". The easiest way is simply like the video and give it a thumbs up. And, also, it's a huge help to share these videos with anyone who you think can find them useful. And if you have the means, you can contribute to Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": "Hey there. How's it going everybody? In this video, we're gonna be learning how to read and write data to different sources. So we'll learn how to read and write data using CSV files, Excel files, JSON, and also SQL databases. Now in this series so far, we've been reading, data from CSV files, but in data science there are so many different ways for data to be stored. So by the end of this video, you should be able to get your data to and from Pandas, no matter what data format you're using. Now if you're watching this video because you're looking for how to read and write a specific file format, then I'll be sure to add timestamps in the description section below to where, we read and write from each different format. Now I would like to mention that we do have a sponsor for this series videos, and that is Brilliant"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". Now I would like to mention that we do have a sponsor for this series videos, and that is Brilliant. So I really want to thank Brilliant for sponsoring this series, and it would be great if you all could check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay. So first, let's look at CSV files since we've already been using these throughout the series. We should already be familiar with reading data in from CSV since that's what we've been doing so far. But in case this is the first video of the series that you're watching, let's go over this one more time, and then we'll also learn how to write to a CSV file as well. So up here towards the top of my notebook here, we can see that I'm reading in this CSV file. And this CSV file is within a data folder that is in the same location as this Jupyter notebook on the file system"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". And this CSV file is within a data folder that is in the same location as this Jupyter notebook on the file system. Now if you have a CSV file loaded elsewhere on the system, then you'll need to pass in the full path to that file instead of just this relative location that we have here. And we can see that we have different arguments that we can pass in when reading our CSV files. So in this example, I'm automatically setting the index, to this respondent column here, which is the respondent ID for each person who answered this survey. And when I read in the CSV, we can see that it sets this data frame, equal to the data, and we can print this data out down here at the bottom. So that is the read CSV method, and it allows us to pull data in to Pandas. Now let's learn how to write this data back to a CSV"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". So that is the read CSV method, and it allows us to pull data in to Pandas. Now let's learn how to write this data back to a CSV. So maybe you're going to make some changes and some different analysis here to your DataFrame, and then we want to export this back to our file system for later use or so that we can share it with someone else or something like that. So for example, let's filter down for a specific location in this survey. You know, maybe you're doing some analysis for your specific country, and you just want to see the survey results from that location. We've seen this in previous videos, but if we want to filter, then we can simply say I'll create a filter here, and just say that I want the, country here, and I'll grab if the country survey results from India. So now I'm going to create a new DataFrame here. I'll call this IndiaDF, and do a df.loc and pass in that filter"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". So now I'm going to create a new DataFrame here. I'll call this IndiaDF, and do a df.loc and pass in that filter. So now if I do an India df dot head to take a look at the beginning of this new DataFrame, if we look over here in the Country column, then we can see that all of these countries here are now set to India. So now let's say that we want to export this new filter DataFrame to a CSV file. So to do this, we can use the to CSV method. So we can say, I'll just say india_df, which is our DataFrame.2_csv. And now I'm just gonna pass it into that same location in that data directory, and then I'll just call this modified. Csv. So if I run this, we can see that we don't get any errors. And now if I go back and look at my, file system here, then I have this modified ds dot CSV. So if I click on this, then we can see that this is, you know, a little bunched together since it's a CSV file, a raw CSV file that we're looking at"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". So if I click on this, then we can see that this is, you know, a little bunched together since it's a CSV file, a raw CSV file that we're looking at. But we can see that we have all of our column names here, and then the 2nd row should be the first result. And I can see here that we have India for that country. If I look at the second result, we can see we have India again, and India again down here most likely. I can't see it, but, you know, we can just assume that it's there. It's looking good. Oh, and actually, there it is right there. So we can see that, we did actually export that data frame, where we filtered that down to a new CSV file. Okay. So that was easy enough. So now let's look at how to read and write to some other formats. So one thing that you might run into is a tab delimited file. These are almost exactly the same thing as CSV files, but instead of your data being separated by a comma, the data is instead separated by tabs"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". These are almost exactly the same thing as CSV files, but instead of your data being separated by a comma, the data is instead separated by tabs. So to do this in Pandas, we're still going to use the same CSV methods that we've already seen, but we're going to pass in a custom separator. So we can write to a tab delimited file, just by changing the file extension here to dottsv, and I'm also going to specify a separator argument. So I'm going to say sep, s e p, and then you want to pass in your separator. Now you can pass in anything here if you want, you know, a, a file that is separated by hashes or anything, but commas and tabs are probably the most common. So I'm going to put a backslasht there because that's how we specify tabs in Python. And now if I run this cell, I'm going to go back to our data directory here, we can see that now we have this modified dottsv"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". And now if I run this cell, I'm going to go back to our data directory here, we can see that now we have this modified dottsv. If I click on that, then we can see that now this looks almost exactly the same as the comma separated file, but now we have tabs here, instead of commas. Now if you're reading in tab CSV files, then all you need to do is take this sep equal to, backslasht, and you can just add that as an argument up here to read CSV. So it's basically the same thing. Okay. So now let's move on to some other file formats. Now a very popular file format when working with this kind of data is Excel. Now if we want to write to Excel, then we're going to need to PIP install a couple of packages. So I have my terminal open with, the current environment that I am using. This is my Jupyter notebook running here. Let me grab my other terminal. So I have the same environment that I'm using within Jupyter"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". This is my Jupyter notebook running here. Let me grab my other terminal. So I have the same environment that I'm using within Jupyter. You want to be sure, that you're using that same environment so that, you're PIP installing in the right location. And now we're going to install a couple of packages. So first I'm going to say pip install, and this is xlwt. So xlwt will write to an older XLS Excel format, But if you want to write to a newer XLSX Excel format, then we'll also need to install OpenPyXL. And you can PIP install multiple packages bus just by, listing them all right here. And finally, we want if we want to read Excel files, then we can install the XLRD package. So I think that is, the 3 packages we're gonna need in order to work with Excel files here. So I'll go ahead and install all of those and let those finish. And once those are installed, let's go back to our notebook, and now let's try to write to an Excel file"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". So I'll go ahead and install all of those and let those finish. And once those are installed, let's go back to our notebook, and now let's try to write to an Excel file. So to write to an Excel file, I'm just going to write the same modified, data frame that we have here, and we are going to use the 2 underscore Excel method. And this is just as easy as passing in, let's see. I'll save it in that data folder again. I'll call this modified dot xlsx. So I'm gonna write to the, newer Excel format. So if I run this, then it might take a second here for this to work because it's actually creating this Excel file on the back end. So let's let this finish, and we can tell it's finished when this turns from an asterisk to a number here. Okay. So once that's finished, let's flip over to our data folder here, and we can see that we do have that .xlsx file. Now this likely won't open up in Jupyter because this is an Excel file. We can see here, that we can't open this up in the browser"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ".xlsx file. Now this likely won't open up in Jupyter because this is an Excel file. We can see here, that we can't open this up in the browser. We actually need Excel. So let me open up my finder window here. I have this open down here, and I am within this data folder, and we can see that we have our modified dot xlsx file here. Now I don't actually have Excel on this machine. I have Numbers, so I'm going to open this up in Numbers. It should basically be the same on Windows, but you can just open it up with Excel. Now again, this might take a second to open up because we do still have a lot of rows here, in this data. Okay. So we've got this opened up, in Excel. Again, I'm on Numbers because I'm on a Mac and I have Excel installed, but it should open up fine in Excel as well. Let me zoom in a little bit here. So we can see and we can format these if, if we need to. So for example, we can change the column sizes here so that all these fit in"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". Let me zoom in a little bit here. So we can see and we can format these if, if we need to. So for example, we can change the column sizes here so that all these fit in. But we can see here that we have our respondent IDs. If I look over at Country, we can see that it did export, the filtered DataFrame that we were hoping to export. So everything looks good here. Now there are also some more advanced things that we can do with Excel as well. If you're familiar with Excel, then you might know that we have the concept of different sheets where we can have multiple spreadsheets in 1 Excel file. And if you want to read or write to a specific sheet, then you can pass in a sheet argument, to these methods. Actually, I'm trying to scroll over to my notebook here. Let me scroll down here to the bottom"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". Actually, I'm trying to scroll over to my notebook here. Let me scroll down here to the bottom. So like I was saying, if you want to read or write to a specific sheet, then you can pass in a sheet argument to these methods, and there's also a way to start from different columns and rows as well. But I'm not going to go into all these little details here. If you Google this method name to Excel, then you can find the arguments that you can pass in and all the additional details in the documentation. So for now, let's go ahead and move on and see how that we can, read in that same Excel file that we just created and make sure that this works. Now, by default, it's going to load in with a default index, just like, when we read a CSV file. So we'll have to specify that we want our index column to be that respondent column. So to do that, I'm just going to call this test since we're going to be creating a new data frame here from that Excel file that we just created"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". So to do that, I'm just going to call this test since we're going to be creating a new data frame here from that Excel file that we just created. And we're going to use the read underscore Excel, method here. Now we just want to pass in the location, and I'll just go ahead and copy this here. So that is modified dot xlsx on my machine. And now I'm going to set that index column equal to and that was respondent. On your data, that might be different, but I want my index column to be equal to that respondent. So I'm going to run that cell and load that in, and then I'm going to look at that test data frame. Now before I run this, I'm gonna make sure that this, finishes processing here and that this asterisk goes away. Again, it can take some time because it's actually, you know, loading in that data from Excel now, which is a little more tricky than loading it in from a CSV"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". Again, it can take some time because it's actually, you know, loading in that data from Excel now, which is a little more tricky than loading it in from a CSV. So now if we look at that test, data frame let me just look at the head here instead of looking at the whole thing. If I look at the head, then we can see that we, have the same data frame here, that we had up here, so that was exported to Excel and imported correctly. Okay. So now let's cover some other popular file formats. Now, JSON is also really popular, for this kind of data. So let's take a look at that. First, let's write our modified DataFrame to a JSON file. Now, for writing to a JSON file, then we can use the toJSON method. So you're probably starting to see a pattern here. These method names are very straightforward. Now this one is a bit different since there are some different orientations that we can use for JSON"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". So you're probably starting to see a pattern here. These method names are very straightforward. Now this one is a bit different since there are some different orientations that we can use for JSON. So just by, using the default arguments, I can just say, so that was India DF dot 2_ JSON, And now I'll pass in a file location here, but instead of an Excel file, we want a JSON file. Now, I'm just going to use the default arguments for now, and then I'll show you, how we can change this up a bit. So if I run this, we can see that ran very quickly. If I go back to my data folder here, then now we have this JSON file. If I look within here okay. That took just a second to open up on my machine. Again, we do have a lot of data in here. But if we look in here, then we can see that this is very dictionary like. So we have, a main branch key here, and then the value for that key are all of the responses just for that column"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". But if we look in here, then we can see that this is very dictionary like. So we have, a main branch key here, and then the value for that key are all of the responses just for that column. And if I was to scroll down here, then I would be able to find the other keys and the other responses as well. So by default, this is a dictionary like JSON. Now there are also, different ways that we can write JSON files. Again, I'm not going to go into every single little detail here, but let's say that we wanted this JSON, to be list like instead of dictionary like, which is how it is by default. So to do this, we can change the orient argument. So instead, let's add 1 here to our arguments, and I'm going to say orient is equal to, and if we pass in records and lines equal to true, then this will now make this records like, which is, list like, and this lines equal to true. Let me spell that right. We'll just make each of these on a new line, so it might be a little bit easier to read"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". Let me spell that right. We'll just make each of these on a new line, so it might be a little bit easier to read. Now if you want to see the exact arguments that you can pass into Orient, then again just look up Pandas to JSON method. And it'll take you to the documentation with all the different things that you can pass in here. So let me run this, and now let's go back and reload our JSON file to see how this looks. And now what we have here is more list like. So before, we had, a single dictionary where the values were a list of all of the responses, but now we have one response at a time. So we have the main branch, and then, so this is this first one here. If I scroll down, we can see that this is the second response. This is actually the entire first response. So we have the main branch, and then that answer, and then open source, then that answer, and then so on. And we can see here that for the country, we have India"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". So we have the main branch, and then that answer, and then open source, then that answer, and then so on. And we can see here that for the country, we have India. And each response within this survey is actually on a different line. So that's a little bit different than how it was before, but there's just different ways that we can export these JSON files depending on your needs. Okay. So now that we've written our data to JSON files, now let's also read this JSON file, so that we can make sure, that we know how that's done as well. Now, since we wrote the JSON file with these different arguments here, then we need to use those same arguments when we read the data in as well. So if you're reading in JSON files and have any issues, then you might need to play around with the different arguments to fit the data that you're trying to read in"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". So if you're reading in JSON files and have any issues, then you might need to play around with the different arguments to fit the data that you're trying to read in. So in this case, I'm just going to copy this whole line here and I'm going to say test is equal to, and actually let me just grab this part, And I'll say pd.read_json. And now I'll pass in all those arguments here. So we are reading the JSON file from this location. We know that the orient is list like instead of dictionary like, and that all of these are on new lines. And again, depending on your JSON data, you might need to go in and change these around, depending on how your data looks. So if I run this, then let's see if we have the same data that we exported before. And it seems like we do. This, looks exactly, like it did whenever we exported this data. Okay. So now the last, file format that we're going to look at, let's learn how we can, read and write data from SQL databases"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". This, looks exactly, like it did whenever we exported this data. Okay. So now the last, file format that we're going to look at, let's learn how we can, read and write data from SQL databases. Now, this is probably the most complicated simply because you have to have the database set up and all of that good stuff, but for the sake of this video, I'm going to assume that you already have a database with the correct credentials to log in to that database. So I have a Postgres database set up on my machine that we'll be reading and writing to. So first, let's see how we would connect to this database. Now just like with Excel, we're going to need to install a package to do this. So let me bring up my terminal here, and I'll close this, Numbers file here. Let's see. Let me try to quit out of this. Actually, I'll just minimize it. It's having trouble shutting down. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". So let me bring up my terminal here, and I'll close this, Numbers file here. Let's see. Let me try to quit out of this. Actually, I'll just minimize it. It's having trouble shutting down. Okay. So let me go back to the terminal that I have opened to where I can install some different packages, and that's my Jupyter notebook. Where is my other terminal? Here we go. Okay. So to connect to our database, we're going to want to install SQLAlchemy, and this is a very popular ORM for Python that allows us to more easily work with databases. If you don't know what an ORM is, it stands for Object Relational Mapper, and it's just a way for us to use Python objects in order to connect to a database. I plan on doing a complete video or a complete series on SQLAlchemy in the future. But for now, let's go ahead and just install this. So this is pip install SQL Alchemy, and I'll install that. And depending on the database that you're using, you might not need to do anything else here"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". So this is pip install SQL Alchemy, and I'll install that. And depending on the database that you're using, you might not need to do anything else here. So for example, if you're using SQLite or something like that. But since I'm using a Postgres database for this tutorial, I also need to install the Psycho PG 2 package that allows us to work with Postgres. I'm not sure if that's actually how you say that package name, but that's what I've always called it. So pip install, and to install, this package to work with, Postgres, it's psychopg2dashbinary. So I'll install that. And with those packages installed, let's go back to our notebook and see if we can connect to this database using SQLAlchemy. So first, we're going to want to import everything that we need. So from SQLAlchemy, I'm going to want to import their Create Engine, and this will allow us to, connect to the database. Now I'm also going to want to import, Psycho PG 2. So let me run this cell"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". So from SQLAlchemy, I'm going to want to import their Create Engine, and this will allow us to, connect to the database. Now I'm also going to want to import, Psycho PG 2. So let me run this cell. And now that those are imported, we should be able to create the engine, which is basically our database connection. And again, I'm going to assume that you've already created this database and have a username and password. So to create this, I can say engine is equal to, and use that create engine function that we just imported from SQLAlchemy, and now we need our Postgres, connection string. Now if you don't know how to make Postgres connect or, connection strings, then, you know, they have this available on the, SQLAlchemy site as well. Let me make sure I spelled this correctly. That is PostgresQL, and then we want to pass in the username and password, for our database. Now for my case, I just made a user of DB user and a password of DB pass"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". That is PostgresQL, and then we want to pass in the username and password, for our database. Now for my case, I just made a user of DB user and a password of DB pass. Now another thing here, that I'd like to mention is that, you probably shouldn't put credentials within code like this. I'll leave a link in the description section below where I show how, in Python you should use, you know, something like environment variables or a config file to hide this information. But for the sake of this tutorial, I'm just gonna put it directly in here. But if you're doing this in, in production code, I would highly recommend using environment variables so that, you know, you don't expose your username and passwords within your code base. Okay. So there we have our username and password, and now the database that we want to connect to. So this is on localhost, this is on my local machine. It's running on port 5,432, and now the name of the database"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". So this is on localhost, this is on my local machine. It's running on port 5,432, and now the name of the database. Now I have pgAdmin open here, where I can see my databases, and we can see that I've just created an empty database here called sample_db. So that is the database that I'm going to connect to. Okay. So if I typed everything correctly here, then I should be able to, get a connection to that database. So now let's try to write our modified DataFrame to a table in this database. And this table doesn't need to currently exist. By default, it will create this table for us. If it does already exist, then we'll need to add another argument to handle that, but we'll see that in just a second. So to do this, I can just say India underscore d f, which is the data frame we want to export, then this is 2 underscore SQL, and now the table that we want to write this data to. I'm just going to call this sample underscore table"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". I'm just going to call this sample underscore table. Now again, this doesn't currently exist, but it should create it. And now we need to pass in our database connection here. I called mine engine, so let's pass that in. And if I run this, let's see if this works. Okay. So we didn't get any errors whenever I read that or whenever I wrote that, but now let's, go back to my pgAdmin here, and let's see if I can see this table. So first I'm just going to right click and refresh. I like to do that anytime, I've made any changes. We can see there here that we have a sample table down here. I'm going to right click on that and go to View and Edit Data, and look at all the rows here. And we can see it does look like, this worked. I know that this is probably a little difficult to see, on my screen here, but we have, all of our data written here into the database. Okay. So that's good that we were able to, get this from Pandas into SQL"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". Okay. So that's good that we were able to, get this from Pandas into SQL. But now what if we updated our data and wanted to rewrite that data, to this database? Let's go back to our notebook and see what this would look like. Now, if I try to run this same line again where we export this to SQL, then we're actually going to get an error because this table already exists. If you want to, write over a table, then we can add in an additional argument. And the argument that we want to add in is called if underscore exists equals and now what we want to do if this table already exists. Now in my case, I'm just going to replace that table with our new data, but there are also other options as well. We could have it throw an error. We could which is what it does by default. We could also append data to a table. So if you're doing like a, daily script where you're analyzing information, then you can just append that daily data to your existing table"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". We could also append data to a table. So if you're doing like a, daily script where you're analyzing information, then you can just append that daily data to your existing table. But for this example, I'm just going to, have this replace the table. So let's run this, and once this, is finished processing, then I will go back to pgAdmin. Now again, let me come up here and refresh this and dig back down into the database. And let me close this view here and let's see if we still have this data. Okay. So we can see that this worked. We were able to, rerun that command and it just replaced that data that was in that existing table, with our new data. In this case, it was the same data, but, that's how you would do that. Okay. So lastly, now that we've seen how to add our data to a database, now let's see how we can read in this same data using SQL"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". Okay. So lastly, now that we've seen how to add our data to a database, now let's see how we can read in this same data using SQL. Now if you skip to this part of the video using the timestamps in the description sections below, then please go back to when we wrote data to our database and see how I set up this database connection here, because we're going to reuse that same connection to read in our data. Okay. So this is pretty simple now that we actually have this database connection set up. To do this, we can just say, I'll call this SQL underscore DF, and we will just say pd.read_sql, and now we wanna pass in the table that we're going to read from, and that was sampletable. And now pass in our database connection. My connection here, I called engine. And also, I'm also going to, pass in an index column just like we did when we read in our CSV. So I'll say index column is equal to, and that is going to be this respondent row right here. For your data, that might be different"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". So I'll say index column is equal to, and that is going to be this respondent row right here. For your data, that might be different. So whatever you want to be your index, just pass it in there. If you want Pandas to just do a default index, then you can just leave this off entirely. Okay. So if I run this, then let's look at SQLDF. Head to make sure this worked, and we can see that that worked well. We still have, the same data frame here that we started off with, where we filter down these countries to just be the results from India. Now there might be instances where you don't want to load in an entire table, but you want to run a specific SQL query in order to load in our data. To do this, we can use the method read underscore SQL underscore query to run a specific SQL query. So let me just copy what I did here and paste this down here. And now instead of reading in, this entire table, I'm going to actually run a query here"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". So let me just copy what I did here and paste this down here. And now instead of reading in, this entire table, I'm going to actually run a query here. I'll do read underscore SQL underscore query, and now instead of the table name here, I'm actually going to pass in a SQL query. Now I'm just going to, load in everything here. So I'll say select star from sample_table. And everything else here is going to be the same. We still have our database connection, and we still want our index column to be equal to respondent. So this is still going to grab all the rows, but if you wanted to customize this, then you could add in a where clause here, to filter this down. So let me run this, and now let's look at our, SQL DataFrame here, and we can see that that worked as well. So we loaded in this data using a SQL query instead of just reading in the entire table"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". So let me run this, and now let's look at our, SQL DataFrame here, and we can see that that worked as well. So we loaded in this data using a SQL query instead of just reading in the entire table. So that can be especially useful, when you're working with large databases where you only want to load in specific data using a query. Okay. So we're just about finished up here, but let me show you one more tip before we wrap this up. So you may have seen people load in data using a URL instead of a specific file for some of the methods that we've looked at before, and we can do that. All you need to do, is you need to be sure that you're using the correct method for whatever form of data is on the URL. So for example, in my Flask and Django series, I created a JSON file of some sample posts for the website that we were creating in that series, and I have that JSON file on my GitHub page"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". So for example, in my Flask and Django series, I created a JSON file of some sample posts for the website that we were creating in that series, and I have that JSON file on my GitHub page. Now, if I wanted to bring that into Pandas, then I could simply use the read JSON method and then pass in that URL. I wouldn't actually have to download that JSON first and then pass it in that way. So I have this open here. If you didn't know, on GitHub, you can look at the raw files. So we can see that this is a long URL here, but I will have this code posted in the description section below if you'd like to follow along. So I'm just going to copy this URL and this isn't on my file system. And now, let's see if we can just load this in. So I'm going to call this post underscore d f and I'll set this equal to pd.read_json since this is JSON on the URL. If it was CSV, then you'd want to use read CSV and so on"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". So I'm going to call this post underscore d f and I'll set this equal to pd.read_json since this is JSON on the URL. If it was CSV, then you'd want to use read CSV and so on. So now I can just paste in that URL there and now let's just run that cell and we can see that we didn't get any errors. So let me now look at the head of our DataFrame here. And we can see, that I do have my sample posts here. These are the sample posts, that I used on, that website series. So depending on the data in that URL, you should be able to use the methods that we've seen to load in data from a URL just like we did here. Now before we end here, I would like to thank the sponsor of this video, and that is Brilliant. I really enjoy the tutorials that Brilliant provides and would definitely recommend checking them out. Brilliant is a problem solving website that helps you understand underlying concepts by actively working through guided lessons"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". Brilliant is a problem solving website that helps you understand underlying concepts by actively working through guided lessons. And Brilliant would be an excellent way to supplement what you learn here with their hands on courses. They have some excellent courses and lessons on Data Science that do a deep dive on how to think about and analyze data correctly. So if you're watching my Panda series because you're getting into the Data Science field, then I would highly recommend also checking out Brilliant and seeing what other Data Science skills you can learn. They even use Python in their statistics course and will quiz you on how to correctly analyze the data within the language. Their guided lessons will challenge you, but you'll also have the ability to get hints or even solutions if you need them. It's really tailored towards understanding the material. So to support my channel and learn more about Brilliant, you can go to brilliant.org forward slash cms to sign up for free"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". It's really tailored towards understanding the material. So to support my channel and learn more about Brilliant, you can go to brilliant.org forward slash cms to sign up for free. And also, the first 200 people to go to that link will get 20% off the annual premium subscription, and you can find that link in the description section below. Again, that's brilliant.orgforward/cms. Okay. So I think that's gonna do it for this Pandas video. I hope you feel like you got a good idea for how to read and write data from multiple different sources. What we covered here should cover the vast majority of file formats that you are going to be seeing and using in the data science field. Now I'm probably going to take a break from this Pandas series after this video and do a few one off videos that I've been wanting to cover. But I know that there are a lot of topics in Pandas left to cover, and I will get around to those more advanced topics in future videos"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". But I know that there are a lot of topics in Pandas left to cover, and I will get around to those more advanced topics in future videos. But in the meantime, if you'd like a good source for learning Pandas, then I would highly recommend checking out the channel Data School. That's run by Kevin Markham, and he's done the Pandas tutorials at PyCon for several years now. Now he didn't, you know, ask me to suggest his channel or anything like that. I just think that, he does a good job. And his channel is actually completely devoted to Pandas and data science, so he's already covered some of the more advanced topics that I do plan to cover in future videos. But if anyone has any questions about what we covered in this video, then feel free to ask in the comments section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that"
    },
    {
        "title": "Python Pandas Tutorial (Part 11): Reading/Writing Data to Different Sources - Excel, JSON, SQL, Etc",
        "text": ". And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up, and also it's a huge help to share these videos with anyone who you think would find them useful. If you have the means, you can contribute through Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": "Hey there. How's it going everybody? In this video, we're gonna continue learning about Matplotlib and seeing how to create some different types of charts. Specifically, we're gonna be looking at bar charts in this video. We're also gonna see how to load in data from a CSV instead of just having our data directly within our Python script because most likely when you're plotting data, the data is gonna be coming from another source like a CSV file. Now I would like to mention that we do have a sponsor for this series of videos and that is brilliant.org. So I really wanna thank Brilliant for sponsoring the series, and it would be great if you all could check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay. So in the last video, we learned the basics of matplotlib and how to plot some data and customize our plots in different ways"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So with that said, let's go ahead and get started. Okay. So in the last video, we learned the basics of matplotlib and how to plot some data and customize our plots in different ways. I have a stripped down version of the code that we wrote in that video opened up here in my editor, and I'll have a link to this code in the description section below if you'd like to follow along. But just in case you're not continuing from a previous video, let me go over this code really quick. So first, we are importing, plot up here at the top, pyplot from matplotlib. We are using a 538 style for our plots. Our ages here, this is our x axis. It's just a list of numbers. Dev y, this is the values that are gonna be on our y axis. And here, we are plotting out that data. So we're plotting out, our x values, which are the ages, the y values, which is our dev y here. We're giving it a custom color and a label, and I've got some commented out code right here"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So we're plotting out, our x values, which are the ages, the y values, which is our dev y here. We're giving it a custom color and a label, and I've got some commented out code right here. All of this data is median salaries for different ages. So this is for developers in general. This is for Python developers here. This is for JavaScript developers here. But I've got those commented out for now. We are also, putting a legend on our plot, giving it a title, x and y label, giving it a tight layout which just helps with the padding, and then lastly, we are showing it. So when we plotted our data in the last video, we used this plt dot plot method. And when you use the plot method, it will use a line plot by default. So if we run this, then we'll see something kinda similar to what we saw at the end of the last video. So we can see that we get a line plot here for the median salary of developers. And, again, this is some data that I took from the annual Stack Overflow developer survey"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So we can see that we get a line plot here for the median salary of developers. And, again, this is some data that I took from the annual Stack Overflow developer survey. But let's say that we wanted to show this as a bar chart instead. Well, to do that, we can simply use the bar method instead of the plot method. So if I just change this to use bar instead of plot, then we'll have a bar method or a bar plot. Sorry. And just like that plot method, we can pass in our x values first for our x values and the y values for our y axis. And additional parameters here can be passed in as well, like color and label. So I'm just going to leave that as is, just like it was with the plot method. And if I run this, then we can see that now this is plotting our data and it's represented as a bar chart instead. Okay. So that is plotting the data for all developers who answered the survey. So like I said, I also have the data for Python and JavaScript developers as well"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". Okay. So that is plotting the data for all developers who answered the survey. So like I said, I also have the data for Python and JavaScript developers as well. And right now, those are commented out. So what if I wanted to include those in our bar chart? Well, first of all, you can mix and match some plots. So if for some reason you wanted the Python and JavaScript data to remain as line plots and just overlay that onto our bar chart, then we could simply uncomment out our code here and we could just run these as plots and that will actually overlay, line plots on top of our bar plot. Now that doesn't make much sense in this situation but depending on your data, you might find that useful. Okay. But what if we wanted to include these in our bar chart as bars side by side with the other data? So you might think that we, could do this just like we did our line plots and just run those using the bar method as well. But that's actually gonna give us some issues"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". But that's actually gonna give us some issues. So let's try that real quick and see what that does. So I'm gonna change these to use bar, so plt.bar. So I'm going to run that, and we can see that this doesn't quite look right. We can't even see the data for all of the developers, and the data for Python and JavaScript is overlapping. So how can we put these side by side? Because right now, they're just all stacked on top of each other. So we can do this by offsetting the x values each time we plot some data. Now I actually think this is a lot harder than it should be. It seems a bit hacky in my opinion, but this is just how we have to do it. So to do this, we're gonna have to import NumPy and use that to grab a range of values for our x axis. Now if you've never used NumPy before, then don't worry too much about it. It's just going to use one simple function"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". Now if you've never used NumPy before, then don't worry too much about it. It's just going to use one simple function. Now I believe NumPy should be installed when you install matplotlib, so we should just be able to import it without doing any additional installs. So up here at the top, I'm going to say import numpy, and I'm going to import that as m p. That's a convention there when using numpy is to import it as m p. And now below our x values here, where we have our ages x, I'm going to create a range from these values. So I'm going to say x underscore indexes and I'm going to set this equal to mp.arange. And I'm going to pass in the length of our ages x list here. And what that's going to do is it's going to create a variable called x indexes, and that is an array of values. And those values are gonna be a numbered version of our x values. So basically, it's a lot like having a list with an index starting at 0 and counting up to our last item, but instead it's a NumPy array"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So basically, it's a lot like having a list with an index starting at 0 and counting up to our last item, but instead it's a NumPy array. So once we have that, we're gonna use that for our x values within our bar chart method. So I'm gonna copy that, and instead of using our ages here, I'm instead gonna use those x indexes. So I paste those x indexes into each of our bar methods here. So if I were to run this right now, then it would look very similar to what we had before, but now we're just using those indexes instead. But now that we're using these indexes, we can actually shift the location of these by adding or subtracting to our values here. So if we think about it, they're all stacked up on top of each other right now. So let's shift our first bar to the left and the second bar to the right. But how far do we actually wanna shift these? Well, we wanna shift them by the exact width of a bar"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So let's shift our first bar to the left and the second bar to the right. But how far do we actually wanna shift these? Well, we wanna shift them by the exact width of a bar. So to do this, it would be nice if we specify an exact width for our bars so that this is explicit. I believe that they have a default width of, like, 0.8 or something like that. But just to be sure, let's create our own width variable. So up here underneath x indexes, I'm gonna create a width and set this equal to 0.25. And I think the default of 0.8 is gonna be a little thick with 3 bars, being side by side. So I think 0.25 would be good here. And but you can experiment with these different widths if you'd like, to get different looks depending on your data. So now that we have a width, let's subtract that width from our first plotted values, and we'll add that width to our last plotted values, and that should, shift those bars to all be side by side"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So now that we have a width, let's subtract that width from our first plotted values, and we'll add that width to our last plotted values, and that should, shift those bars to all be side by side. So with our first bar plot here, which is right here, we are going to say x indexes minus width. Then for our 2nd bar chart, we're not gonna do anything because that's gonna be in the middle. And then for our last bar chart, we'll say plus width, since we want that to shift over to the right. And lastly, before we plot this, we're actually gonna need to tell our plot that we want the width of the bars to be equal to the width variable that we just created. And we can do that just by passing in another variable here. So right before color on all these, I'm going to add a width oops, let me spell that right. Width equal to width. And I did that for all 3 of these bar methods. So width equals width here, here, and there"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". Width equal to width. And I did that for all 3 of these bar methods. So width equals width here, here, and there. So now that we've done that, if we run our code here, then now we can see, if I make this a little larger here, we can see that now our bar chart has these all lined up side by side instead of being stacked on top of each other like they were before. Now if you have more or less bars that you need to fit side by side, then you'll have to adjust the offsets accordingly, for the number of bars that you have. The way that I did this was with 3, but if you added another bar, then you'd need to do an offset with the width, added twice and so on. Now also, if we look at our x axis down here, we can see that we no longer have the age ranges that we had before. It's using the indexes, since that's what we needed to do our offset. So to fix this, let's go back to our code. So I'm gonna shut that down"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". It's using the indexes, since that's what we needed to do our offset. So to fix this, let's go back to our code. So I'm gonna shut that down. And down here towards the bottom, we're gonna need to use an xticks label to change the labels. So right here above the title, I'm gonna say plt.xticks. Oops. Let me spell that right. So within this xticks method, we need to pass in a couple of arguments. So I'm gonna say ticks is equal to, and those ticks are equal to the x indexes. Now the labels for those ticks are going to be equal to our ages list here. So we are using those x indexes for the ticks, and the labels, which are all of our ages that we saw before in the last video, we're gonna use that for our labels. So now if I run that, then we can see that now our plot, has our x axis labeled correctly. Okay. So we've looked here at vertical bar charts and how to add multiple different bars to that plot"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So now if I run that, then we can see that now our plot, has our x axis labeled correctly. Okay. So we've looked here at vertical bar charts and how to add multiple different bars to that plot. And in a minute, we're gonna look at how to create horizontal bar charts, but first, I wanna load in some data that's more appropriate for a horizontal chart. You usually want to use horizontal bar charts when you have a lot of data and it looks too crowded in a vertical plot. And the data that I want to load in is going to be from a CSV file. So so far, we've only used data that has been directly in our Python script. But most of the time, you're gonna be, likely using data from external sources like a CSV file. And sometimes you're gonna need to work with that data a little bit before it's actually ready to be graphed. So first, let me get rid of the data that we've been using so that we can make room for data that will load in from our CSV file. So I'm going to remove"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So first, let me get rid of the data that we've been using so that we can make room for data that will load in from our CSV file. So I'm going to remove. I'm gonna remove all the way from our pltxticks there. I'm gonna go all the way to our ages and remove all of that data. And for now, I'm also going to comment out our plot titles and plot show and things like that. And now, let me open the csv file and show you what this looks like. So I have this open here in my current directory. And like I said, all of this is gonna be available for download in the description section below, if you want to follow along. So this is the CSV file that I'm gonna be loading in here. So this is also data from that Stack Overflow developer survey, but I cleaned it up a little bit and only grabbed the data for the programming languages, respondents said that they worked with. So we can see that the top line here tells us what information this is. So this first column here is the responder ID"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So we can see that the top line here tells us what information this is. So this first column here is the responder ID. So these are just IDs for each person who answered the survey. And the languages worked with, these are the languages that that specific person said they knew. So this first person here said that they knew HTML, CSS, Java, JavaScript, and Python. And we can see that these languages are all, delineated by a semicolon here. So each line here has all these different languages. And using these, we can, graph the most popular programming languages from that survey. So let me go back to my script here. And like I said, let's say that we wanted to create a bar chart of the most popular programming languages that people said that they work with. So first, let's grab the data from that CSV file. Now there are multiple ways that we can load in a CSV file. We could use the CSV module from the standard library. We could use the read CSV method from Pandas"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". Now there are multiple ways that we can load in a CSV file. We could use the CSV module from the standard library. We could use the read CSV method from Pandas. We could also use the load TXT method from NumPy. Now first, let's use the CSV module from the standard library for since, most people are probably familiar with that. But then I'm also going to show you a faster way using Pandas and that read CSV method. So first, let's use the standard library to do this. So at the top here, I'm going to import CSV, and now I'm gonna read that file using the CSV module. Now if you don't know how to work with CSV's files using the CSV module from the standard library, then I do have a detailed video specifically on that. So I'll be sure, to leave a link to that video in the description section below if anyone is interested. Okay"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So I'll be sure, to leave a link to that video in the description section below if anyone is interested. Okay. So the way that we can read this in is I can say with open, and we want to open that file was called data dot CSV, and it's in the same directory as this script so I don't have to specify a full path. And now we can just say as CSV file, and now we can use this CSV module to read this in. So I'm going to say CSV reader is equal to, and I'm going to use the dictionary reader method from the CSV module to read in the CSV data. The dictionary reader actually makes, a dictionary where we can access the values by key instead of by index, and I find that pretty helpful. So to do that, that is csv.dict reader. And now we just want to pass in that CSV file. Okay. So now we should have that CSV data in our CSV reader variable, and this is an iterator that we can loop over"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ".dict reader. And now we just want to pass in that CSV file. Okay. So now we should have that CSV data in our CSV reader variable, and this is an iterator that we can loop over. Now I don't want to loop over all of these right now because I think there are, like, 90,000 rows in that data there. So instead, let me just print out the 1st row so that we can kind of see what this looks like. And I can grab that first row by saying row is equal to next CSV reader, and that will grab, that first line from that iterator. And now let's print that out. So I'll print out row. So if I save that and run it let me make my output a little larger here. Okay. So we can see that this is an order dictionary and the keys are what we saw as the headers in the CSV file, and the values are the responses for that particular person. So like I said, we wanna plot the most popular programming languages. So those are within the key languages worked with right here"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So like I said, we wanna plot the most popular programming languages. So those are within the key languages worked with right here. So let me just print out that key instead of printing out that entire row. So if I save that and run it, then we can see that now we get those languages. And like I said, these are delimited by semicolons here. So to clean this up a bit and turn this into a list of languages, we can actually split the values on that semicolon, by saying after we access that key, we can just simply say dot split and split on those semicolons. So if I save that and run it, then now we can see that we have a Python list of those languages. So sometimes you're gonna run into data that you need to clean up or analyze a bit before you're actually able to plot the data that you want. So that's why I'm showing that process here. So in our case, we want to plot the most popular programming languages from the results of this survey"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So that's why I'm showing that process here. So in our case, we want to plot the most popular programming languages from the results of this survey. So we need to keep a count of each language, that each respondent said that they work with. So there are a lot of different ways that we could do this as well. We could keep a list and count them at the end. We could keep a dictionary and update the counts of of that dictionary each time. But this is actually so common, called counter. And it's definitely the best way to do something like this. Now if you don't know how counters work, they can be extremely helpful. And I plan on making a video specifically about counters in the near future, but I haven't put one together just yet. So first, let me show you how, a quick example of how counters actually work. So let me open up my terminal here, and I'm going to run Python. And let me show you how counters work here really quick"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So first, let me show you how, a quick example of how counters actually work. So let me open up my terminal here, and I'm going to run Python. And let me show you how counters work here really quick. So to import these, I'm going to say from collections import counter. They are from the collections module. And now that we have a counter, I'm going to say c is equal to counter and I'm going to pass in a list here. So I'm gonna pass in a list of Python and I'll also pass in a, of Python and JavaScript, those two values in my list. So if I look at that counter, we can see that this says, okay. I have a counter here. I have a key of Python, and that's currently set to 1. I have a key of JavaScript, and that's currently set to 1. So it's keeping count of how often it sees these values. So to update this counter, I can simply say c dot update. And now I'm gonna pass in a new list. So this new list, let's say this time I say, c plus plus oops, c plus plus and Python. Okay"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So to update this counter, I can simply say c dot update. And now I'm gonna pass in a new list. So this new list, let's say this time I say, c plus plus oops, c plus plus and Python. Okay. So now let me look at this counter. So now when we look at the counter, we can see, okay, now Python is 2 because it's seen Python twice. We we saw it up here when we first created the counter, and we saw it up saw it right here when we updated the counter. It's still only seen JavaScript one time the first time we created it, and it's only seen c plus plus one time. So now let's do an update one more time. So if I run that update statement again with c plus plus and Python, and then look at our counter again. Now it's saying, okay, I've seen Python 3 times, c plus plus twice, JavaScript once. So this is what we're gonna use to keep track of these languages. So at the top of my script, let me exit out of Python here"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So this is what we're gonna use to keep track of these languages. So at the top of my script, let me exit out of Python here. I hope that all made sense to you, because these are the kind of things that you need to do sometimes when you clean up data for plotting. Okay. So I'm gonna close down that output. Now up here at the top of my script, I'm gonna import that counter. So, again, that's from collections, import counter. Spell that right. Okay. Now I'm gonna instantiate a new counter right after we read in our CSV data. So right above our row here, I'm going to make a variable and I'm going to call this language underscore counter and set that equal to an empty counter. So right now we only have the data for a single row, but we want to grab the exact same list of languages from every row. So in order to do this, we can copy what we've already printed out here, This big long thing here is what got us that list of languages from that single row"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So in order to do this, we can copy what we've already printed out here, This big long thing here is what got us that list of languages from that single row. So let's copy that, and now we can loop over all of the rows of our CSV data and update our counter with the data, that is within this list here. So I'm going to say 4 row in CSV reader, and this will loop over every row in that CSV file. And I'm going to say language counter dot update. And we want to update that with that list of languages for every single row. And so I'm going to paste that in, and this section here is what's gonna give us those lists of languages. So now our language counter should get updated, with all those languages. Okay. So now let's print out our language counter to see if it looks like we have some coherent data. And I'm gonna do this back on the main level of the Python script outside of this with context manager here. So above our plt.title, I'm gonna print out language counter"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". And I'm gonna do this back on the main level of the Python script outside of this with context manager here. So above our plt.title, I'm gonna print out language counter. So let's run that, and it looks like we've got some good data here. Okay. So since this is a counter, it should print out sorted with the, most responses at the beginning. So we can see here that we have JavaScript with 59,000, HTML CSS 55, SQL 47, Python 36,000, Java 35,000, and so on. Now we can see that there are a lot of programming languages here. If I remember core correctly, I think there are 28 total here. So we probably don't wanna plot all of these. So let's say that we just wanted the 15 most common languages. Well, the great thing about using a counter, like we did here, is that it actually has a most common method built in, to do this for us. So whenever I'm printing this out, I could say print language counter dot most common and just pass in a 15"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So whenever I'm printing this out, I could say print language counter dot most common and just pass in a 15. And if I run that, then that is the 15 most common responses. And that most common method actually returned a list here. And each item in this list is a tuple, containing so this is one tuple here. It's containing the language and the count. So now let's try to plot this data. So how would we do this? Well, first, we need to split out the languages into their own list and these corresponding counts into their own list. So when we did our previous bar charts, we had our x and y axis. So we'll want all of our languages on one axis and the counts on another, so that's why we need to split those up. So there are also a couple ways that we can do this. Now let me show you a way that takes a little bit more code, but I think is gonna be, where most everyone will be able to read it. So to do this, I'm just gonna overwrite this line here. Actually, I will keep that there for now"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So to do this, I'm just gonna overwrite this line here. Actually, I will keep that there for now. But above this line, I'm just gonna say languages and set this as an empty list, and then I'll say popularity. That's gonna be, for the numbers. So we want the languages in this list and this corresponding popularity in this list. So now let's loop over all those tuples that we got back from this most common method. So I'll say for item in language counter dot most common. Whoops. And let me sorry. Let me, go to the next line here. And remember, this is going to be looping over a list of tuples. And the first value of that tuple is going to be the language and the second value is going to be the popularity. So I'll just say languages dot append item index of 0 to grab that first item and append that to our languages. And we want to append the second item to our popularity"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So I'll just say languages dot append item index of 0 to grab that first item and append that to our languages. And we want to append the second item to our popularity. So now if I print out our languages and our popularity, languages, print popularity, save that and run it, then we can see that now we have one list here that is all of our top 15 most common languages. And the second list here is the corresponding popularity of that language according to that survey. So now we can actually use these two lists for our plot. Now there's actually a way of doing this whole section right here. There's actually a way of doing that with a one liner using the zip function and unpacking values and things like that. But I wasn't sure how many people would find that confusing. So I think it's easier to read this way. So I just decided to, do it this way instead. Okay. So now that we have these lists here, let me, exit that output there, and I'm also going to, get rid of those print statements"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So I just decided to, do it this way instead. Okay. So now that we have these lists here, let me, exit that output there, and I'm also going to, get rid of those print statements. So now that we have these lists, let's plot these just like we did before. So to do that, we can just say plt.bar because we want to make a bar chart here, and on our x axis we're going to plot the languages, and on the y axis, let's plot the popularity. And let's also uncomment out our titles and labels here, and let's change those to match what we're actually plotting. So instead of median salary, I'm going to type in, let's just say most popular languages. Spelled that wrong. That's okay. For the x label here, I can just say our x label is the programming languages. So I'll say programming languages. And for the y label here, I'll say number of, people who use. Okay. So now with that in place, let me save that and run this and let's take a look at our chart"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So I'll say programming languages. And for the y label here, I'll say number of, people who use. Okay. So now with that in place, let me save that and run this and let's take a look at our chart. Now we can see right off the bat, when we have this many items, it's hard to see all of these using a vertical bar chart like we did here. When you have a lot of items, then it might be more readable to use a horizontal bar chart instead. And we can do that easily just by changing our bar method to a bar h method. So right here where we're saying dot bar, I'm going to change that and say dot bar h. So now we can leave our arguments exactly as they are because the horizontal chart expects the y axis values first, so we'll just keep our languages there. Now we will have to change our axis labels here because those are gonna be different now. So I'm just gonna switch the x and y labels here real quick"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". Now we will have to change our axis labels here because those are gonna be different now. So I'm just gonna switch the x and y labels here real quick. So I'm just gonna have programming languages as our y label, number of people who use as our x label. Okay? And now I think that's about it. And actually, now that I think about it, I don't even think that we need this y label telling us that these are programming languages. That's pretty self evident since the names of the programming languages are actually the labels themselves. So I'm just gonna get rid of that. That's one thing with plots is, it's nice to be descriptive, but you can also be overly descriptive. So I'm gonna get rid of that. Actually, just let me comment it at it out instead. Okay. So now let me run this. And now we can see that we have, oops, a vertical bar chart here. Let me open this back up, make this a little larger. Okay. So what I meant to say is we have a horizontal bar chart here"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". And now we can see that we have, oops, a vertical bar chart here. Let me open this back up, make this a little larger. Okay. So what I meant to say is we have a horizontal bar chart here. So we can see that this is much easier to read with a lot of values, and that those aren't scrunched together like they were in that vertical bar chart. So whenever you're plotting things out, if you've got a lot of values to plot with a bar, then it might be a good idea to use a horizontal, for this type of thing. Now one thing here is that with a horizontal bar chart, maybe you want the most popular language. Right now, it's down here at the bottom. Maybe we want that at the top since we read from the top down. So to do this, we could simply just reverse the list that we're passing into the bar h method, before we actually plot it. So I'm going to close that down. And now up here before that bar h method, I'm simply going to say languages dot reverse and popularity dot reverse"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So I'm going to close that down. And now up here before that bar h method, I'm simply going to say languages dot reverse and popularity dot reverse. And the reverse method on a list actually reverses those in place, so we don't need to, set languages equal to this or anything like that. It's actually going to modify that list in place. So now if I save that and run it, then now we can see that we have the most popular languages up top, and I think that that looks a lot better. Now I did say that I was gonna show you a faster way to load in that data from the CSV using Pandas. So let me show you how to do that, because for the rest of the series, I'm probably gonna use pandas to load in data since it's a bit faster and it's also a bit cleaner. So first of all, if we don't have pandas installed, then we'll need to do that. And it's really easy to install. So first, let me install that. I'll just open up my terminal here and clear this out"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So first of all, if we don't have pandas installed, then we'll need to do that. And it's really easy to install. So first, let me install that. I'll just open up my terminal here and clear this out. And we can just install that using pip by saying pip install pandas. Whoops. Got the wrong spelling there. Pip install pandas. And now once that's installed, we will need to I'm just gonna assume that that installs correctly, and it did. Okay. So back here in our script, up here at the top, we need to import this. So I'm just gonna say import pandas as pd. That's another convention when you're using pandas is to import it as pd. Okay, so up here at the top of our file, instead of opening our file and using the dict reader method to read in the data, we can instead replace that with a pandas method. So now instead of doing it like this, we can simply say so I'm going to get rid of this with context manager here"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So now instead of doing it like this, we can simply say so I'm going to get rid of this with context manager here. And since we got rid of that context manager, I'll unindent these other lines here. But now where we were opening that file, instead I can simply say data is equal to pd.read_csv and pass in the name of that CSV file. And it was data dot CSV. And now I can specify some columns. So I'm going to say that the ID I'm going to create this IDs variable, and I'm going to say ID is the let me see exactly what that column name was, responder ID. So I'll pass in responder ID there. So that's gonna set this IDs variable equal to, all of the IDs in that responder ID column, and we can do the same thing with the languages. So I'll call this variable lang underscore responses is equal to, data, and we want the key to be languages worked with. So I'll grab that"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So I'll call this variable lang underscore responses is equal to, data, and we want the key to be languages worked with. So I'll grab that. So we still want our language counter, but now here for our loop, instead of saying 4 row in csv reader, this doesn't exist anymore, now we have this list of languages here. So I can just say for response in lang responses, update that counter. So that simple update to our code there, should work exactly the way that we that it worked before. So if I save this and I run it, then whoops. Name row is not defined. Okay. So, yeah, I got an error here that says name row is not defined. I also meant to update this section here because there's no row anymore. So we just want to split the response instead. So response dot split. Because remember, these lang responses here, when we're looping through these, each response is gonna be this entire section here of all of the languages. So we can simply just split that response. Okay"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So we can simply just split that response. Okay. So I'll save that and run it. And this should work exactly like it worked before. And we can see that it does. That looks pretty good. Now like I was saying before, this is actually real world data that I grabbed from their actual survey. And I actually have those charts that Stack Overflow put together when they analyzed their survey data. So let me open those up and see if we got similar results. So So I'm gonna put my chart here on the right, and their chart I have open here in the browser. So let me open that up. Okay. So here is their chart plotting out the exact same thing that we just plotted. Now there could be some small differences here based on how I sanitized the data compared to how they sanitized it, but you can see that as far as the order goes, we got the same results. They've also styled their plot a bit further, but with a little customization, we could probably get something very similar"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". They've also styled their plot a bit further, but with a little customization, we could probably get something very similar. So it looks like we just need to change up the colors a bit and add in a little, spacing and also make these lines a little thinner, and it would almost be identical. So that's why learning things like this can be extremely useful, because these companies are constantly looking for people who can analyze their data and present it in ways that can give insights like this. So this is definitely a skill that you're gonna be able to apply to a lot of different situations just like we did here. Okay. So before we end, I'd like to mention the sponsor of this video, and that is brilliant.org. Brilliant is a problem solving website that helps you understand underlying concepts by actively working through guided lessons. They have computer science courses ranging from algorithms and data structures to machine learning and neural networks"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". They have computer science courses ranging from algorithms and data structures to machine learning and neural networks. They even have a coding environment built into their website so that you can run code directly in the browser. And that's a great way to compliment watching my tutorials because you can apply what you've learned in their active problem solving environment, and that helps to solidify that knowledge. Their guided lessons will challenge you, but you also have the ability to get hints or even solutions if you need them. It's really tailored towards understanding that material. So their computer science material is fantastic, and I really like what they're doing. They also have plenty of courses depending on what you're most interested in. So they have courses in different fields of mathematics or astronomy, solar energy, computational biology, and all kinds of other great content. So to support my channel and learn more about Brilliant, you can go to brilliant"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/cms to sign up for free. And, also, the first 200 people that go to that link will get 20% off the annual premium subscription, and you can find that link in the description section below. And, again, that's brilliant.orgforward/cms. Okay. So I think that is gonna do it for this video. Hopefully, you feel a bit more comfortable working with matplotlib and how you can pluck out the data that you need and create types of charts that you'd like. In this video, we covered bar charts, but in the next video, we're gonna learn how to create pie charts. And pie charts are great for seeing how our data is proportioned and quickly visualize what different categories make up large and small pieces of your data. So be sure to check that out. But if anyone has any questions about what will be covered in this video, then feel free to ask in the comment section below, and I'll do my best to answer those"
    },
    {
        "title": "Matplotlib Tutorial (Part 2): Bar Charts and Analyzing Data from CSVs",
        "text": ". So be sure to check that out. But if anyone has any questions about what will be covered in this video, then feel free to ask in the comment section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up. And, also, it's a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute through Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": "Hey there. How's it going everybody? In this video, we are going to be learning about how to sort our data in Pandas. So we'll look at ways to sort our columns, how to sort multiple columns, and grabbing the largest and smallest values from different rows. Now as usual, we'll look at how to do this on a small dataset first, then we'll see how this applies to a larger dataset, like our Stack Overflow survey data that we've been using throughout the series. Now, I've been reading y'all's comments and suggestions for the series, and I'm trying to take your suggestions to heart. A lot of people have said that they'd like shorter videos, so I'm going to do my best to have shorter videos that don't sacrifice on any of the details that I think are important. Now, I'd also like to mention that we do have a sponsor for this series of videos, and that is Brilliant"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". Now, I'd also like to mention that we do have a sponsor for this series of videos, and that is Brilliant. So I really want to thank Brilliant for sponsoring the series, and it would be great if you all could check them out using the link in the description section below and support the sponsors, and I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay. So I have my Snippets notebook open that we've seen throughout the series. Now, again, if anyone would like to follow along, then I do have links to this code and the data in the description section below. So let's say that we want to sort this small data frame that we have here. So first, let's decide how we want to sort this. Now, one way that might make sense is to sort this by last name. So in order to do this, we can use the sort values method"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". So first, let's decide how we want to sort this. Now, one way that might make sense is to sort this by last name. So in order to do this, we can use the sort values method. So in order to sort this by last name, I can simply say, df dot sort underscore values, and then we'll say that we want to sort that by and set the by argument equal to the column name. In this case, it's last. So if I run this, then we can see that we get a data frame returned where those last names are sorted alphabetically. And if these were numbers, then those would be sorted smallest to highest, and we'll see that when we look at our Stack Overflow data. Now, if we wanted to sort these in descending order, then we can pass in an argument and just say that we want the ascending order to be equal to false. So if I run this, now we can see that those are sorted in descending order. Now, sometimes your sorts can get a little complicated. Maybe you want to sort on multiple columns"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". So if I run this, now we can see that those are sorted in descending order. Now, sometimes your sorts can get a little complicated. Maybe you want to sort on multiple columns. Now you do this, when the first value that you sort on has identical values, and then you want to sort on a second value. So in order to do this, we can just pass in a list for these columns that we want to sort on. So let's say that we want the first column that we want to sort on is the last names in ascending order, and then if there are duplicate last names, then we wanna sort the first name after that. So in order to do this, we can just pass in a list of columns to sort by. So I'm actually going to go to a new line here, and now instead of just sorting by last, I can pass in a list here. So, let's say that we want to sort on the last name first, but then we want to sort on the first name"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". So, let's say that we want to sort on the last name first, but then we want to sort on the first name. So if I run this, then we can see that this is sorted in descending order on the last name, just like we saw up here before, but it's also, sorting in, the first name in descending order as well if there are identical last names. So we can see that Jane was first up here, and now it's John because this is in descending order. And sometimes you might run into a situation where you want to sort on multiple columns, but you might want to have one in descending order and another in ascending order. So let me add one more name, to our data frame here, so that it's more clear whenever I do this. So I'm going to add one more name here at the top, to our dictionary. So I'm just going to call this Adam, and we'll keep a duplicate last name of Doe, and then I'll just pass in, an email of a.email.com. So now let me go ahead and rerun all of these cells. So I'll just say, cell run all"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ".email.com. So now let me go ahead and rerun all of these cells. So I'll just say, cell run all. And now, down here at the bottom, we can see that we have our last names and then all of these in descending order. But let's say that we want to, sort this data frame by last name in descending order, like we have here, then we want the first names to be in ascending order. So to do this, we can simply pass in a list of boolean values to the ascending argument. So let me copy what we have here and show the differences of what this looks like. So instead of just saying ascending is equal to false, let's instead pass in a list and these will correspond to our columns. So if I say that I want the last name in descending order, then we can keep that as false. But then if I want the first name to be in ascending order, then I can just pass in a true for that second value"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". But then if I want the first name to be in ascending order, then I can just pass in a true for that second value. So now if I run this, then we can see that our last names are still in descending order, but our first names here are now in ascending order, with Adam coming, before these two here. And as we've seen several times throughout the series, if we want to save this data frame and make this sort permanent, then we can set the in place value equal to true. So if I do this, I'm just gonna add an in place equal to true here at the end. If I run this and now I look at our data frame, then now our data frame has been modified, in an order where we can see that these values are sorted how we specified. Now if you wanna set this back to how it was before and have those indexes be sorted, then we can do that by sorting the index. So to do this, instead of using the sort values method, we'll use the sort index method"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". So to do this, instead of using the sort values method, we'll use the sort index method. So I can just say, df dot sort underscore index and run that, and we can see that now our index is sorted over here on the far left, in the order that we added those. Now, I also wanna point out that if you're simply wanting to sort a single column, then we can easily just sort that single series as well. Series objects also have that sort value method. So if we want to simply see the sorted last names and not the entire data frame, then I can simply access that column by passing in the last, name column there in those brackets, and then I can just say sort_values. I'm just gonna leave all of the arguments as defaults here and run this, and now we can see that these are sorted in ascending order. Okay. So that's a brief overview, so now let's go over to our survey data and see what this looks like on a larger dataset"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". Okay. So that's a brief overview, so now let's go over to our survey data and see what this looks like on a larger dataset. And, we'll also see some simple ways to view the largest and smallest results from our data. Okay. So I have our Stack Overflow developer survey open here that we've seen throughout the series. And again, if you'd like to download this data to follow along, then I have links in the description section below. Okay. So one way that we might want to sort sort these survey results is by country name. We can see over here that we have a country column where the respondent answered which country they were from. So maybe you're doing some analysis on information from different countries, and it's just easier seeing them all sorted. So for example, let's say that we want to look at countries and salary"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". So maybe you're doing some analysis on information from different countries, and it's just easier seeing them all sorted. So for example, let's say that we want to look at countries and salary. So to sort these survey results by country, then we can simply come down here to the bottom and say, df dot sort_values, and I wanna sort that by and set that equal to country. And now I'm also gonna make this in place so that it changes our data frame. So now, let's take a look at the country column for the first 50 results or so from this data frame. So I'm going to access that country column of the first and I'll just get the, first 50 of those by using the head method. So if I run this, then we can see that these are in alphabetical order. So we have results from developers from Afghanistan, and at the bottom here, the results go into Albania"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". So if I run this, then we can see that these are in alphabetical order. So we have results from developers from Afghanistan, and at the bottom here, the results go into Albania. Now we only have the top fifty results here, but if we were to look through all of these, then we'd see that all of these countries are listed in alphabetical order. Okay. So now let's look at, let's take a look at the salaries reported from these countries. So let me add that to our output here, and I'll just do that by accessing the, converted comp column. So that is converted comp. Now remember here, this is a mistake that some people make. Whenever we're accessing multiple columns here, we have to put this inside of a list within our brackets. So we're gonna have 2 sets of brackets here. Okay. So now let's run this, and we're going to have the salaries here for each respondent listed on the right"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". So we're gonna have 2 sets of brackets here. Okay. So now let's run this, and we're going to have the salaries here for each respondent listed on the right. We can see that we have a lot of not a number objects here, which just means that they skipped over the question. But if we wanted a general idea of the higher salaries, then we can sort these in descending order. So like we saw in our earlier example, if we want to sort the countries in ascending order and the salaries in descending order, then we can do that just by going up here and passing in multiple columns that we wanna sort on. So we wanna sort on country, and we also want to sort on this converted comp, column here. And also, I'm going to pass in an ascending argument here, and I'm going to set this equal to a list, and this will correspond to our column names whether we want these in ascending order"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". And also, I'm going to pass in an ascending argument here, and I'm going to set this equal to a list, and this will correspond to our column names whether we want these in ascending order. So for the country, I will pass in true that we do want those in ascending order, but I wanna see the highest salaries first, which means that we want this to be false so that the salaries are in descending order. So if I run this sort and then we take a look at this head again, then we can see that now, we have Afghanistan here, and all the highest salaries are listed at the top, for what people said they made. And if we scroll down here, we can see that we get to 0 and then not a number as the lower salaries. And then once we get down to I Albania, then it restarts with those high salaries from that country. Now we can see that there are some big outliers here. This is a lot larger salary than what other people, said that they made"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". Now we can see that there are some big outliers here. This is a lot larger salary than what other people, said that they made. Now there are some techniques that we can use in order to account for outlier data, and we'll focus on that in the next video where we, cover aggregating data and grouping data. Now before we end, I'd also like to take a look at some other useful methods for seeing the largest and smallest values. So maybe you're sorting results just so you can grab the largest or smallest values from a specific data frame. Well, if you are doing that, then there is actually a much simpler way to do this. So maybe we want to see the 10 highest salaries from our survey. So in order to do this, we could simply use the nlargest method. So first, I'm just going to run this on a series. So let's say that I want to grab that converted comp column, which is the salaries, and I will grab the n largest and I want to grab the 10 largest salaries"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". So let's say that I want to grab that converted comp column, which is the salaries, and I will grab the n largest and I want to grab the 10 largest salaries. So if I run this, then we can see that we get the 10 largest salaries reported. So these salaries are all the same here at 2,000,000. So I'm assuming that the survey capped, their salaries at 2,000,000 for this particular survey. So, you know, I think that's pretty high. So I'm curious to see what type of developers these people are and if they're in management roles or or not. And, again, we'll see how to further analyze these results in the next video. But, you know, if any of you all are making $2,000,000 a year as a developer and are hiring, then let me know because, you know, I'm not looking for additional work at the moment, but I do think I would make an exception here for $2,000,000 a year"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". Now you can see here, when we grab the 10 largest values from this series here, from this column, it only gives us the 10 largest values from that column. But what if we wanted to see the other survey results, from these rows? Well, in order to do that, then we can simply run this method on the entire data frame and pass in the column for which we want, the largest results. So I could say, df.nlargest, and then I want the 10 largest from the converted comp column. So if I run this, then these will give me those same rows, but now we have all of their survey results instead of just the salary. So if I go up here to their index, so this is 25983, then we can see the first one here is 25983. So this is the same result. If I scroll over here to converted comp, we can see that these are all $2,000,000 here. And if we wanted to see the smallest values instead of the largest, then instead of using n largest here, then we can simply say n smallest"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". And if we wanted to see the smallest values instead of the largest, then instead of using n largest here, then we can simply say n smallest. So if I look at the smallest salaries here, then this will give us the smallest salary values from our survey. Now, I'm assuming this is probably just 0 for people who aren't currently working, and yes, this is a 0 here. Okay. So that's a brief overview of how to sort our data and how to sort on multiple columns and get the largest and smallest values. Now before we end here, I would like to mention the sponsor of this video, and that is Brilliant. Brilliant is a problem solving website that helps you understand underlying concepts by actively working through guided lessons. And Brilliant would be an excellent way to supplement what you learn here with their hands on courses. They have some excellent courses and lessons on data science that do a deep dive on how to think about and analyze data correctly"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". They have some excellent courses and lessons on data science that do a deep dive on how to think about and analyze data correctly. So if you're watching my Panda series because you're getting into the Data Science field, then I would highly recommend also checking out Brilliant and seeing what other data science skills you can learn. They even use Python in their statistics course and will quiz you on how to correctly analyze the data within the language. Their guided lessons will challenge you, but you'll also have the ability to get hints or even solutions if you need them. It's really tailored towards understanding the material. So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/ cms to sign up for free. And also, the first 200 people to go to that link will get 20% off the annual premium subscription, And you can find that link in the description section below. Again, that's brilliant.orgforward/cms. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". Again, that's brilliant.orgforward/cms. Okay. So I think that's gonna do it for this Pandas video. I hope you feel like you got a good overview for how we can sort our data frames. In the next video, we'll be learning about aggregating and grouping data. Now, this will be the video that a lot of people have been waiting for, because this is what most people think of when they think of data analysis. So for example, we'll see how we can group our survey data by country, and then get the median salaries for each country and things like that. That also would take care of some of that outlier data that we just solved before. It's definitely a good skill to know in Pandas and will be, you know, open up a lot of possibilities for exploring your data further. But if anyone has any questions about what will be covered in this video, then feel free to ask in the comments section below, and I'll do my best to answer those"
    },
    {
        "title": "Python Pandas Tutorial (Part 7): Sorting Data",
        "text": ". But if anyone has any questions about what will be covered in this video, then feel free to ask in the comments section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up, and also it's a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute through patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": "Hey there. How's it going everybody? In this video, we're gonna be learning how we can group and aggregate our data. Now, if you don't know what grouping and aggregating really entails, then I'd really recommend sticking around for this video, because basically this is what most people think of when they think of actually analyzing data in a meaningful sense. So this will be the first video where we actually get some statistics back on our datasets and aren't just modifying our DataFrames in different ways. So for example, maybe you want to know what the average salary for a developer is, or maybe you wanna know, how many people from each country knows Python or another programming language. So what we're gonna learn here is going to allow us to answer those types of questions. Now I would like to mention that we do have a sponsor for this series of videos, and that is Brilliant"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So what we're gonna learn here is going to allow us to answer those types of questions. Now I would like to mention that we do have a sponsor for this series of videos, and that is Brilliant. So I really wanna thank Brilliant for sponsoring this series, and it would be great if you all could check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay. So before we start doing some more advanced data analysis, let's start off slow and build up to the more advanced stuff, so that all of this makes sense along the way. So I have my developer survey data open here that we've been using throughout this series. And as usual, if you'd like to follow along, then I have links to this code and the data in the description section below. So let's look at some basic aggregations"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". And as usual, if you'd like to follow along, then I have links to this code and the data in the description section below. So let's look at some basic aggregations. So if you don't know what aggregation means, basically it means that we're going to be combining multiple pieces of data into a single result. So for example, if you've ever used a mean, median, or mode in mathematics, these are aggregate functions because they take multiple values and give you either the mean, median, or mode of those results. So if we wanted to run some analysis on our developer survey here, one question we might ask is, okay, what is a typical salary for developers who answered this survey? So that might be some good information to have if you're looking for a job and want to get an idea of what these salaries look like at the moment. So to do this, we can grab the median salaries of our data frame. So first, let's look at these salaries"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So to do this, we can grab the median salaries of our data frame. So first, let's look at these salaries. So our salary column within this data frame here of all these survey results is called converted comp, and that is converted to US dollars. It's actually further over here in the survey. It is, about right here. So I'm gonna copy that. Now first, let's just look at this column. So as we've seen before, we can just access the column, just like we're accessing a key of a dictionary, and I'm gonna grab the first let's get the first 15 salaries or so. So I'm gonna look at the head of the of the, results here. And these are salaries here that developers put down for this survey. And these NAN values here just mean not a number. In this context, it means that they just skipped that question in the survey. Okay. So we can see the median salary for this survey just by running the median method on this series. So to do this, I'm gonna go ahead and copy what I have here"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". Okay. So we can see the median salary for this survey just by running the median method on this series. So to do this, I'm gonna go ahead and copy what I have here. And now instead of looking at the head, I can just run median on that series. So if I run this, then we can see that the median salary for this survey was around $57,000. So that takes all of the salary responses from our survey, from this series here, and it gives us the median value of all of those and ignores the NaN values. Now this probably doesn't give us as much information as we'd really like to have. So for example, different comp, countries pay different amounts, since there are different costs of living and things like that, so it would be nice if we could look at the median salary broken down by country, and we'll look at that here in a second when we learn about grouping data. But first, I want to cover a few more basic concepts before we move on to grouping"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". But first, I want to cover a few more basic concepts before we move on to grouping. So So one thing that I'd like to look at is running these aggregate functions on our entire DataFrame. So let's see what we get if we just run this median, function that we just ran on our entire DataFrame instead of just this single series. So here, I'm just going to say df. Median. So we're no longer accessing just a single column. So if I run this, then it might take a second to spin up here. So when I do this, it's going to look through our DataFrame and find the columns that contain numerical values where it can grab a median value. And some of these, might not make sense, to use with the median, but others might be pretty useful to us. So for example, we can see that the median age down here at the bottom, for this survey was 29 years old, and the median number of work hours per week, that was 40, which is pretty standard, so that makes sense"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". Now if you want to get a broad overview of your data and a statistical overview, we can use the describe method on our DataFrame instead. So if I instead run describe instead of median and I run this, then this is gonna give us a broad overview of some different stats. So if we look at the converted comp column here, then we can see a few different stats about this column. So it gives us the count, it gives us the mean, it gives us the standard deviation, the minimum, and then it also gives us the 25, 50, and 75%, quantiles here. Now this 50% marker is just the median value, by the way. And just like we saw before when we looked this, median value up specifically, this is around 57,000. Now this is in scientific notation here, so it looks a little bit different. Basically, this means that we just need to move 4 spots over from the decimal point. So 1, 2, 3, 4, so that would be 57,000 there"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". Basically, this means that we just need to move 4 spots over from the decimal point. So 1, 2, 3, 4, so that would be 57,000 there. So this describe method gives us a bunch of these aggregates in one place, if we just wanna get a quick overview of our data. Now if you're wondering why I wanted to look at the median of our salaries instead of the mean, which is the average, basically it's because the mean is affected too heavily by out outliers. It's not really a good metric to use because a few outliers can affect the average very heavily. We can see that the mean salary up here, if I highlight this right here, if we were to count this up, then that's actually about $127,000 on average, but that gives us an unrealistic expectation of what a typical developer salary is, because the largest salaries in our dataset are just pulling up that average so heavily. So in cases like that, you definitely wanna use the mean instead. I think that's a better representation"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So in cases like that, you definitely wanna use the mean instead. I think that's a better representation. Or I'm sorry, you're gonna want to use the median instead because that's a better representation. Now if we only wanted to get this overview for a single column, then we could just run this describe method on a single column as well and get those results for that specific series. Now you might be wondering what that count value is listed at the top of these described results. Now the count value is the number of non NA rows, which basically means that it counts the non missing rows. So in the context of this survey, a missing row just means that the respondent didn't answer that a specific question. So if I look at the count for the converted comp column so I'm gonna go up here and grab this, and instead of grabbing the median, I'm just gonna grab the count, we can see here that only about 55 to 65 or 55 to 56000 people answered that question"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". Now I think there are about 89,000 rows for this data, so that means that there are about 30,000 people or so who didn't answer the salary question on this survey. Now, I sometimes see the mistake that some people think that the count function will count up the individual values in a specific row and report how many of those values were in the column. But if that's what you're trying to do, then that's what we would use the value counts function for. Now in case that doesn't quite make sense, let's look at an example, to see what this looks like. So for example, we had the question on the survey that asked each person whether they coded in their free time as a hobby. So to see all of these responses for that question, we can look at the hobbyist column. So I'll just access that hobbyist column here and run that, and we can see that we get a series returned here, And these are just a bunch of yes or no questions. So it was just a yes or no question that each person answered"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So it was just a yes or no question that each person answered. So you might get the survey results back, and you might think to yourself, okay. Well, I can see the responses here in the survey, but I just wanna know how many people answered yes and how many people answered no. So how would we do that? Well, we can get that information with the value counts function. So if I just look at the value counts, and that is value underscore counts, if we run that method on that series, then that is going to give us a breakdown of how many people answered yes and how many people answered no as to whether or not they code as a hobby. So I use the value counts all the time when exploring data, and we can find out some interesting things from our survey by using this on some different fields. So for example, there is a question on this survey that asks each person what social media platform they use the most"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So for example, there is a question on this survey that asks each person what social media platform they use the most. So if you're building an app or a website and want to keep track of the most popular social media sites, then you might be interested in what the most popular answers to that question are. So to view these results, we can access the social media column of the survey. So let me do that. And before I run value counts on this, let me just show you what, this column looks like. So this column was called social media. So I'm gonna run this, and we can see that respondent number 1 said that they use Twitter more than any other social media. This person used Instagram, Reddit, Reddit, Facebook, YouTube, and so on. Now, I've pointed this out in previous videos so far, but if you've forgotten or if this is your first video that you've watched in this series, then at the top of my notebook here, I've also loaded in a schema data frame, right here"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". And this DataFrame tells us the exact question that was asked on the survey for each of these column names. So for example, if we wanna see the exact question that was asked for this social media column, then I can just access that schema data frame and do a dot loc because the indexes are going to be the column names, and then we can just search for social media. And if I run that, then we can see that the question that they asked on the survey specifically was, what social media site do you use the most? Okay. So we can see that we get a few different, responses here, but which of these are the most popular? So to find that out, let's look at the value counts of this series to see what the most popular social media sites are overall, for these developers. So I'm going to run this, and then I'm going to run that value counts function here"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So I'm going to run this, and then I'm going to run that value counts function here. And now we can see here at the top, that Reddit was the most popular with about 14,000 people, and then we have YouTube, WhatsApp, Facebook, Twitter, Instagram. I don't use social media was one of the answers. Now we also have, some foreign social networks here. So I've never heard of these, but, I believe these are Chinese characters, so this is probably a, a Chinese social media site. I don't know, really Russian writing, but I would assume that this is Russian writing here, so this is probably a Russian social media site. So it's kind of interesting seeing all of these different answers from around the world. Now one more quick tip. If we wanna see these broken down by percentage instead of raw numbers, then we can pass in the normalize argument to the value counts function and set that equal to true. So let me show you what this looks like. So I can say normalize equals true"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So let me show you what this looks like. So I can say normalize equals true. And now we're gonna get these broken down by percentage. So 17% of the people said that they use Reddit, 16 said YouTube, about 16 said WhatsApp, and so on. Okay. So we can see that we have some social media sites here from some other countries. So obviously, this is most likely a regional thing. My guess would be that the popularity of these social media platforms, varies a lot based on what country you're in. So how would we break up these results so that we can see the most popular social media sites for each country? Now in order to do this, we're going to have to learn about grouping our data. So again, this is a topic that can be a little confusing when you first see it, so let me start off slow so that we can see exactly what's going on here"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So again, this is a topic that can be a little confusing when you first see it, so let me start off slow so that we can see exactly what's going on here. So first of all, if we want to see specific results based on the country or based on some other column, then we are going to have to group on that specific column. And we have the group by function for this. So what actually does it mean to say that we are going to use the groupby function? So in the Pandas documentation, it says that a groupby operation involves, some combination of splitting the object, applying a function, and combining the results. So I'm gonna try to walk through each of those processes one at a time so that we can see exactly how this works. So again, in the Pandas documentation, it says that a group by operation involves some combination of splitting up our object, applying a function, and then combining those results. So let's do each of those"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So let's do each of those. Now first, just for a reference, let's display the value counts for each country so that we can see the countries that have the most results for this particular survey. So to do this, we can just access the country column, and if I run this, we can see that, this gives us the country that each respondent said that they were from. And if we look at the value counts for this, then this is going to tally up all of the unique responses. So we can see that, the majority of this survey was answered by developers in the United States, and, in second was India, then Germany, United Kingdom, Canada, and so on. Okay. So now let's look at how to use the group by function on our country column. So first we're going to split the object, and then we're going to apply a function, and then it will combine those results. So first, let's look at splitting the object. Now, in this case, we want to group all of the results by country. So to do this, we can simply say, df"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So first, let's look at splitting the object. Now, in this case, we want to group all of the results by country. So to do this, we can simply say, df.groupby, and then we will pass in, this is going to be a list of columns that we want to group on. And I'm just gonna pass in a single column here for country. So if I run this, then what we get back here is this data frame group by object. So what is this object, and what exactly can we do with this? So first, let's explain a bit what this is. So, this object contains a bunch of groups, and to better understand what this is, let's take a look at an individual group, that this DataFrame has. Now, before we do that, I am going to set this as a variable so that we can reuse this, and not have to retype our code over and over, and also it will be easier to read. So I am going to call this country group, and I'm just going to set this equal to this df.groupby"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So I am going to call this country group, and I'm just going to set this equal to this df.groupby. And now, instead of typing this every time, we can just reference this country group variable here. So now let's take a look at one of these groups. So since we grouped our rows by country, then we can grab a specific group by country name. So I'll grab the group for the United States. So to do this, we can say country group dot git_group, and then pass in the name of the group. In this case, I wanna get the group for United States. So if I run this cell, whoops, and this is telling me that country group is not defined, and it's because I didn't rerun this cell up here after I set that variable. So if I run this and grab the group for the United States, then we can see that we get a data frame returned here with some survey results. So, this doesn't look like anything special yet, but if I look at the country name for each of these survey results, the country is listed right here"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So, this doesn't look like anything special yet, but if I look at the country name for each of these survey results, the country is listed right here. Then we can see that all of these responses are from people who said that they were from the United States. And if I look at the group for India, so if I instead change United States to India here and grab that group, if we look at the country here, then these are all the survey results for people who said that they were from India. So that's what our data frame group by object that we saw before consists of. It has broken up all of the different responses into groups by country name. So this would be similar to running a filter on our original data frame. So I should be able to get these same results for a single country, just by doing what we've seen in previous videos and creating a filter"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So I should be able to get these same results for a single country, just by doing what we've seen in previous videos and creating a filter. So I could say, okay, I want to grab, I want our filter to be equal to, anytime the country is equal to the United States, and then I can apply this to our DataFrame by saying, okay, df dot loc, and give me all the results that match that filter. If I run this cell, then we can see over here in the country column, that all of these, results are respondents from the United States. So if we're just looking to get information on a single country, then it's very similar to just creating a filter like we did here. But instead of just grabbing, the results for 1 country, groupby instead splits all of these responses up by country name. So now that we have all of those split up and grouped by country name, now we can apply a function and bring those results back together"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So now that we have all of those split up and grouped by country name, now we can apply a function and bring those results back together. So what kind of function would we like to apply? Well, like I mentioned before, maybe we want to see the most popular social media sites broken down by country. Now if you just wanted to get the most popular social media sites, by the United States or by India, then we've already seen how we can do this. So right here, I have some filtered results down, to where we have the responses for the United States. So we can just do what we did before where we ran the value counts method on the social media column. So I could just say here, at the end, I could access that social media column of that filtered DataFrame, and then I could just run value counts here. So if I run this, then we can see that for the United States, we have Reddit, and Twitter, and Facebook, and YouTube as the top 4, social media sites"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So if I run this, then we can see that for the United States, we have Reddit, and Twitter, and Facebook, and YouTube as the top 4, social media sites. And if we wanted to look at these, specifically for India, then I could instead change that filter for India and run this, and we can see that WhatsApp came first, and then YouTube, then LinkedIn, and then Facebook. So these are the results for one specific country. But if we were to run this on our data frame group by object, then it will give us the results for all of those country groups. So, if it helps you with how you think about this, you can imagine that it is similar to running a filter and then applying a function like we did here with a single country, but when we group these using the groupby function and then apply a function, then it will combine those groups to give us the results for all of those unique countries. So I think this will make sense once we just see this here"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So I think this will make sense once we just see this here. So remember, I called our group up here, country group. If we come down here to the bottom, then we can say, okay, for the country group, now I want to, look at the social media column, and I wanna grab the value counts for that column for that entire country group. So if I run this, then what this returns is a series with the most popular social media sites broken down by country. Now, this actually cuts off a little early here, so let me grab a larger chunk of this series to get a better idea of what this looks like. So right here at the end, I'm just gonna say, dot head and look at the top fifty results or so. So if we run this, then we can see here that our first country is Afghanistan, and we can look at the most popular social media for that, and then go down the list. Albania, Algeria, Argentina, and so on. Now, this is actually returning a series, and this series has multiple indexes"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". Albania, Algeria, Argentina, and so on. Now, this is actually returning a series, and this series has multiple indexes. It has this country index and this social media index. Now, we haven't discussed multiple indexes in this series yet, but if anyone is curious about how this works, then maybe just leave a comment in the description section below, and maybe we can cover that topic in a future video. But, the country is the first index, and we can grab these just like we would with any other series. So again, if I wanted to grab those most popular social media sites, for India, for example, then I could just come up here, and with that returned series actually, let's take a look at this again. So here's the index here. I can grab that series just by saying dotloc, and then looking for India. And we can see that those are the same results that we got before"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So here's the index here. I can grab that series just by saying dotloc, and then looking for India. And we can see that those are the same results that we got before. Now, you might be wondering, well, hey, if those are the same results that I got before, then why is this even useful? And it's useful because now we can see this result with any country without running a filter on each individual country in the world. So, for example, if I wanted to see the most popular social media sites, for the United States, then now instead of, you know, changing a filter over and over, I could just, you know, go here and look at the United States index for this return series, and now we can see those results. So I think it's really interesting, being able to play around with your data like this and being able to explore. I really like seeing the different results for different countries, and a lot of these sites I've never heard of"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". I really like seeing the different results for different countries, and a lot of these sites I've never heard of. So for example, if we look at the most popular social media sites in China or in Russia, then let me look at China here. So we can see that, yeah, it does look like that was a Chinese, social media site, this WeChat or WeChat, and then we have I'm assuming this is pronounced Weibo maybe. But, yeah, I think that's very interesting. If we wanna look at Russia, then, we can't actually say just Russia. In this survey, Russia was called the Russian Federation. I've made that mistake before where I just type in Russia, and it'll tell you that it cannot find an index with that name. So this is actually Russian Federation, And if we search for that, then we can see I don't know how to pronounce this, but the one that I thought was Russian writing before, it does look like that was in fact Russian"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". And just remember, if it makes more sense, for you to, look at percentages instead of just raw numbers here, then you can always set normalize equal to true, and it will give you percentage results instead of the raw numbers. So we can see that this Russian social media site here, has 30%, or 30% of the people from Russia said that that was their, most popular social network. And if we go back to China, then we can see that this one here at the top, that has 67% of the developers from China said that that was the social media site that they used the most. So I just thought that was really interesting, being able to play around with these numbers and seeing the different results for different countries, and this is the kind of thing that we can do once we have got these skills down within Pandas. And a lot of the times, it's just fun being able to explore your data like this and finding things within your data that you might not have expected"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". And a lot of the times, it's just fun being able to explore your data like this and finding things within your data that you might not have expected. Now bringing this back to what we were discussing at the beginning of the video, we can also use this to run more traditional aggregate functions like mean, median, and things like that. So before, we looked at the median salaries for the entire survey, but now let's break these down by country instead. So just like we looked at the value counts of the social media column, we can look at the median of the salary column, and that salary column is labeled converted comp. So to do this, I can just grab our country group here, and we want to look at this converted comp column. And now we need to tell it what aggregate function we wanna see for all these countries, and I want to see the median salaries for all these countries"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". And now we need to tell it what aggregate function we wanna see for all these countries, and I want to see the median salaries for all these countries. So if I run this, then we can see that our result here is that it says, okay, here is the median salary in Afghanistan, here it is for Albania, and so on. So now if you wanted to, for example, see the median salary in a place like Germany, then we can just simply come up here, and this is the result that we get here, and these are our indexes. So the index, the indexes are country name. So if I wanna grab a specific country, then I can just use dot loc and type in the country name. So if I run this, then we can see that the median salary here in Germany is about 63,000. Now maybe you're working on some analysis where you want to group your data, but you also want to run multiple aggregate functions on your group. So let's say that we just didn't want to see the median, but we also wanted to see the mean as well"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So let's say that we just didn't want to see the median, but we also wanted to see the mean as well. So to do this, we can use the agg method, agg, and pass in all of the aggregate functions that we wanna use. So to do this here, I could just say let me grab, where we ran our median here. Instead of running just the median aggregate function, we're gonna use this ag method here, agg, and now we're gonna pass in a list of the aggregate functions. So let's say that I wanna get the median first, and then I also wanna be able to see the mean. So if we run this, then we can see that we get a data frame with the mean and the median salaries for every country. And, again, just like we did before, if I wanted to narrow this down, by a specific country, then we could easily do that just by grabbing one of these indexes here by country name. So if we wanted to look at the mean and median salaries for Canada, then I could just come up here and say dotloc, and then pass in Canada here"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So if we wanted to look at the mean and median salaries for Canada, then I could just come up here and say dotloc, and then pass in Canada here. Let me spell that correctly. And now we can see the, median salary and the mean salary for Canada. Now depending on what you're trying to do, you might run into some issues that you didn't quite expect. So for example, let's say that you're trying to figure out how many people in each country know how to use Python. So before we do this to our group, let's first look at how we do this with a single country using the filtering approach that we used earlier. So I'm going to scroll up to where we had that filter, and I'm gonna copy that and paste that in down here. Then I'm just going to get rid of this value counts section here. So currently, the filter that we have here is we are filtering the countries down to people who said that they were from India"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". Then I'm just going to get rid of this value counts section here. So currently, the filter that we have here is we are filtering the countries down to people who said that they were from India. So now, in order to figure out how many people said that they knew Python within this survey, we're going to use the string methods that we've seen in previous videos. And if you don't remember what these look like, then we could do this by doing something like this. We could say, okay. I want, all of the responses, for the people who said that they were from India. And now when I get that result, remember that this result here is just gonna be a filtered version of our data frame, our original data frame. And now we can say, okay, I also want, the language worked with is where they put the different the different languages that they actually use"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". And now we can say, okay, I also want, the language worked with is where they put the different the different languages that they actually use. So if we look at this language worked with column here, then we can see that they list all of the languages that they said that they know, And to see if Python is within, this column here, then I can say dot str and use the string class on that return series and say, okay, we want where the str dot contains Python. So this will return true, for the rows that have Python in the languages worked with, and false for the responses that don't. So if I run this, then this just returns a series of true and false values where it tells us whether the language worked with column for each respondent contained that string of Python. Now, if we want to actually count the number of people who know Python, then we can use the sum function to add all of these up"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". Now, if we want to actually count the number of people who know Python, then we can use the sum function to add all of these up. Now, normally, you might think that sum would only work with numerical data, but sum will also work on booleans. It will count all of the trues as 1 and all the falses as 0. So to find out how many people know Python, then I could simply just do a dot sum here at the end. If I run this, then we can see that around 3,100 people, from India, who answered the survey said that they knew Python as one of the languages that they work with. Now before, when we wanted to run a similar aggregation function on our data frame group by object, we simply took the same approach on our group by object. So So for example, you might think that we could just do something like this. To see all of these, to see how many people knew Python from each country, you might think that we could say, okay, well, I should just be able to do this"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". To see all of these, to see how many people knew Python from each country, you might think that we could say, okay, well, I should just be able to do this. I could just say, okay, for this country group, I want to look at this language worked with column, and then see the strings that contain Python and sum those up. But if I run this here, then we can see that we get an error. Now, like I said in a previous video, sometimes it can be hard to read these Pandas errors and understand exactly what we did wrong, but in this case, it actually gives us a pretty good clue as to what we did wrong. It tells us that we cannot access the attribute string of a series group by object, and then it says try using the apply method instead. So the reason that we get this error here is because this is no longer just a series. Instead, this is a series group by object, and it tells us to instead use the apply method"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So the reason that we get this error here is because this is no longer just a series. Instead, this is a series group by object, and it tells us to instead use the apply method. So, when we run an apply method on a group object like this, we are going to specify a function that we want to be run on every series in this group. And I know that can sound a little bit confusing, so let's actually see what this looks like, and, hopefully, it'll clear this up a bit. So instead of accessing this string class, directly here, I'm instead going to use the apply method. And for anybody following along or who will download this, I'm gonna go ahead and leave this cell with this error here, so that you can run that and reproduce that error, and then I'm gonna do the correct way in this cell. So, again, instead of using the string class directly on this series group object, I'm instead going to use the apply method. Let me just cut that out and I'll say dot apply"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So, again, instead of using the string class directly on this series group object, I'm instead going to use the apply method. Let me just cut that out and I'll say dot apply. And now, we can apply a function that we want to run on each series in this group. So if you've seen one of the previous videos, then you'll know that if we just want a nice, quick, easy function, then we can use a Lambda function. You could write another separate function if you wanted to, but here I'm going to use Lambda. So Lambda here is going to be a series. So now we can say, okay. Well, what do we want to return? Alright. Well, I wanna return x, and then since this is a series, we can say x.string.containsPythondot sum"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So now we can say, okay. Well, what do we want to return? Alright. Well, I wanna return x, and then since this is a series, we can say x.string.containsPythondot sum. So again, just one more time, we are running the apply method on this series group, and then we are passing in a function that is going to run on each one of these series, and the function that we want or what we want returned from that function is the sum of, any of the values in that series, that contain the string Python, and it's gonna do that for every country since we're using this country group. So if I run this, then we can see here, that we see okay. In Afghanistan, 8 of the respondents said that they know Python, Albania was 23, and so on. Now seeing these numbers by itself isn't really that big of a help if we're trying to get an understanding of the percentage of people in each country who said that they know Python. Because with these results here, we only see a single number"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". Because with these results here, we only see a single number. We'd have to go back and forth and compare, okay, how many people answered their survey from each country, and how many of them use Python, and then we could do a calculation from there to figure out the percentage of people from that country who knew Python. But we don't wanna do that. That is too much to do manually. So we want to figure our way so that we can get Python and Pandas to do this calculation for us. Now, a lot of people have asked me to put together coding problems to practice what we learn in these videos, so you can think of this as practice. So I'll do this here. So can any of you think of a way where we can figure out what percentage of people in each country know how to use Python? If you think that you can figure that out, then you can pause the video here and try to work through this yourself, and it's going to combine a few topics that we've discussed in the series so far in order to do this"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". But with that said, I'm gonna go ahead and move along with my solution. So, again, if you wanna try to figure that that out on your own, then you can pause the video and try to work that out. And if you did do that, then I hope that you were able to, get something figured out there. But if not, then no worries. Let's go ahead and walk through my solution here, so that you can use this as practice to get better with pandas, so that you can do this type of analysis in the future. So like I said, in order to get the percentage of developers, who know Python for each country, we are going to use a combination of a few different things that we have learned throughout this series so far. Now, there are probably several different ways of answering this question, and if you have a different, way that you answered this question than me, then definitely leave it in the description section below so that people can see different approaches to this"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". You know, it's absolutely possible that there's a more efficient way than how I'm about to do it here. So if there is, then I'll highlight that so others can see what the best approach is. But here's how I'm gonna do this. So first, I'm gonna grab the total number of respondents from each country. That way, we, know the total number of people from each country who responded to this survey. So I will just call this, country respondents, and I will set this equal to, we want to grab the value counts of the countries here. So if I print out what we get here, we've seen this before. Whoops. And I got an error there because I put county, I meant to put country. So if I look at this, then these are the total number of respondents who said that they were from each country. And again, we saw this earlier in the video. So now I'm gonna grab the total number of people from each country who know Python, and we just did this a second ago right here"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". And again, we saw this earlier in the video. So now I'm gonna grab the total number of people from each country who know Python, and we just did this a second ago right here. But I'll go ahead and do this again and set it as a variable, so that we have all of these steps. So I'm going to grab all of that that we just calculated, and now I'm gonna set this as a variable, and I'm gonna call this, you know, country uses Python, and then I'll set it equal to that. And now let's print out that variable as well. So let me go to the next line here. My computer's kinda giving me some grief. Okay. So these are all the people from each country who said that they know how to use Python. So now we have one variable that is a series that has the total number of people from each country, right here, called country respondents. And then we have another variable that is a series that is the total number of people from each country who know Python. So now we need to combine these 2"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". And then we have another variable that is a series that is the total number of people from each country who know Python. So now we need to combine these 2. Now, I'm actually going to use a method here that we haven't discussed in this series yet. So if you got stuck here, then that's completely understandable. I probably should have mentioned this in the video where we appended rows to a data frame, but we can combine more than 1 series together using the Pandas concat function. So let's see what this would look like. So I can say and I'll just call this data frame Python df. And now I'm gonna create a data frame where we concat those 2 series into 1. So I can say pd.concat, and now I'm gonna pass in a list of the series that we want to concatenate. So I want this to be our country respondents and I also want to add in this country uses Python series"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ".concat, and now I'm gonna pass in a list of the series that we want to concatenate. So I want this to be our country respondents and I also want to add in this country uses Python series. And now, we also want to set axis equal to columns because by default, it's going to try to concatenate these on row, but we wanna match up the indexes here so that it concats it, that way instead. So we wanna say axis is equal to columns. And then finally, I'm also gonna put sort is equal to false. Now if you watched a previous video, this isn't absolutely necessary, but if you run it without sort equal to false, then it'll give you a warning saying that in a future version of Pandas, that it'll sort by default or sort by false on default, so it's better just to go ahead and specify if you want the, resulting data frame sorted or not. So now let's look at this concatenated data frame here. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So now let's look at this concatenated data frame here. Okay. So now we have a data frame here where these two series have been concatenated and match up on the same index. So this is a lot more useful because now we can see, okay, there were about 20,000 or 21,000 people, who said that they were from the United States, and about 10,000 people who said that they know Python. So that's definitely a lot better and more useful information. Now, one thing about this new data frame that, we have is some columns that don't really relate to what we're talking about anymore. We can see here that this one is just called country, and this one is called languages worked with. So let's rename these so that they make more sense in the context of what we're actually trying to do. And we saw how to rename columns in a previous video as well. But if you forgot, then you can do this just by grabbing our data frame here, and I'll say, Python df, which is our data frame, dot rename"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". But if you forgot, then you can do this just by grabbing our data frame here, and I'll say, Python df, which is our data frame, dot rename. And now, what do we want to rename? We want to rename the columns, and now I'm going to pass in a dictionary here where the key is the previous value and the value is going to be the updated value. So I will call this, number of respondents, and then I also wanna change this languages worked with column here, and I wanna change this, to be let's call this NumKnows Python. And if I run this, then we can see that this looks good. We have number of respondents from the United States, and number knows Python from the United States. So that looks good to me. So since it looks good, I'm gonna say in place is equal to true so that it actually modifies our data frame. So if I run that and then look at our data frame one more time, then we can see that it has been updated with those new columns"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So if I run that and then look at our data frame one more time, then we can see that it has been updated with those new columns. Now we have the total number of respondents from each country and the number of people who know Python from each country in one data frame. So we have all the information that we need to calculate a percentage. Now all we need to do is create a new column and calculate this. So if you remember, in order to create a new column, we can simply just assign it. So I will call this column, PCT for percentage, knows Python, and now what do we want this to be equal to? Well, if you don't know how to calculate a percentage mathematically, basically what you do is you take the part and then divide that by the whole, and then you multiply that by 100. So our part here is the number of people who know Python"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So our part here is the number of people who know Python. So I will grab that and say, python_df and access that series, access that column, and then I wanna divide that by the whole, and the whole are the total number of people from that country. So that is num respondents. And now if we want this to be a whole number percentage, then we can multiply this by 100. Okay. So if I did all of this correctly, and it's very possible I made a mistake, but if I did all this correctly, then we should have a data frame here with the percentage of people who know Python from each country. And now we can work with this just like any other data frame. So let's say that we wanted to sort these results. Now, we learned this in a previous video on how to sort values in a series. So let's say that we want to sort the countries by the largest percentage of respondents who know Python. So to do this, I can just say, Python df"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So let's say that we want to sort the countries by the largest percentage of respondents who know Python. So to do this, I can just say, Python df.sort underscore values, and if you forget how to do any of this, then you can always go back to our Pandas video where we learned about sorting. So in order to sort by the people who know Python or the percentage, we can say, okay, sort by what did I call this here? Percent knows Python, And then I actually want this to be in ascending order equal to false because I want the largest percentage of people who know Python at the top. And I was about to put in place equals true first, but let's see what this looks like. Okay. So it looks like that that sort worked and it looks good. So now I'll say in place is equal to true so that it modifies our data frame, And now, we can look at our results here"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". Okay. So it looks like that that sort worked and it looks good. So now I'll say in place is equal to true so that it modifies our data frame, And now, we can look at our results here. So we can see here that, some of these are a little misleading here because, you know, a 100% of people from, Sao Tome and Principe know Python, but we only had one person from the country who answered the survey, and he happens to know Python or she. So that is a 100%. So instead, let's look at the head here and grab, see if we can find a country here with a larger number of respondents. So okay. We have 72 people from Uganda, and 47 of them knew Python, so that's 65%. That's pretty good. We have oh, okay. So this is United States. That's not bad either. We have about 21,000 here, about 10,000 new pythons, so that's 48%. So that's in the higher range. That's pretty good. So yeah"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". We have oh, okay. So this is United States. That's not bad either. We have about 21,000 here, about 10,000 new pythons, so that's 48%. So that's in the higher range. That's pretty good. So yeah. I think this is a great way to practice working with pandas, and also it's just fun being able to explore your information in this way. And now that we have a data frame with all this information, then we can also inspect a specific country to see what the percentage of developers are from a specific country who know Python. So for example, instead of looking through what if I wanted to see Japan? Instead of looking through all of these, I could just say, okay, Python df.loc, and since our country names are our, indexes here, then we can just do a dotloc of Japan, and then we can see that we get these statistics for that specific country. Okay. So I know that that may have been a lot to take in and that we covered a lot of ground in this video"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". Okay. So I know that that may have been a lot to take in and that we covered a lot of ground in this video. We definitely covered some more advanced topics here than we did in previous videos, but I hope this kind of got you a little excited to learn what you can do with Pandas, and the types of problems that we can solve. You know, when you are exploring through your data like this, you're probably gonna make a ton of mistakes along the way. You know, I still make mistakes in pandas all the time. Even in these videos, I've made some mistakes, and I have these scripted out. So it definitely happens, but, you know, each problem that we work through, similar to this, just makes it easier and easier each time to work through additional problems. So if you need to go back and rewatch some of these steps in order to work through these problems like this on your own, then that's completely normal"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So if you need to go back and rewatch some of these steps in order to work through these problems like this on your own, then that's completely normal. You know, don't think that just because this may have seemed difficult, that there's something wrong with you. It's definitely normal for this stuff to be a lot of information to take in. And also, like I said before, if you have some other ways of solving the problems that we answered here, then like I said, definitely leave a comment with your solution in the description section below, and I'll take a look at those. And I'll highlight some if they are better than what I did here. Okay. So before we end here, I would like to mention the sponsor of this video, and that is Brilliant. So in this series, we've been learning about pandas and how to analyze data in Python, and Brilliant would be an excellent way to supplement what you learn here with their hands on courses"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So in this series, we've been learning about pandas and how to analyze data in Python, and Brilliant would be an excellent way to supplement what you learn here with their hands on courses. They have some excellent courses and lessons that do a deep dive on how to think about and analyze data correctly. For data analysis fundamentals, I would really recommend checking out their statistics course, which shows you how to analyze graphs and determine significance in the data. And I would also recommend their machine learning course, which takes data analysis to a new level where you'll learn about the techniques being used that allow machines to make decisions where there's just too many variables for a human to consider. So to support my channel and learn more about Brilliant, you can go to brilliant.org forward slash c m s to sign up for free"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So to support my channel and learn more about Brilliant, you can go to brilliant.org forward slash c m s to sign up for free. And also, the first 200 people that go to that link will get 20% off the annual premium subscription, and you can find that link in the description section below. Again, that's brilliant.orgforward/cms. Okay. So I think that's gonna do it for this Pandas video. I hope you feel like you got a good idea for how to use these aggregate functions, and also how we can group our data so that we can explore our data in interesting ways. I would really encourage you to take some time after this video and play around with the data a bit. See if you can answer certain questions that someone might have about this data. So for example, what is the most common education level for people who answered this survey? That's definitely something that we, could answer by what we learned here"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". So for example, what is the most common education level for people who answered this survey? That's definitely something that we, could answer by what we learned here. So I hope you feel like you got a good introduction to being able to answer those types of questions. Now in the next video, we're going to be learning about how to handle missing data and how to clean up your data. It's very common for data to have missing values, so knowing how to sanitize and clean our data is definitely going to be important. But if anyone has any questions about what we covered in this video, then feel free to ask in the comments section below and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up. And, also, it's a huge help to share these videos with anyone that you think would find them useful"
    },
    {
        "title": "Python Pandas Tutorial (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data",
        "text": ". The easiest way is to simply like the video and give it a thumbs up. And, also, it's a huge help to share these videos with anyone that you think would find them useful. And if you have the means, you can contribute through Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": "Hey there. How's it going everybody? In this video, we're gonna be learning how to work with date and time series data within Pandas. Now there's a ton of interesting stuff that we can do with datetime data, and we'll be learning about that here. So we'll learn how to properly read in our data so that we can use datetime functionality. We'll also see how to filter by datetimes, how to group dates by resampling the timeframes, and we'll also take a look at doing some simple plotting with our time series data as well. Now I'd like to mention that we do have a sponsor for this series of videos, and that is Brilliant. So I really wanna thank Brilliant for sponsoring this series, and it would be great if you all could check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay. So first of all, I've been using the Stack Overflow survey data for this entire series so far, but that dataset doesn't actually have any date or time series data, so I had to choose a different dataset for this video. I downloaded some historical cryptocurrency data that we can analyze for this video, and as usual I'm going to have links to download the data and the notebooks that I'm using in the description section below. So I've got my notebook opened up here where I'm reading in this CSV file of data, and, let's go ahead and take a look at what this looks like. So we can see here that I'm loading in this CSV file and I called this eth_oneh, and that's because this is historical data for Ethereum, which is a cryptocurrency, and I'm, and this data is broken down on 1 hour segments"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So if we look down here at the head of this data, we can see that we have some columns here. The first one is a date column, and these are broken down by the hour. We also have some other information here like the symbols, the open and closing values for these hours, the highs and lows, and also the volume. So we can so all of this here is for, let's see, March 13th, and this is for 8 pm, 7 pm, 6 pm, and so on. Now remember, if you want to see more, information about your DataFrames, so for example how many rows and columns there are, I can run df. Shape, and we can see that there are 23,000 rows here, almost 24,000. So a good bit of data for us to work with. Okay. So now let's actually get into working with daytime data. So we have this date column here, and it looks like this is just giving us every hour of the day. But right now, this isn't actually a datetime object"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So we have this date column here, and it looks like this is just giving us every hour of the day. But right now, this isn't actually a datetime object. I can kinda tell this just because it's not in a format that datetimes usually display as, but if you want to be sure, you can always try running a pandas data, pandas datetime method on this to see if it works. So let me just grab the 1st row of this DataFrame, and I'll grab that date value. So, and then I'll go ahead and try to run a datetime method. So to grab that first step value, I'm just going to say df.loc, and we can see here that the index is just 0 over here, so I'm just going to pass in a 0, and I want to grab that date column there. So if I run what we have now, then we can see that I've plucked out that first date. So now let's just try to run a date time method on this. So there's one method called day name that will give us the weekday that this date fell on"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So now let's just try to run a date time method on this. So there's one method called day name that will give us the weekday that this date fell on. But if I run this now and I say, okay, dot day name for this value here, if I run this, then we can see that we get an error and it says, that a string object has no attribute day name. And that's because we are reading this in as a string currently. So how do we convert this to a datetime? So there's a few different ways that we can do this, and we'll go over some of those here. Now if you wanna convert a column like we have here to a datetime, then we can use the pandas to underscore datetime method. So to do this, I could simply say we'll access that date column and we'll set this date column equal to and then we'll just say pd to underscore datetime. And now I want to pass in that same column to convert that to a datetime"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". And now I want to pass in that same column to convert that to a datetime. Now I'm not going to run this right now because if I run this as is, then Pandas would do its best to figure out the formatting of the date time and convert it accordingly. But the date time that I have here is in a pretty different format, so I doubt that this is gonna work. But let's go ahead and try it out anyway. Okay. So I expected to get an error. If we scroll down and look at the error here, we can see that it says unknown string format, so it did not know how to parse this date. But like I said before, depending on how your dates are formatted, then that might actually work for you. This just so happens to be formatted in a way that Pandas can't convert this automatically, without us telling it how our date is formatted. So what we need to do here is pass in a format string specifying how dates are formatted so that it can parse this correctly"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So what we need to do here is pass in a format string specifying how dates are formatted so that it can parse this correctly. Now I went ahead and I created the correct, string format ahead of time for this specific date, but just to be clear, I never really remember these formatting codes off the top of my head. I always need to go and find these codes within the pop, Python documentation. So I have that page open here, and I will leave a link to this in the description section as well. But however your date is formatted here, So ours started with the year, so we can see that that is a percent y. And then we have the month day, so we could find that in here. Another one is that we have, like, 8 PM and things like that. So we can see here that, these eyes here, this eye is for a 12 hour clock, which is what ours is doing, and then this percent sign p is for the local equivalent of AM or PM"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So we can see here that, these eyes here, this eye is for a 12 hour clock, which is what ours is doing, and then this percent sign p is for the local equivalent of AM or PM. So those are going to be in our format string, but I'll leave a link to this just in case your date formatting is different and you need to create your own. So the format string that I need to pass in here, and again, this is basically just telling Pandas how to parse our date, we're gonna say that first we're gonna see the year, and then a dash, and then the month, and then the day with a dash in between that, and then a space, and then percent I was that 12 hour clock, and then there is a dash and then it is percent p. So let me go ahead and run this, and if I put this in correctly, then this should work. Okay. So we didn't get any, errors there, but let's go ahead and make sure"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So let me go ahead and run this, and if I put this in correctly, then this should work. Okay. So we didn't get any, errors there, but let's go ahead and make sure. So I'm going to go ahead and look at the date column here, and we can see that now, these look more like datetime objects that we might be used to seeing in programming. So it converted 11 PM to 23. Well, I'm sorry. I thought 11 PM was the first one. No. It's 8 PM. Okay. So it, converted 8 PM to 20 and 7 PM to 19, and so on. And now that this is converted to a datetime, we should be able to run these datetime methods that gave us an error before. So up here where we got this error, where we tried to grab the day name for these, I'm just gonna copy that and paste that in down here. And now let's try to rerun this, and we can see that now it's saying that that first date in our series here, this, March 13th was a Friday. Okay. So that's nice. So it looked like it works"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". And now let's try to rerun this, and we can see that now it's saying that that first date in our series here, this, March 13th was a Friday. Okay. So that's nice. So it looked like it works. Now the way that we did this here is that we converted this to a date, after we loaded in our data with this line right here. But if we wanted to convert this to a date as we're loading in our data, then we can also do that as well. So if I go up here to the top where we loaded this in, at this read CSV line here, then I can actually pass in some arguments to read CSV, so that it loads in certain columns as date times, and then we can pass in our formatting string as well, so that it parses those as the data is read in. So to do this we need to pass in this parsed dates, argument here, and now I'm just going to pass in a list of the columns that are going to be dates. We only have one here, so it's just gonna be a list of 1 item. Oops. And I meant to put date, not dates"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". We only have one here, so it's just gonna be a list of 1 item. Oops. And I meant to put date, not dates. And now just like with before, if your dates are already formatted in a way that Pandas can parse them, then you don't need to add anything else here. But we already saw before that we need to pass in a specific format. So to do this here, we can't just pass in a format string. We instead need to pass in a function that converts each String to a DateTime object. So first, let's create that function. And we've seen Lambda functions in this series before, but just in case you're unfamiliar with those, you can simply create a normal function instead if you are more comfortable with those, but this is just a shorter way. So to create this Lambda function, I'm just gonna call this d_ parser. I'm gonna set this equal to a Lambda function, and I'll just use x as the variable here. And now what do we want to return? So when we used pd"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". I'm gonna set this equal to a Lambda function, and I'll just use x as the variable here. And now what do we want to return? So when we used pd.2 datetime down here, we actually passed in an entire series to pd.2 datetime. But now this is actually just going to be each individual string, and it's going to send each individual string through this function. So in order to convert this, we can use a function called pd. Datetime. Strp time. That's how we convert a string to time. And then we can just pass in our string that we want converted to a datetime, and then the format. And I already had the format down here, so I'll just go ahead and copy that and paste that in here. And that's all we need for that date parser function. So now the argument for the date parser is date underscore parser, and I'm going to set that equal to that d parser, variable there that is set to our Lambda function. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So now the argument for the date parser is date underscore parser, and I'm going to set that equal to that d parser, variable there that is set to our Lambda function. Okay. So now if I run this cell here, then we can see that we didn't get any errors, so that's good. And now if I run this df.head here, then we can see that now our DataFrame, was already loaded in as a datetime. So we didn't have to do any conversions later on, it just did it as it was reading in that CSV file. Okay, so now let's look at some more useful things that we can do with date times. So first, I'm going to delete the sales that we have below here, so that we are not converting these columns again, since they are already loaded in as, dates. So I'll delete that one. I will delete that one since that was what was converting it earlier. I'll delete that as well, And I'll keep this one here just for reference since I will have these up on my GitHub afterwards. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". I'll delete that as well, And I'll keep this one here just for reference since I will have these up on my GitHub afterwards. Okay. So before, actually right here, we saw how to run a datetime method on a single value, when we use this day name method. But what if we want to run that method on our entire series? So let's say that we wanted to view the day name of this entire date column here. So to do this, we can access the dt class on the Series object and access the datetime methods that way. So to do this, we can just say we can first grab that series, so that date column is going to return a series. If I run that, we can see that we get all those values. And now if we wanted to access the dt class on the series object, then we can just say dot dt, and now the date time method that we wanna use. So if I wanna get the day name of all these values, then I can just do day name there"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So if I wanna get the day name of all these values, then I can just do day name there. And if I run that, then we can see that we get the day of the week for each of the dates in this Series. So using the dt class on the Series object is very similar to how we access the string class or the str class for the string methods on an entire Series, and we saw that in previous videos. So this can definitely be pretty useful. So let's say that we wanted to, you know, create another column so that we could quickly reference what day all of these trades took place. So to do that, we could just grab what we have here, and I could simply create a new column by, simply like I'm accessing a column. So I could call this column day of week and set this equal to and paste in that date time method there"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So I could call this column day of week and set this equal to and paste in that date time method there. If I run this, and then we look at our data frame, then we can see that now we can quickly see over here on the right, that, okay, 13th was a Friday, and then we have these dates down here towards the end. This was a Saturday. So it's nice to see or be able to see what days these trades actually took place. So now let's look at how we can explore our data a bit. So we can see by looking at the indexes here on the far left that there are over 20,000 rows in this dataset. So let's see how we can view the earliest and latest dates in this data. So to do this we can use the min and max methods. So to see the earliest date, I could simply access this date series here and I could just run the min method on this. If I run that, then we can see that the earliest date that it gives us is 20 17, 0701. Now if I wanted to see so what is that? That's, July 1, 2017"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". If I run that, then we can see that the earliest date that it gives us is 20 17, 0701. Now if I wanted to see so what is that? That's, July 1, 2017. So to view the most recent date that I have, and it should be the date that I downloaded this data, then I can just look at the max value here. And if I run this, then we can see that, this is March 13th 2020, which actually was the day that I downloaded this data. And one really cool thing with date times is that we can actually subtract dates in order to view the time between those two dates, and this is called a time delta. So to get the amount of time that spans between these two dates here, then I could simply say, take the max value and then subtract the min value. And if I run this, then we can see that we get this timedelta, that says that there were almost a 1000 days between the earliest date in our dataset and the most recent. So we have 986 days in this entire dataset of cryptocurrency data, almost a1000"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So we have 986 days in this entire dataset of cryptocurrency data, almost a1000. So that would definitely be a lot of days to look through if we want to find some specific ranges. So what if we wanted to do some filters by date? So for example, let's say that we just wanted to view the data for 2020. Now that we have these converted to date times, we can create filters just like we have in previous videos, and we should be able to use, strings that are formatted like date times, or we can use actual date time objects. We'll take a look at both. So let's see an example of this in some code so that it makes some more sense. So first, I'm gonna create a filter in a separate variable like I've done in previous videos, but you can also do this inline if you prefer to do it that way. I just think that, creating our filters separate is a little bit easier to read. So let's say that I want, our date series"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". I just think that, creating our filters separate is a little bit easier to read. So let's say that I want, our date series. I want the objects or the rows that are greater than, and then I'm just gonna pass in a string here for now. And I can just pass in a 2020 there, and Pandas will know that I'm talking about the year 2020. Let's actually do a greater than or equal to here. Okay. So now that I have that filter, let's just do a df dotloc. Again, we've seen this in previous videos, and then I'll pass in that filter. So if I run this, then my bottom row here should be January 1, 2020, and it is. And we can see that we have, 17000 hours here of 2020 data, or I'm sorry. That's, 1700 hours of 2020 data. Okay. So the reason that this doesn't go above 2020 is simply because, you know, our latest data runs out. So we're not getting 2021, since, 2021 hasn't happened yet. But what if we wanted data for 2019? Well, in order to do that, we'd also have to put in an upper bound as well"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So we're not getting 2021, since, 2021 hasn't happened yet. But what if we wanted data for 2019? Well, in order to do that, we'd also have to put in an upper bound as well. So to do that, I'm gonna say, okay. We want our data to be greater than or equal to, 2019, and and we just wanna do an ampersand there. I'll go ahead and copy this here and then just replace this with a less than, and we'll say less than 2020. If I run this, then we can see that our bottom row here, we have January 1, 2019 at midnight, and then our top row here is December 31st at 11 pm, 2019. So that gives us all of the rows of data that we have for 2019. And right now we're just using, strings up here for these comparisons, but we can use actual date times as well. So to do that, we could actually say I could just say pd.datetime, and then let me go ahead and pass in the month and day here as well. So I'll say that I want this to be greater than 2019, January 1st"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ".datetime, and then let me go ahead and pass in the month and day here as well. So I'll say that I want this to be greater than 2019, January 1st. And then I'll just grab this here and replace this 2020. And then I'll say but I want this to be less than 20 twenty's January 1st. So now if I run this, whoops, and I got an error here. The it says, you know, integer is required. Got a string. That might not make sense. What I did here is I don't want pd.datetime. That was my mistake. I want to do the same thing that we did before and do to datetime so that it converts the string here to a datetime. So let's do pd.todatetime for both of those and run this. And now we can see that we get those same results as before, for all of the rows in 2019"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So let's do pd.todatetime for both of those and run this. And now we can see that we get those same results as before, for all of the rows in 2019. Now one nice feature about dates is that if we set our index so that it uses, the date, which would actually be a good idea for this dataset since all of these, date or time stamps are unique, then we can actually do this same thing by using slicing instead. So let's see what this looks like so that it makes more sense. So first, let's set our index so that it's using this, date column here. So here at the bottom, I'm gonna say, df dot set underscore index, and then I'm gonna pass in, that we wanna set the index to date. And if I run this, then that looks good. We have, set it our index to use date here. And now that that looks good, it actually didn't make that change. I want to say in place is equal to true, to make that change permanent. So I'll run that, and if we look at our data frame again, then now we have that date as our index"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". I want to say in place is equal to true, to make that change permanent. So I'll run that, and if we look at our data frame again, then now we have that date as our index. And now with that date index, we can actually filter our dates just by passing them into our brackets. So if we wanted the data for 2019, then I could literally just say, that I want the data here for 2019, pass that into my brackets. If I run that, then we can see that we get the same thing here. We get, this value for, January 1st, and then the top value here is for, December 31st. So it's a bit easier, to, you know, just access these within brackets when these are our indexes, rather than creating a filter. Now if you want to grab dates for a specific range, then you can use a slice. So let's say that we wanted all of the data for January February of 2020. So to do that using this slicing here, then I could say, okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So let's say that we wanted all of the data for January February of 2020. So to do that using this slicing here, then I could say, okay. I want from 2020 o 1, which would be January, and then I could just do a slice here using that colon, and then say, okay. Well, I wanna go up to, February of 2020. So if I run this, the second value here is inclusive, so we can see that we have, January 1, 2020 down here at the bottom. That slices all the way up to February 29th, since this was a leap year. Now this can be really useful for analyzing our data, because let's say that we wanted to get the average closing price for Ethereum for all of our rows of these dates. To do that we could simply grab this close column here and then grab that average or grab that mean. So to do that we can just say let me copy this part here. First let me just access that close series there, that column"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So to do that we can just say let me copy this part here. First let me just access that close series there, that column. If I run that, then we can see that we get all of those closing values on each of those hours for all of those days. And now to get the mean of that, I can just say dot mean, and that gives us the average closing price for all of those rows within that time frame. And remember, each of those days is reporting by the hour. But what if we wanted to see this data in a different way? What if we instead wanted to look at this data on a daily basis instead of on an hourly basis? Well, first, we need to think about what would make sense to view on a daily basis. So for example, let's say that we wanted to, you know, view the highs for each day. So right now, we have, all of these highs broken down, by hour. Let me actually look at the first let me grab this date range here, and let's look at the first, 24 of these so that we can get 24 hours here"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". Let me actually look at the first let me grab this date range here, and let's look at the first, 24 of these so that we can get 24 hours here. So we can see that for February 29th, we have all these different hours here, and each hour has a different high value. But what if we were like, okay, well, we see all these different high values here, but what was the highest value of the day? So actually, let me just grab a single day here, and then we will look at the high values for that. So instead of doing all of these dates here, I'm just going to grab January 1, 2020, and then we will look at the high values for that day. So again, we don't really care what the highs are for each hour of each day, We just want to know the high for the entire day. So to do this, all we need to do is grab the max value for this series. And we saw how to do this. It's just like running mean right here. All we have to do is say dot max"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So to do this, all we need to do is grab the max value for this series. And we saw how to do this. It's just like running mean right here. All we have to do is say dot max. And if I run that, then we can see that the high value for that day was 132 point 68. Okay. So let's remember this value here right now, this 132.68, because we're going to see how we can resample our data, so that we can get the highest trades for each day of our data, and then we'll use this one here to compare for, January 1, 2020. So again, right now our data is broken down on an hourly basis. So if we want to redo this so that it's instead broken down by day or week or month, then we'll do this by doing something called resampling. So let's see what this looks like. So if I want to resample this and see the high value by day, then I can simply access this high column here. And then on that series I can say, okay, I want to resample this. And now we have to tell resample how we want to resample this data"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". And then on that series I can say, okay, I want to resample this. And now we have to tell resample how we want to resample this data. Right now it's hourly. If I put in a d, then it resamples it to days, and I can do 1 d or 2 d. You can do whatever there. You can do a w for week. There's all kinds of different codes here. Now, just like with these datetime formats, I hardly ever remember these, so I always need to look them up in the documentation. So I've got this pulled up in the Pandas documentation here for these date offsets, and I will leave a link to this page in the description section below as well, if you all would like to try out some of these. But we can see we have hour, minute, second, milliseconds, microseconds, all kinds of things. If you're doing finances, you can do, quarterly and things like that. So I wanna do this on a daily basis, so I'm gonna put a d there"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". If you're doing finances, you can do, quarterly and things like that. So I wanna do this on a daily basis, so I'm gonna put a d there. And now we have to tell it, okay, well, what do we want to, do with these resamplings? If I'm looking at entire days here, so if I take, this entire day of 1st, what do I want to do with this high value? And we're just saying, well, we want the max value for each of those days. So if I run this, then we can see that that gives us a series with all of the high values for each day. So now let's save this series here as a new variable and look up the specific date that we used before. So I'm gonna save this as a variable and call that highs, and then let's access that specific date of 2020, 0101, for the highs. Now what we should get here, since we're using the same date that we did here, we should get this value of 132 point 68. So if I run that, then we can see that the high for that day, was in fact, equal to what we did here. So that works"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So if I run that, then we can see that the high for that day, was in fact, equal to what we did here. So that works. But now instead of just getting one day at a time like we did here, now that we've resampled this, now we have those high values for, every single day in our data. Okay. So why would something like this be useful? I mean, you know, that might be useful just because it's interesting, but there are other things that we can do as well. So let's say that maybe we wanted to plot this out. But instead of, you know, viewing a plot that had these prices broken down hour by hour, now we can just do a plot for the total price broken down by day. So within Jupyter Notebooks, it's extremely easy to plot out information. I'm actually going to do an entire series on plotting with pandas, so I'm not going to go into a ton of details in this video, but we will see how we can do a you know, very simple line plot here"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". I'm actually going to do an entire series on plotting with pandas, so I'm not going to go into a ton of details in this video, but we will see how we can do a you know, very simple line plot here. So to do this, we first need to use this special line within Jupyter Notebooks that allows our plots to display within the browser. So all we have to do is say this is a percent sign here then we can say matplotlib inline. Now one thing that I do want to mention here is that I did have go and install matplotlib in the, virtual environment that I'm using. So if you've only installed, you know, pandas or and that's it, then you might want to go back and install matplotlib, or else you will get an import error here. But I went and installed that in my, virtual environment, so we can see that that worked there. And with that one line of code there, now we can display plots directly within our Jupyter notebook"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". But I went and installed that in my, virtual environment, so we can see that that worked there. And with that one line of code there, now we can display plots directly within our Jupyter notebook. So I can simply run the plot method on this data frame variable that was resampled and get a plot of that. So I'm just gonna say, okay, I want highs plotted out. So highs dot plot. I'll run that, and we can see that we get a nice, matplotlib plot here. Okay, so that's pretty nice for, you know, just a few lines of code there. Now one thing that you might be wondering is if it's possible to resample multiple columns at once. And we can do that by running the resample method on our entire data frame instead of 1 a single series. So for example, what do I mean by this? Okay. So, whenever I say, you know, resample multiple columns at once, I mean that what if we wanted to resample this by day, but so far we've only seen, okay, how we got the high value. But what if we said, okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". But what if we said, okay. Well, I wanna resample this by day, but I also want, you know, the average, closing cost of that entire day. I want the sum of all of these volumes for that entire day. And then I want the, you know, the max high value, and I want the min low value. So the way that we've done that down here, where we just access that single column, we wouldn't be able to do it using this method that we did here. So in order to resample and use multiple columns like that, here's how we can do this. So we can do this by running the resample method on our entire data frame. So if you want to use the same aggregation method on all of your columns so for example, let's say, df dot resample. So now we're resampling our entire DataFrame object here, and now we're gonna pass in what we wanna resample on. Instead of day, let's change it up and do week. Now we'll resample by the each week"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So now we're resampling our entire DataFrame object here, and now we're gonna pass in what we wanna resample on. Instead of day, let's change it up and do week. Now we'll resample by the each week. So if you want to use the same aggregation method on everything, then you can just put in that aggregation method there. So if I run this, then this is gonna give me the mean values for each of our columns on a weekly basis. Now this is cool that we can do this, and sometimes you might wanna do something like this. But in this instance, it doesn't really make sense to use mean to get the average of all of our columns. So for example, there's no real reason to get, you know, the average volume per hour or something like that. You probably wanna get the sum for the, you know, entire time period"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So for example, there's no real reason to get, you know, the average volume per hour or something like that. You probably wanna get the sum for the, you know, entire time period. Or for our high and low values here, these are giving us the average highs and the average lows, but the point of a high and low value is to know the high for that time period and the low for that time period. So we probably don't want mean here either. So how can we resample this, to where we can, you know, resample and use multiple columns, but also use multiple aggregation methods? Now we've actually seen this in previous videos and use this method, but what we want to use here is the agg, the agg method. And the agg method also accepts a map of columns and the aggregation functions that we want to run on that column. So for example, let's do this with the values for, let's see. We'll do the closing column, we'll do the high and low columns, and then we'll also do the volume here"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So for example, let's do this with the values for, let's see. We'll do the closing column, we'll do the high and low columns, and then we'll also do the volume here. So I'm going to grab this from up here, and then we'll do df. Resample, and we'll pass in a w for a weekly basis. And now instead of passing in dot mean, like we did up here, I'm going to pass in dotagg. And now I can pass in a dictionary of the columns and, or the column names, and then the values will be the aggregation function that we want to use on that column. So for example, let's say that for the closing value, I do want to grab the mean of that, and then I'll say for the high column, I want to use the max, aggregation function for that since we want the max value. For the low column, I want to get the min. And for volume, I'll go ahead and just sum up, all of the volume for that entire time period. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". For the low column, I want to get the min. And for volume, I'll go ahead and just sum up, all of the volume for that entire time period. Okay. So, again, the keys here for this dictionary that we passed in the ag, the ag method, this is the, column name here, then this is the aggregation function. So we're taking the mean of close, we're taking the max for this entire weekly period here, for the highs, the min for the low, and then sum for volume. So if we run this, then it gives us this nice weekly overview of the, you know, the weekly highs and the weekly lows here and also the average, closing costs here, and we also have the summation of the volume of trades. So, you know, this really touches on what we can do with date times and time series data in Pandas"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So, you know, this really touches on what we can do with date times and time series data in Pandas. Like I said a little bit ago, I do plan on doing a full series on pandas plotting where we'll cover more advanced topics, you know, such as plotting, plotting things out and having rolling averages for data and things like that. Now before we do end here, I do wanna thank the sponsor of this video, and that is Brilliant. And I really enjoy the tutorials that Brilliant provides and would definitely recommend checking them out. So in this series, we've been learning about Pandas and how to analyze data in Python, and Brilliant would be an excellent way to supplement what you learn here with their hands on courses. They have some excellent courses and lessons that do a deep dive on how to think about and analyze data correctly"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". They have some excellent courses and lessons that do a deep dive on how to think about and analyze data correctly. For data analysis fundamentals, I would really recommend checking out their statistics course, which shows you how to analyze graphs and determine significance in the data. And I would also recommend their machine learning course, which takes data analysis to a new level where you'll learn about the techniques being used that allow machines to make decisions where there's just too many variables for a human to consider. So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/cms to sign up for free. And also, the first 200 people that go to that link will get 20% off the annual premium subscription, and you can find that link in the description section below. Again, that's brilliant.orgforward/cms. Okay. So I think that's gonna do it for this Pandas video"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". Again, that's brilliant.orgforward/cms. Okay. So I think that's gonna do it for this Pandas video. I hope you feel like you got a good idea for how to work with date and time series data within Pandas. And like I said, there's a lot more that we can cover with datetime data, but I feel like what we did here should definitely provide you with the basics of being able to convert, analyze, and resample your data so that you can do the exact analysis that you need. Now in the next video, we're going to be learning how to read data in Pandas from different sources. So far in this series, we've only covered, CSV files, but we're going to learn how to read in data from Excel, from websites, SQL databases, and a few more. So be sure to stick around for that. But if anyone has any questions about what will be covered in this video, feel free to ask in the comments section below, and I'll do my best to answer those"
    },
    {
        "title": "Python Pandas Tutorial (Part 10): Working with Dates and Time Series Data",
        "text": ". So be sure to stick around for that. But if anyone has any questions about what will be covered in this video, feel free to ask in the comments section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up, and also it's a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute to Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": "Hey there. How's it going everybody? In this series of videos, we're gonna be learning how to use the matplotlib library in Python. So matplotlib is a plotting library for Python that allows us to create some great looking graphs from our data. So this is used a ton in the data science field and also in applications where we need to visualize our data. So I have the Matplotlib website open here, and we can see on their example page that you can make some really nice visualizations using Matplotlib. And we'll be learning how to do several of these in this series. So in this video, we're gonna be going over the basics of matplotlib and start out with an easy line plot. We'll also learn how to customize the plot style and labels to the axis, add a title, create a legend, and things like that. Now I'd also like to mention that we do have a sponsor for this series of videos and that is brilliant.org"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". Now I'd also like to mention that we do have a sponsor for this series of videos and that is brilliant.org. So I really wanna thank Brilliant for sponsoring this series, and it would be great if you all could check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay. So first, we need to install matplotlib. So we can do this easily using pip. So I'm going to open my terminal here. And we can simply install this with a PIP install. Now I have a virtual environment activated. You don't need to be using a virtual environment. But in my opinion, it's always a good idea to create a new environment for when you're starting new projects, even if we're just testing stuff out. Now if you don't know how to create virtual environments, then I'll leave a link to my video explaining those in the description section below. Okay"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". Now if you don't know how to create virtual environments, then I'll leave a link to my video explaining those in the description section below. Okay. So to install Matplotlib, we can simply say pip install and that is matplotlib. So let's install that. And once we have this installed, then we're gonna go, learn how to create a simple plot. So I'm using Sublime Text for these videos. So I'm going to open up Sublime here. And I just have a new folder here called matplotlib, and I'm currently within this MPL demo, dotpy file here. Now it's also very popular to use Jupyter Notebooks when working with data because you can run specific cells at a time, and also you can see your visualizations in line. But some people find it difficult to get up and running with Jupyter Notebooks, so I'm just gonna use a regular editor since more people are probably probably familiar with this. But if you're using Jupyter, then you should be able to follow along just fine"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". But if you're using Jupyter, then you should be able to follow along just fine. Then, if you'd like to learn how to use Jupyter notebooks, then I do have a separate video specifically on that. So I'll be sure to leave a link to that video in the description section below as well, if anyone is interested. Okay. So let's create some simple plots to get us started out. So first, I'm gonna import pyplot from the matplotlib module. So I'm gonna say from matplotlib, and we want to import pyplot. And I'm going to import this as plt. That's a common convention there to just import that as PLT so that we don't have to write out pyplot every time we wanna use that. And now let's create some sample data that we wanna plot. So in this video, we're gonna add our own data here within Python, and in the next video, we'll see how to read in data from an external source like a CSV file. So I'm gonna use some data that I grabbed from the annual Stack Overflow developer survey"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So I'm gonna use some data that I grabbed from the annual Stack Overflow developer survey. They actually just released the 2019 data publicly the day that I was putting this video together, so it was good timing on that part. So the data that I'm gonna be using from that survey is the median salary for a developer based on their age. And this is data that I parsed out of the results myself. So I'll be sure to leave a link to my data files here in the description section below, for those of you who'd like to follow along. Also, I'm gonna make a video in the near future showing how I cleaned and parsed out that data out of their results. But for now, let's just continue on with plotting this. So first, I'm going to create a list and I'm gonna call this dev underscore x, And this will be the values for the x axis on the plot, and these will be age ranges. Now I'm a pretty slow typer sometimes, so I'm gonna use some snippets here"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". Now I'm a pretty slow typer sometimes, so I'm gonna use some snippets here. And, again, I'm gonna post the, link to these snippets in the description section below if anyone wants to grab these themselves. So I'm just going to grab these from my snippets here just so I don't have to type all these out. So I'm gonna grab those and paste those in, and this is just a list here from 25 to 35. Now in the actual survey, they did actually have all of the ages included, but I didn't wanna crowd the screen with data right off the bat. So we're just gonna work with a subset of the ages between 2535 for now. But if you stick around to the end of the video, then we'll plot out the median salaries for all of the ages, that had enough data. Okay. So now I'm gonna create a list, I'm gonna call this dev y. And this will be the values of our y axis on the plot. And these will be the median salaries for the ages that we added into our other list here. So let me also grab these from my snippets file"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". And this will be the values of our y axis on the plot. And these will be the median salaries for the ages that we added into our other list here. So let me also grab these from my snippets file. So I'm gonna grab those and paste those in. Okay. So now that we have a list of values that we want for our x axis here as dev x and a list of values that we want for our y axis here as dev y, so now let's plot this. So to plot this data, it's as easy as simply saying plt.plot. And first, we wanna pass in, what would the data for our x axis, which is gonna be devx, and then the data for our y axis, which is devy. Now if you've ever looked at the Matplotlib documentation or looked at other examples of people creating plots, then you may have seen them create plots by creating figures and axes and subplots and all kinds of other stuff. And we are gonna look at that further on in the series, but we're gonna keep it simple now and just use what we have here with plt.plot"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". And we are gonna look at that further on in the series, but we're gonna keep it simple now and just use what we have here with plt.plot. So this is going to allow us to work with a single plot, which is perfect for the data that we have right now. So if we were to run this right now, it's not actually gonna show us the plot. If we want the plot to show, then we have to say plt.show. And now if we run this, then we can see that we get a very basic plot here. So what this plotted out is a basic plot where we have our ages down here on the x axis, so between 2535, and those median salaries in that other list are on the y axis here. So this does make sense to me. It looks like the salaries typically get higher as you get older. So Matplotlib comes built in with some nice features, and we can see that this window here has some controls and options down here at the bottom left. So let's go ahead and take a look at some of these"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So let's go ahead and take a look at some of these. So first, we have, a pan to where we can pan around if we want to see anything in particular. We also have a zoom. So if we click on the magnifying glass and we wanna zoom in on, you know, 26 to 28, then we can do that and then pan around from there. We have the arrows here, and I think these are undo and redo. So if I hit back, then that should take me back to what we did before, and this resumes and things like that. And, finally, we have, home here. And, also, we have this, which is just more finely detailed zoom configurations here. I hardly ever use that. I usually just use the pan and zoom here. And, lastly, we can save this. So if I, wanted to save this as a PNG, then I could click that and save this plot as a PNG file. So that's a quick little overview of this window here. Okay. So now let me close this down. And now let's look at how to add some more information to our plot"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So that's a quick little overview of this window here. Okay. So now let me close this down. And now let's look at how to add some more information to our plot. So right now, there's no way to actually tell what that data represents. If we were to send this to somebody or if we were to look at this ourselves, then no one would actually know what that x and that y axis were, supposed to be. There's no labels or anything like that. Now the point of these plots is to visualize the data in the easiest to digest format as possible and relay the information that could just get hidden in the numbers. So we need to have some labels here to show what this actually represents. So first, let's give our entire plot a title. So to do this, I'm gonna do this right above plot dot show. I'm going to say plt dot title and let's pass in a title of median salary and then I'll say that the salary is in USD by age"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So to do this, I'm gonna do this right above plot dot show. I'm going to say plt dot title and let's pass in a title of median salary and then I'll say that the salary is in USD by age. Okay? And now to label our x and y axis, it's as easy as saying pltdot xlabel, and we want our x label to be ages. And right below that, I'm going to say plt dot, whoops, y label, and that y label, let's say median salary, and again, we will specify USD. Okay. So now if we run what we have here, then now our plot is a little bit more detailed. So now we have some more useful information here. So we have a plot title up here at the, top that tells us what this chart is about, and our x and our y axis now have labels explaining those as well. Okay. So now let's add another line to our plot. So let's say that I wanted to also plot the median salaries by age for Python developers specifically. So the values that we have right now are for developers of any language. So now let's do Python"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So let's say that I wanted to also plot the median salaries by age for Python developers specifically. So the values that we have right now are for developers of any language. So now let's do Python. So to do this, we can sim simply create more lists and plot just, like we did the first ones here. So let me close this down. So I grabbed that data from the Stack Overflow survey as well, and I added those to my snippets also. So let me grab those from the snippets, and those are right here, median Python developer salaries by age. So So I'm going to grab this pydevx and this pydevy. So I'm going to go back to my script here and right below my other data, right below where I'm running plt.plot of that other data, I'm going to paste this PYDev data in. And now I can plot those simply by saying plt.plot. And now we want to pass in PIDevx, and we want to pass in PIDevy. Let me get some spacing there. So now, if I were to actually run this right now, then that would work"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ".plot. And now we want to pass in PIDevx, and we want to pass in PIDevy. Let me get some spacing there. So now, if I were to actually run this right now, then that would work. But before I do that, if we look at our x axis here, then we are just repeating those same age ranges, from the other list. So we have 25 to 35. So instead of repeating these in both of our plots, let's just rename our x values at the top here and use that for both plots. So instead of dev x and py dev x, I'm going to just remove that py dev x there. And now this x list here at the top, I'm going to rename this to ages_x, ages underscore x. And now I'm going to use that for both plots. So I'm going to use it in my first plot there and replace dev x, and in the second plot, I'm going to replace that PIDev x. So now we're using this same data for our x axis, and the y axis we are plotting different data"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So now we're using this same data for our x axis, and the y axis we are plotting different data. So like I said, we could have had that repeated list in there and it would have worked just fine, but this is just a way of cutting down on repeated code. Okay. So now if we run this let me go ahead and make that output little smaller there since we're not using that. So now if I run this, then we can see that now we are getting 2 lines. So that's nice. But we don't know which line is which. So we need to add a legend to tell us which line represents what data. So let me close this plot here. And there are 2 ways of adding legends. So the first way is to do it like this. I could add labels for the legend as a list of values in order, in the order that they were added to the plot. So down here at the bottom whoops. Down here at the bottom actually, let me actually put this below the title here"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So down here at the bottom whoops. Down here at the bottom actually, let me actually put this below the title here. So I could say plt dot legend, And now we can pass in a list of values in the order that they were added to the plot. So our, all of our developers, this dev y, was added to our plot first where we did plt.plot, and the Python developers was added second. So plt.plot here with pydev y. So I could pass in a list and just say alldevs is the first value and Python is the second value. And if I run this, then we can see that that works. We, get a plot and the legend is telling us which line is which here. But there's a way that I actually like to do legends, that I really think is better than this. So let me close down this plot here. Now I don't really like this method of adding legends because you have to know the order that all of these things were added to the plot, and I feel like that's extremely error prone. So I think that this is a better way to do it"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So I think that this is a better way to do it. So we can pass a label argument to our plot methods. So instead, let me copy this part here where I said all devs. Instead, up here where we did our first plot, I can pass in a label argument and say label is equal to all devs for that one. And for the second plot, I can say label is equal to, and this will be Python. And now when we actually run this legend, method here, we can actually do that without any arguments. So I'm just gonna leave that empty. And now it's just gonna use these plot labels instead. So now if I run this, then we can see that that works. But I feel like this is a lot, less error prone and easier to read, and it also kind of self documents our code as well. If we look back here at the code, then we can see that this is self documenting in a way where it's telling us what we're actually plotting here. So I think that that's a much better way to do it. Okay"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So I think that that's a much better way to do it. Okay. So now that we have those plotted, let's look a bit at how we can change some of the formatting of this plot. So let's say that I wanted some different colors and styles for the lines and things like that. I feel like since one line is just developers in general, I'm just gonna make that line gray, and we'll make the Python line blue since that's one of the main colors in in the Python logo. Now there's a way to pass all of this information in all at once, but I hardly ever do it this way, just because I think it's hard to read. So I'll show you a quick example just in case you see this in someone else's code, but then I'll show you how I normally do it as well. So we could pass in all of the information at once by passing in a format string after our y values in our plot method. So let me pull up a web page here and show you what this format string actually expects. So whoops"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So let me pull up a web page here and show you what this format string actually expects. So whoops. And I did have it pulled up here, but I may have, overwritten it here. Let me see. Okay. Here we are. Format strings. And let me make this just a little bit larger here so that everybody can see. So we can see here that it says that a format string consists of a part for color, marker, and a line. So format string looks like this. Marker, line, color. So let's say that for our line graph, we wanted a black dash line. So to do that, we can scroll down here. These are the marker styles. We're not using markers right now, we're using lines. So I'm gonna go down to the line styles. So we can see that just a single dash here is a solid line style. A dash dash is a dash line style, so that's what I'm gonna use, but then they also have a couple of others here. Now let's also look at the colors here. So these are the general colors. So b is blue. So if I want a black, then that is k"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". Now let's also look at the colors here. So these are the general colors. So b is blue. So if I want a black, then that is k. So if I go back up to our format string here, then it says that, let's see here. Yeah. So if I go up here, yeah. So color marker line. Okay. So now let's go back to our code here. And now let's pass in a format string after our y value. So I'm going to say that I want this one to be black so that was k, and then dash dash is the dash line. So for Python, if I wanted this one to be blue, then I could just pass in a b for blue, and then I'll leave everything else as the default. Since, a solid line is the default, we don't have to change anything there. So now if I save that and run it, then we can see that now our line with all of our developers is this dashed black line here and our Python line is this blue line. So we're able to, change that up a little bit"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So we're able to, change that up a little bit. Now like I said, I've never really liked these format strings that contain, the colors and the marker styles and the line styles all in one because I don't feel like that's very readable. I always forget, how to write these down and what these are supposed to be. So I just wanted to show you these in case you saw them in someone else's code, but I prefer to be more explicit and make our code a bit more readable. So to do that, we can pass these in as arguments instead. So instead of doing it this way, I'm going to say that color is equal to k, and then I will say line style is equal to dash dash. Now that's a little harder or that's a little more code there, but I think that that is much easier to read. So also down here in the Python plot, I'm gonna say color is equal to b, so for blue, and that should work exactly the same as our format string worked. But in my opinion, it's just more obvious what's going on there"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". But in my opinion, it's just more obvious what's going on there. So if we run that, then we can see that we get the exact same results there. Now if you also wanted to add markers to your lines, then we can do that as well. To do that, we could simply say so after line style here, I'm gonna say marker is equal to. And if you wanna know what marker styles you can use, you can go back to that formatting page where I showed all those different, formatting options. But I know that some of these, off the top of my head, I know that, the dot is 1. And let me also put one in here for Python as well. And I know that circle will do like a larger marker there. So now if I save that and run it, then we can see that now, these have markers here. So we have these small markers for all developers and these bigger markers for Python. And I'll be sure to add a link in the description section below to that formatting page in case you wanna check out more options that you have here"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". And I'll be sure to add a link in the description section below to that formatting page in case you wanna check out more options that you have here. Now I don't really like these markers on this specific chart, so I'm gonna go ahead and go back and just undo a couple of steps here before we put those markers in. Okay. So we can also use hex color values for our lines as well. And that's normally what I use since you have a lot more color options, and it's easier to find color pilots online that, look good and contain those hex values. So I have some written down here that I'm going to use for our plots. So for the developer's line, I'm just gonna use a hex value here. So for color, I'm just gonna use a hex value of 444444. And if you don't know how hex values work, the first pair of numbers are gonna be for the red values. The next two numbers are gonna be for the green values, and the last two numbers are gonna be for the blue values"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". The next two numbers are gonna be for the green values, and the last two numbers are gonna be for the blue values. So with all those being the same, it's going to generate a shade of gray, And this is a darker shade of gray. And you can find hex color palettes online if you would like to come up with some of your own. Now for Python, I'm going to set this to this still blue color that I found online. So I'm going to change this to be a hex value of 5a7d9a. And just to show one more line of information and colors here, let me also add in some JavaScript data that I have here in my snippets as well. So So I'm gonna go back to the snippets, and now since we're sharing the x, we can just copy the y values that I want here. So I'm going to copy these y values, and these are the median JavaScript developer salaries by age. And underneath our Python data, I'm going to paste that in, and let me actually get this, plotting data here beside what it's actually plotting there. Okay"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". And underneath our Python data, I'm going to paste that in, and let me actually get this, plotting data here beside what it's actually plotting there. Okay. And now let me copy the Python line here, and I'm just going to use that for my JavaScript data. But instead of plotting the py dev y, I'm gonna plot the j s dev y. For the color, I'm gonna change this to a yellowish color. So this will be a d a d three b. And for the label, I'm gonna say JavaScript. Okay? So if we run this, then we can see that now we get three lines here on our plot. All of them, have labels and legends, and they all have their own customized colors and styles as well. So that looks pretty good. Now I'm not sure why the Python developers in the survey are reporting higher salaries like this. I didn't expect it to be that much of a difference between, you know, the different types of developers, but that's just what was in the data. Now I feel like these lines are a little bit thin right now"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". Now I feel like these lines are a little bit thin right now. So let's say that we wanted, the lines for the specific languages to be a little bit wider so that they're more emphasized and just keep general developers as it is. So to do that, we can add another argument to both of our, plot methods here. And to make these lines a little thicker, I can just say line width is equal to, and I think the default is 1, so let's try 3 and see what this looks like. So I'll do that with both Python and JavaScript, and I'm gonna leave, the all developers as it is. Now this could actually cover up our dotted line because lines are layered in the order that they're added. So instead, I'm going to move our dotted line to the bottom here. So I'm going to grab this plot and grab this data, and I'm gonna move that to the bottom so that it's plotted on top, just in case it would have been hidden behind any of those other two lines"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So I'm going to grab this plot and grab this data, and I'm gonna move that to the bottom so that it's plotted on top, just in case it would have been hidden behind any of those other two lines. So do you remember earlier when we changed our legend to use these labels instead of passing them directly into our legend method? Well, this is why that was a good idea, Because moving the plotting order like we did just now, would have meant that we needed to manually come down here and change the order that we passed in those legends also. And if we forgot that, then our plot would just be wrong. But since we did it this way by using these labels instead, that just updates automatically. So that's why I prefer that method. So let's go ahead and run what we have here. And we can see that now our language lines are a bit thicker, but we can still see that, all developers line over top of the JavaScript line here where it would have been hidden behind. Okay. So that looks pretty good"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". Okay. So that looks pretty good. Now I'm on a larger monitor here, but whenever I was running this on my laptop, I noticed some weird padding issues. If you ever notice that your padding isn't very good and that stuff is getting cut off, then there's a way that we can take care of that. And let me go back to the code here. And to take care of that, I'm just gonna do this right above, plt.show. To do this, I'm gonna add in a line that automatically adjusts our plot parameters to give some padding. And to do this, it is just plt dot tight_layout, and that is a method. So if I run this now, then it kinda looks the same on my machine, but on my laptop, it made the padding a lot better whenever I ran that. Now there's one more thing about the plot that I think that we could improve here. Now if we look at this, if we go out here further to the right, it might be harder to tell when we cross certain salaries. So if we put in a grid, then I think it would make this a lot easier to read"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So if we put in a grid, then I think it would make this a lot easier to read. So if we go back to our code, we can put in a grid really easily, just by saying, and I'll just do this above where we currently are. I'll just say plt.grid, and we just have to pass in a value of true. So if we run that, then now we can see we have a grid. So we can tell exactly when each of these lines crosses certain salaries and ages here. Okay. So that's looking pretty good. Now one more thing before we finish, let's look at how we can change the style of our plots and make these look a bit better. Now we have some built in styles that we can use with matplotlib. So let me go to the top of our file here and let's use some of these here. So underneath our imports, I'm gonna say plt dot style. And to see the available styles that we can, use, we can access a list of available styles by saying plt.style. Available. Now that's not a method, so you don't want to put in parentheses there"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". And to see the available styles that we can, use, we can access a list of available styles by saying plt.style. Available. Now that's not a method, so you don't want to put in parentheses there. It's just an attribute, so don't execute that. So now let's print that out to see what styles we have available. And I'm going to comment out our plt.show so that a plot doesn't show up when we run this. So I'm gonna run this, and I'm gonna make our output a little bigger here so that we can see these. And these are the available styles that we can use that are built in to Matplotlib. And you can experiment around with these and see which ones you like. Personally, I really like the 538 style, and I also like the, seaborne and the ggplot styles. And I'll probably use a, you know, few of those throughout the series just so we can get an idea of what some of these different styles looks like. So let's say that I wanted to use the 538 style"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". And I'll probably use a, you know, few of those throughout the series just so we can get an idea of what some of these different styles looks like. So let's say that I wanted to use the 538 style. So to do this, I could simply say I'm gonna overwrite our print statement here. I'm gonna say plt dot style dot use and then pass in the string of 538. So now let me uncomment out plt.show, and let me run this. So when I run this, I don't know if you remembered what that looked like before, but now this is a bit of a different style. And these styles all have their own unique way of coloring lines and stuff like that too. So you could also try try plotting these without your custom colors and see if you like the styles default colors more than the ones that we specifically added for our lines. So I'm actually gonna try that. I'm gonna remove my colors and line widths for Python and JavaScript plots, and I'll just leave the all devs plot as it is"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So I'm actually gonna try that. I'm gonna remove my colors and line widths for Python and JavaScript plots, and I'll just leave the all devs plot as it is. So for Python and JavaScript, I'm going to remove the line width and I'm gonna remove the color. And I'll do that for JavaScript as well. And let me make this output a little smaller here. And I'm also gonna remove the grid as well since some of these styles also have their own grid preferences Okay. So now with all those in place, first, let me comment out where I'm using the style and run that plot. So that is the default matplotlib, style. And now let me plot with the 538. So if I look at both of these, then you can see the difference here. There is a, definitely a different style with the 538 plot over here. And I really like the 538 default colors and styles here. Now if you wanna play around with the different styles, then it's as easy as choosing another one from the list that we printed out just a second ago"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". Now if you wanna play around with the different styles, then it's as easy as choosing another one from the list that we printed out just a second ago. So if I wanted to try a ggplotstyleinstead, then I could just say dot useggplot. If I run that, then we can see that now we get a different looking style. And this one kind of has like a grayish background, with some thinner lines here. Now speaking of styles, let me show you something else that I think is pretty cool that's built in the Matplotlib. And it's nice if you have like a blog or something where you're making some plots and wanna have a little bit of fun with it. Now most of you have probably heard of xkcd comics. They publish some online comics that are usually pretty funny, and a lot of those are tech related also"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". Now most of you have probably heard of xkcd comics. They publish some online comics that are usually pretty funny, and a lot of those are tech related also. For those of you that have watched my videos in the past, then you might know that the Python has a standard library module called antigravity, and it actually opens up a standard library module called anti gravity, and it actually opens up one of their comics in the browser. Anyways, they have a pretty distinct style with their comics, And matplotlib actually has a method that will mimic the style of their comics, and it's super easy to use. So in order to use that, all we'd have to do, I'm gonna overwrite, this style line here. Now this is actually a method instead of a style. So this will be plt.xkcd, and that is a method. And with that small change in place, if I run this and make this a little larger, then now you can see that this is kind of in the style of those xkcd comics"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ".xkcd, and that is a method. And with that small change in place, if I run this and make this a little larger, then now you can see that this is kind of in the style of those xkcd comics. So it kinda looks like a graph that you would see, embedded in a comic somewhere. It's kinda got these squiggly lines here that kinda makes it look like it was hand drawn by somebody. So I think that's a pretty cool built in feature that matplotlib has, and it's a fun way to mix up your plots if you're making them for something that isn't too serious. So if you wanted to actually put this on your website or something, then, you could just save this as a PNG, like we saw before, and then upload it that way. Now we saw how to do that here within the window, but we can also do this programmatically as well. So if I close this plot here, if we go back to the code, I'm just going to save this, right here before plt.show. In order to save this as a a png, then we can simply say plt"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So if I close this plot here, if we go back to the code, I'm just going to save this, right here before plt.show. In order to save this as a a png, then we can simply say plt.savefig, and now I'm going to, just save that as plot dot PNG or something like that, and that will save an image called plot dot PNG to my current directory. Now if I wanted to save it somewhere else, then you can also, pass in a full path here as well, and it'll save it to whatever path you pass in. So I'm going to run this and it's gonna show that graph there. But if I open up my current directory, we can see that I have a plot dot png here and if I open that, then we can see that it saved that png file here in my directory. Okay. So real quick, let me do one more thing before we finish up here. So I mentioned towards the beginning of the video that I'd, plot the data for ages of 18 to 55. That's the larger set of data that they had in the survey, if anyone was interested in seeing that"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So I mentioned towards the beginning of the video that I'd, plot the data for ages of 18 to 55. That's the larger set of data that they had in the survey, if anyone was interested in seeing that. Now I didn't do it earlier because I didn't wanna crowd the screen with tons of data, but let me grab that from my snippets file and see what this looks like. So here within the snippets, these are all of the ages that had enough data here. They had more data, ages than this, but these were the only ones that had, I think it was like over a 100 answers to the, question or something like that. I can't remember exactly the the, the cutoff that I used there, but it was something like that. There were some people who, you know, in their 8 or eighties nineties that answered the survey, but there were so few of them that it was hard to get a, a mean that was trustworthy. So, these are the ones that had, you know, hundreds of answers. So, lastly, let me grab this last list here"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So, these are the ones that had, you know, hundreds of answers. So, lastly, let me grab this last list here. This will be the last one that I need to replace. And, again, these will be available for download on my GitHub page if anybody else wants to follow along. So now that we have all that data, copied and pasted into our script, now let me save that and run it. And now this is the data for, all of those ages, and the median salaries. So it looks like that big gap between Python developers and other developers was mainly between the ages of 2535. That's what we saw here. And once we plot the rest of these, then they're a bit more in line. The other languages catch up around in here, and Python doesn't have such a big gap anymore. But it still looks like Python, it does have, the leverage here in most of these ages though. Okay. So before we end here, I'd like to also mention the sponsor of this video, and that is brilliant.org"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". Okay. So before we end here, I'd like to also mention the sponsor of this video, and that is brilliant.org. So in this series, we've been learning about mat plotlib and how to plot data in Python, and Brilliant would be an excellent way to supplement what you learn here with their hands on courses. They have some excellent courses covering the fundamentals of statistics, and these lessons do a deep dive on how to think about and analyze data correctly. They even use Python in their statistics courses and will quiz you on how to correctly analyze the data within the language. Their guided lessons will challenge you, but you also have the ability to get hints or even solutions if you need them. It's really tailored towards understanding the material. They've also recently released a programming with Python course, and they even have a coding environment built into their website so that you can run code directly in the browser"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". They've also recently released a programming with Python course, and they even have a coding environment built into their website so that you can run code directly in the browser. And that is a great way to compliment watching my tutorials because you can apply what you've learned in their active problem solving environment, and that helps to solidify that knowledge. So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/cms to sign up for free. And, also, the first 200 people that go to that link will get 20% off the annual premium subscription, and you can find that link in the description section below. Again, that's brilliant.orgforward/ cms. Okay. So I think that is gonna do it for our first Matplotlib video. I hope you feel like you got a good introduction for how to create some simple plots in Python and also how to customize these in different ways"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". I hope you feel like you got a good introduction for how to create some simple plots in Python and also how to customize these in different ways. In the next videos in this series, we're gonna be learning how to create all kinds of different plots. So we're gonna learn how to create bar charts, pie charts, scatter plots, histograms, stack plots. We're gonna be plotting time series data and things like that. We're also gonna learn how to create multiple subplots in case you wanna plot more than one thing at a time. So in the next video, we're gonna be learning how to create bar charts, and we're also gonna learn how to load in data from a CSV instead of having the data directly in our Python scripts like we did here. So be sure to stick around for that. But if anyone has any questions about what we covered in this video, then feel free to ask in the comment section below, and I'll do my best to answer those"
    },
    {
        "title": "Matplotlib Tutorial (Part 1): Creating and Customizing Our First Plots",
        "text": ". So be sure to stick around for that. But if anyone has any questions about what we covered in this video, then feel free to ask in the comment section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up. And also, it's a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute to Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": "Hey there. How's it going everybody? In this video, we're gonna be learning more about indexes. So we've seen basic default indexes in previous videos, but in this video, we'll learn how to set custom indexes and the benefits of doing this. Now I'd also like to mention that we do have a sponsor for this series of videos and that is brilliant.org. So I really wanna thank Brilliant for sponsoring this series, and it would be great if you all could check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay. So I have my snippets file open here, or my snippets notebook open here so that we can look at indexes using a simple data frame with a little bit of data, and then we'll see how to use these with our larger survey dataset that we have been using so far in the series"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". So in these snippets, we have the same small data frame that we saw in the last video where we just have 3 people with their first name, last name, and email address. And I have this data frame displayed, down here at the bottom right here. So like I said in previous videos, our data frames have this thing on the far left over here that looks like a column without a name, and this is an index. So since we've, just seen these default indexes so far, this is currently just a range of numbers that's basically an integer identifier for the rows. So this is a 0, a 1, and a 2. Now sometimes it might make more sense to have a different identifier for each row, and that will basically be the label for that row. So it's usually unique. Now, Pandas doesn't actually enforce indexes being unique, and sometimes it won't be, but most of the time these will be unique values"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". So it's usually unique. Now, Pandas doesn't actually enforce indexes being unique, and sometimes it won't be, but most of the time these will be unique values. So what might be a better index for our sample data here? Well, maybe the email address would be a good index for this data since that's usually a unique value for most people. So right now, if I wanted to view all of the email addresses, then we could say df and access the email column. And we saw this in the last video, but we can see that it displays all of these email addresses. Now what if we wanted to set these email addresses as the index for this DataFrame? Well to do that, we could just say df dot set underscore index and then we can just pass in the name of the column that we want for the index. So if I run this, then now we can see that the email is on the far left and it's bold. And it actually, does kind of look like a normal column because this index has a name. It has the same name as our column when we set it"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". And it actually, does kind of look like a normal column because this index has a name. It has the same name as our column when we set it. So I want to show you something here. We can just set this index in this cell, but if I look at my data frame again, so underneath here, if I say df to print out this data frame, then we can see that our data frame didn't actually change. It still has the default index over here on the left. And that's because Pandas doesn't, do a lot of these changes, in place unless we specifically tell it to do so. And this is actually nice because it allows us to experiment without worrying about modifying our data frame in unexpected ways. So let's say that we actually did wanna set our index to the email column and have those changes carry over into these future cells. So to do this, back up here where we said set index, we can just add in another argument here and say in place is equal to true"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". So to do this, back up here where we said set index, we can just add in another argument here and say in place is equal to true. Now if I run that and then re run the data frame again, then now we can see that it actually did set that index, and modified that data frame. And we can actually, look specifically at that index just by saying df dot index. And if I run that, then we can see that we have an index here and it has the values as a list of what all the index values are, and it also tells us that the name is equal to email. Okay. So why would this actually be useful? Well, like I said before, the email address as the index gives us a nice unique identifier for our row. And remember in the previous video that we used dot loc to search our data frame by label. Well, these indexes are the labels for these rows. So before, we just used the default ranged index, but now we can find a specific row, by passing in that label"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". Well, these indexes are the labels for these rows. So before, we just used the default ranged index, but now we can find a specific row, by passing in that label. So if I say df dot loc this will be easier if we actually just look at an example here. If I say df dot loc, before, we were passing in a 0 as the label. But now I can say, okay, I wanna see the information for coreymshafer atgmail.com. And then it'll come back and say, okay, that, person has a first name of Corey, last name of Shaffer, and so on. So now we get the row for that specific email index. And like we saw in the last video, we can still pass in values for the specific columns as well. So if we wanted the last name, then I could just pass that in as the second value. So I'll just say I want the last name, and we can see that there we get Schaeffer. Now we actually no longer have those default integers as our index because now it's using the email"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". So I'll just say I want the last name, and we can see that there we get Schaeffer. Now we actually no longer have those default integers as our index because now it's using the email. So if I try to use those integers that we used before, so if I say if I want row of 0 using Loc, then we're going to get a type error. And I get an error because it no longer has an index with that label. If you want to use Integer location instead of labels, then you still have the EyeLoc indexer available to you, and we saw that in the last video as well. So if I change this to be I loc instead of loc, then it'll still give us that first row. So that still works. Now if you accidentally set the index and want to reset it, then we can do that with the reset index method. So down here I will just say df dot reset underscore index and I will do an in place equal to true so that those changes carry over, and then I'll go ahead and print out that Data Frame"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". So down here I will just say df dot reset underscore index and I will do an in place equal to true so that those changes carry over, and then I'll go ahead and print out that Data Frame. So if I run this, then we can see that now we're back to having that email as a column and the default range index. Now, if you actually know what you want the index to be when you are creating your Data Frame, then you can simply set it there instead of setting it later using the set index method. And we can do that as we are loading in data from a CSV or other source as well. So let me switch over to, our other notebook here with the Stack Overflow data that we've been using so far throughout the series, and we'll take a look at some real world examples of why using indexes is useful. Now again, for those of you who have been following along, with the series so far, this should look, familiar to you"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". Now again, for those of you who have been following along, with the series so far, this should look, familiar to you. But if you haven't been following along and this is the first video you've watched, I we here's a brief overview of what's going on. We are loading in Pandas here. We are loading in some CSV files here as well, and I have a link in the description section below to the data that we are, using for these CSV files. And then we're also setting some options here in Pandas to display max columns to where we can see all the columns, and max rows to where we can, see a lot of these rows. And then this is what our data frame looks like. These are just survey results from Stack Overflow. So so far, if we look at our data frame here, in the series so far, we've been using this default index, and we can look over here and see that it's just this range from 0, 1, 2, and 3"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". So so far, if we look at our data frame here, in the series so far, we've been using this default index, and we can look over here and see that it's just this range from 0, 1, 2, and 3. Now if we look at the survey response data, then it looks like they actually have a unique value per row within the data itself. So if we look at this respondent column here, this respondent column, is actually a unique ID. So it's respondent 1, respondent 2, and 3, and so on. So really, we should probably clean this up a bit and just use that respondent ID as our data frame index. Now we could do this just like we saw before, by coming down here and saying df dot, set index and do it that way. Or we can do this while we re actually reading in the data, by passing in an additional argument to the read CSV method. So up here where we loaded in the data, lets just add another argument here and we will call this index underscore call is equal to and now the name of the column that we want to be the index"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". So up here where we loaded in the data, lets just add another argument here and we will call this index underscore call is equal to and now the name of the column that we want to be the index. And in this case, I want it to be this Respondent unique ID here. So I'm going to say our index call is equal to Respondent. I will rerun that cell. Now I'll come back down here and rerun our data frame head. And now we can see that this is cleaned up a bit because now we have this respondent as our actual index. So now these are the labels. So if you wanted the first respondent, then, we could just say d f dot loc, and that is 1. So this is the first respondent there. Okay. Let me delete that cell. Okay. So now let me show you a real world example of where I would use this. So if you remember from earlier in the series, we have our survey data that we can see here, but we also have another dataframe that tells us what each of these columns actually means in the survey data"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". So let me display that data frame real quick. So for example, if I wanted to know what hobbyist meant, then we can look at our schema data frame here, and we can see that the answer that they or the answer on the survey or the question on the survey for hobbyist was, do you code as a hobby? So when we see yes and no questions up here for hobbyist, they were answering the question, do you code as a hobby? So here's a question. What if I wanted to locate what a specific column meant without needing to search through this entire Data Frame manually? Well, in this case, we can simply set the column name as the index and use the dot loc indexer. So I'll set this index up here where we loaded in the schema Data Frame, so let me go back up here to the top, And the column, we want this here to be the index because these are all unique values"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". So I'll set this index up here where we loaded in the schema Data Frame, so let me go back up here to the top, And the column, we want this here to be the index because these are all unique values. So I'm going to grab the name of this column, which just so happens to be column, and then up here I will say that I want the index to be equal to this column of actually let me get that indexcol is equal to column. Run that and now let's re run our schema data frame. And now we can see that that column is bold so that is our index. So now we can use dot loc to search for those columns directly. So if I wanted to see what the information for the hobbyist column was, then I could just say let me scroll down here. I could say, schema data frame dot loc, and then we can just pass in the label of the index that we want. So if I wanted to see what hobbyist was, then we can see, oh, okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". I could say, schema data frame dot loc, and then we can just pass in the label of the index that we want. So if I wanted to see what hobbyist was, then we can see, oh, okay. Hobbyist has the question text of, do you code as a hobby? So let's go back to our survey data here and see if we can find, a column that doesn't make much sense to us. So if I scroll through these here okay. Like, what would this one mean? Mgr idiot. Okay? Mgr idiot. So let me scroll down here, and now I'll paste that into the, schemadf.loc and rerun that. Now we can see that we get the information for that column. Now the text is actually truncated in Jupyter Notebooks by default, but we can, we can change that setting if we'd like to see this entire question text. But I kind of want it 1 since we have so much data to display. But instead, if you wanna see the full text for that question, then you can just access the data in that row and column directly, by also passing in the column name into dotloc as well"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". But instead, if you wanna see the full text for that question, then you can just access the data in that row and column directly, by also passing in the column name into dotloc as well. So just like we've seen before when we're using dotloc, this is the row we want. So what column do we want? So we wanna read that question text, so I'll paste that in. And now if I run this again, now we can see that the full question text for what mgr idiot means is how confident are you that your manager knows what they're doing? So this is one nice example here of when, setting these indexes is useful, because it allows us to make the search, search these rows by labels very easily just like we did here with the schema. Now let me show you one more thing before we finish up here. So we can see that we were able to set our indexes, and all of that looks good. But it might make it a bit easier to read the schema data frame if the in indexes were sorted alphabetically"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". So we can see that we were able to set our indexes, and all of that looks good. But it might make it a bit easier to read the schema data frame if the in indexes were sorted alphabetically. So to do that, it's just as easy as saying, schema d f dot sort underscore index, and let's run this. Let me scroll down here a little bit. And we can see that now these indexes are sorted alphabetically. So if we knew that we wanted to, you know, get to employment or something, it's going to be in the e's. So that just makes it a little bit easier, to find what you're looking for. And if you wanted to, sort this in descending order instead, then we could just say ascending is equal to false. And now we can see that it is in reverse order here instead. So depending on your data, that might make it easier to read. So we're gonna go over a lot more advanced, sorting in a future video, but these are just some basics on getting our indexes in order"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". So depending on your data, that might make it easier to read. So we're gonna go over a lot more advanced, sorting in a future video, but these are just some basics on getting our indexes in order. Now, as usual with, our data frame, if you wanted to, the sort to be permanent and carry over into future cells, then you should set in place equal to true. And we'll see that a lot throughout the series, because doing it this way kind of allows us to, you know, see what things would look like without actually affecting the data frame itself. So down here, the data frame is still unsorted. But if I come up here and say sort index in place equal to true, rerun that, and then rerun our schema data frame, then now our schema data frame is permanently sorted"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". But if I come up here and say sort index in place equal to true, rerun that, and then rerun our schema data frame, then now our schema data frame is permanently sorted. So depending on your data, learning about these indexes will be, really useful, especially whenever using dot loc because it allows you to search by label there, which is extremely useful, depending on what type of data you are searching through. Okay. So before we end here, I'd like to mention the sponsor of this video, and that is brilliant dot org. So in this series, we've been learning about Pandas and how to analyze data in Python. And Brilliant would be an excellent way to supplement what you learn here with their hands on courses. They have some excellent courses and lessons that do a deep dive on how to think about and analyze data correctly"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". They have some excellent courses and lessons that do a deep dive on how to think about and analyze data correctly. For data analysis fundamentals, I would really recommend checking out their statistics course, which shows you how to analyze graphs and determine significance in the data. And I would also recommend their machine learning course, which takes data analysis to a new level, where you'll learn about the techniques used that allow machines to make decisions where there's just too many variables for a human to consider. So to support my channel and learn more about Brilliant, you can go to brilliant.org forward slash c m s to sign up for free. And also, the first 200 people that go to that link will get 20% off the annual premium subscription, and you can find that link in the description section below. Again, that's brilliant.orgforward/cms. Okay. So I think that is gonna do it for this pandas video"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". Again, that's brilliant.orgforward/cms. Okay. So I think that is gonna do it for this pandas video. I hope you feel like you got a good idea for how to use indexes and why these might be useful. And like I said, you don't have to use indexes, but sometimes it just makes sense depending on your data. So for example, in this video, setting the schema data frame index made it very simple for us to look up column names easily. So in the next video, we're going to start learning how to filter data frames and grab data that meets specific criteria. So maybe we only wanna see data where, you know, the salary is above a certain amount, or maybe we only wanna see data for people who said that they use Python, in this survey. So we'll take a look at being able to filter data frames on that type of criteria in the next video. But if anyone has any questions about what we covered here, then feel free to ask in the comments section below, and I'll do my best to answer those"
    },
    {
        "title": "Python Pandas Tutorial (Part 3): Indexes - How to Set, Reset, and Use Indexes",
        "text": ". But if anyone has any questions about what we covered here, then feel free to ask in the comments section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up, and also it's a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute through Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": "Hey there. How's it going everybody? In this video, we're gonna be revisiting line plots like we saw in the very first video, but this time we're gonna add to them by adding in fills. Now fills are great not only for making our plots look nice and professional, but also they can give us some useful insights depending on how we use them. So for example, we can use conditional fields that will show us what areas of our line plot fall above or below a certain threshold. So I think the best way to learn is for us to just jump in and start looking at some examples. Now I would like to mention that we do have a sponsor for this series of videos, and that is brilliant.org. So I really want to thank Brilliant for sponsoring the series, and it would be great if you all could check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay. So first, I'm loading in my data using the Pandas read CSV method to load in this CSV. Now if you've been following along with previous videos, then this probably looks a little familiar to you. But just in case you didn't see the other videos leading up to this, showing how this works, let me go over all this code here and show exactly what's going on real quick. So here at the top we are importing pandas, and we are also importing pyplot from matplotlib. Here we are bringing in some data from a CSV file, and I'll look at this in just a second, and show you exactly how that's working. But continuing on, we are also doing plt.plot. So this will do a line plot, and these are our ages and developer salaries here. Again, we'll take a look at this data in just a second. We have another plt.plot. So this will be a second line on our line chart. Now we also have plt"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". Again, we'll take a look at this data in just a second. We have another plt.plot. So this will be a second line on our line chart. Now we also have plt.legend to show these labels. We're also giving our plot a title, our x axis a label, our y axis a label. Tight layout just, changes the padding around where it looks a little nicer, and plt.show actually shows our plot. So that's a quick overview there. And all of this code and this data dot CSV file will be available for download in the description section below, and I'll put this up on my GitHub if you'd like to copy and, paste into your editor and follow along with this. So here, we are reading in this data from this CSV file, and we are reading this in from data dot CSV. So let me show you what this data dot CSV file looks like. So the data within this data dot CSV file are the ages, so 18, 19, 20, 21, and then these other columns here, we have all devs, Python, and JavaScript. So these are the median salaries for that age"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". So the data within this data dot CSV file are the ages, so 18, 19, 20, 21, and then these other columns here, we have all devs, Python, and JavaScript. So these are the median salaries for that age. So for, age of 18, the median salary for all developers who answered the survey, was this number here. The median salary for all the people who said they knew Python was this number here and so on. So when I go back to my code here, So when we load this in using pandas, when we say ages is equal to data age, all that's doing is grabbing that age column. So our ages variable is gonna be equal to, 18, 19, 20, 21, and so on. Same thing for our dev salaries. We're reading in that alldevs column. Pie salaries, we're reading in that Python column, and jssalaries, we're reading in that JavaScript column. Okay? And down here, we saw these line plots in the very first video of this series, but this is plotting out, the salary or their median salaries for all of our developers here"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". Okay? And down here, we saw these line plots in the very first video of this series, but this is plotting out, the salary or their median salaries for all of our developers here. And then we're adding in a custom color and style here as well, also giving it a label. And we're also pot plotting out the Python median salaries here as well. So if I run this with those plots, then this should be similar to what we saw in the very first video. We don't have JavaScript on there right now. I'm only gonna work with, Python and all developers, so that we can kinda see what's going on here a little bit better. Okay. But we've already seen these line plots here, so we kinda know already what that's all about. So now, let's see how we can add in some fields to our plot. Now we'll start off with a simple a simple one here, to just see what this looks like. So let's say that we wanted to fill the entire area underneath our Python plotted data"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". Now we'll start off with a simple a simple one here, to just see what this looks like. So let's say that we wanted to fill the entire area underneath our Python plotted data. So to do this, here above plot dot legend, we can create a fill for our plot simply by saying plt.fill_between. And now we're gonna pass in our x axis. So that was ages just like our other plots here. And now we wanna say what we want to fill between. So I want to fill between the Python salaries here, so I'll pass in py salaries. And now I'm not going to pass in anything else. Now we can pass in an additional parameter here and say that I wanna fill between, you know, pi salaries and dev salaries, for example. But, the y 2, this is called y 2, this is set to 0 by default. So if we don't put anything in there, then it's just going to fill between our Python salaries all the way down to the bottom. So let me run this just to show you what this looks like"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". So if we don't put anything in there, then it's just going to fill between our Python salaries all the way down to the bottom. So let me run this just to show you what this looks like. So now we can see that our Python plot here has a fill from our Python line all the way down here to the bottom. But we can see it's also interfering here a bit with our other plotted line, So to make this look a little bit better, let's put an alpha on our fill so that we can see through this a bit better. So back here in the plot, I'm just going to say alpha, and this is how much we can see through it. I'm just gonna say 0.25. So now, if I run that, then we can see that now that looks a little bit better there. Okay. So I feel like just filling in our line plots with an alpha here just makes our plots look a little bit better. But if we use these, with conditional thresholds, then it can also give us some useful information and some feedback as well. So let's see an example of this"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". But if we use these, with conditional thresholds, then it can also give us some useful information and some feedback as well. So let's see an example of this. So right now, our fill is defaulting to 0, which means it's filling between our y values, our Python plot, and 0 all the way down here at the bottom. But we can change that. So I have the overall median salary for all developers who answered the survey, and I have that commented out here. So instead of using 0, let's say that we wanted to fill between this overall median and our Python salaries. So to do that, we could just pass that in as that third argument, which is the y two value that I was telling you about, and that will, fill that in instead of defaulting to 0. So I'm gonna pass that in as the 3rd value there, and now let's run this plot. So now we can see that instead of plotting at 0, that overall median was 57,000. So now it's showing us exactly where our Python plot crossed that overall median salary"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". So now we can see that instead of plotting at 0, that overall median was 57,000. So now it's showing us exactly where our Python plot crossed that overall median salary. So when our Python plot is below the overall median salary, it fills up to that point. And when our plot is above the overall median salary, it fills down to that point. So that actually gives us some nice feedback. And we can even put in, some additional conditionals here so that it only fills when that condition is met. So let's look at an example of that. Let's say that we wanted one fill with the color set to green when we are above this median salary and another when it is below, so we'll say red or something like that. So to do that, we can say I'm gonna go to a new line here. Now we're actually going to add in, another argument here, and this is going to be a where. So I'm going to say where, and we're going to set this equal to this will be where pi salaries are greater than the overall median"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". So I'm going to say where, and we're going to set this equal to this will be where pi salaries are greater than the overall median. Okay? So that meets the conditional. This fill between meets the conditional where the Python salaries plot is over that overall median. And I'm also gonna add in one more argument here, and this is going to be, interpolate. So I'm gonna say interpolate, and I'm gonna set that equal to true. And that will just make sure that certain x intersections don't get clipped and that all of the regions are actually filled correctly. So I'm not gonna add custom colors yet. I just wanna show you what this one conditional does. So if I run this, then we can see that now our conditional here let me get this to where you can see the plot and the condition at the same time. So we can see here with that where clause that we are only doing that fill where our Python plot is above that overall median salary. But where it's below, it's no longer plotting up to that point"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". So we can see here with that where clause that we are only doing that fill where our Python plot is above that overall median salary. But where it's below, it's no longer plotting up to that point. So if we wanna fill in the area that's below the overall median with a different color, then we'll need to write another fill between method. So I'm gonna go back to the code here. I'm just gonna copy all of this that we currently have, and paste this in below. And instead of being above the overall median salary, I'm just going to say less than or equal to instead. And I think with this current, color scheme, that this first fill between is blue and this first fill between or in the second fill between here is red. So let's go ahead and run that and see what that looks like. Okay. It's not quite red. It's kinda orange, but I think that might just be the alpha"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". So let's go ahead and run that and see what that looks like. Okay. It's not quite red. It's kinda orange, but I think that might just be the alpha. So now we can see that everything below that overall median has one color, and everything above it has another based on our fill between methods. Now if we do wanna customize the colors, then we can do that pretty easily just by passing in a color argument. So let's change, one of our fill betweens here to have a custom color. So I'm gonna change, this bottom one here, and I will just say color is equal to, and we'll just pass in red. So if I save that and run it, then we can see that now that does have more of that reddish color than it, than that orange color. So right now, we have our plots filling in the area between our Python plot and a fixed value, and that fixed value is that overall median. But we can actually fill in the area between 2 different plots as well"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". But we can actually fill in the area between 2 different plots as well. So for example, if I wanted to fill in the area between the Python salaries and our developer salaries here by age, then I could just pass that into the fill between method instead. So let me go back here and show you what this looks like. So for, our fill betweens, instead of using this overall median, which is that constant value of 57,000, I'm going to use this dev salaries, which is the other line on our plot, and I'm going to pass that in as our third value here. And I also want to change my queries here. So I'm going to change this query to be over, those dev salaries, and this one to be under those dev salaries. So now if I run this, then we can see that now it's filling in the areas between those two plots. So we don't actually have a lot of red here because it doesn't really dip below, the other one. I don't know if it dips below right here or not if I zoom in. Yes"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". So we don't actually have a lot of red here because it doesn't really dip below, the other one. I don't know if it dips below right here or not if I zoom in. Yes. We have a little bit of red there where it dips below for that one age of 38 years old. But if I were to go in and manually edit, this information here so if I was to go down to, you know, ages, if I was to change this to, like, 45,000 instead, and let's see, 50,000 there and 55,000 there. I don't know what that's gonna make our plot look like, but now let's run it. Okay. And when I changed it manually there, we can see that now I made it dip below that line, and we can clearly see where we're in the blue, and then when it dips below our, all developers line there, we're dipping into the red. So it really helps when you're trying to emphasize those sections in your line plot"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". So it really helps when you're trying to emphasize those sections in your line plot. Now anyone viewing our plot still wouldn't really know what those red and blue sections represent, so it would probably be a good idea to label these filled sections. So to do that, we can simply pass in a label to our fill between method. So, back here in fill between, I'm just going to do this as the last item here. I'm going to say label is equal to, and for the top one here, I'm just going to say above AVG for above average. And for the bottom here, I will say below average. So now if I run that, then we can see that now those fields are included up here in our legend, and it tells us that the that the blue filled in area is above average and the red is below average"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". So now if I run that, then we can see that now those fields are included up here in our legend, and it tells us that the that the blue filled in area is above average and the red is below average. So not only do I think that these fill betweens make our plot, look better, like I just said earlier, but also it really helps us kinda add in a, 3rd level of information here and give us some more feedback, than what is here just on the plot. Okay. So we're just about finished up here. But before we end, I'd like to mention the sponsor of this video, and that is brilliant.org. So in this series, we've been learning about matplotlib and how to plot data in Python, and Brilliant would be an excellent way to supplement what you'd learn here with their hands on courses. They have some excellent courses covering the fundamentals of statistics, and these lessons do a deep dive on how to think about and analyze data correctly"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". They have some excellent courses covering the fundamentals of statistics, and these lessons do a deep dive on how to think about and analyze data correctly. They even use Python in their statistics courses and will quiz you on how to correctly analyze the data within the language. Their guided lessons will challenge you, but you also have the ability to get hints or even solutions if you need them. It's really tailored towards understanding the material. They've also recently released a programming with Python course, and they even have a coding environment built into their web site so that you can run code directly in the browser. And that is a great way to compliment watching my tutorials because you can apply what you've learned in their active problem solving environment, and that helps to solidify that knowledge. So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/cms to sign up for free"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/cms to sign up for free. And, also, the first 200 people that go to that link will get 20% off the annual premium subscription, and you can find that link in the description section below. Again, that's brilliant.orgforward/cms. Okay. So I think that is gonna do it for this video. Hopefully, you feel like you got a good overview of how you can use these fields to enhance your line plots and emphasize certain areas. In the next video, we're going to be covering histograms. And histograms are great for visualizing how our data is broken up into different ranges, and values and how many of those values fall into certain bins. So definitely be sure to check that out. But if anyone has any questions about what we covered in this video, then feel free to ask in the comments section below, and I'll do my best to answer those"
    },
    {
        "title": "Matplotlib Tutorial (Part 5): Filling Area on Line Plots",
        "text": ". So definitely be sure to check that out. But if anyone has any questions about what we covered in this video, then feel free to ask in the comments section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up, and also it's a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute through Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": "Hey there. How's it going everybody? In this video, we're gonna be learning how to plot histograms. So histograms are great for visualizing the distribution of data where the data falls within certain boundaries. It's a lot like a bar graph, but a histogram groups the data up into bins instead of plotting each individual value. So the best way to see what this looks like is to just take a look at some examples. Now I would like to mention that we do have a sponsor for the series of videos, and that is brilliant.org. So I really wanna thank Brilliant for sponsoring this series, and it would be great if you all could check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. So I have a little starting code here that you might recognize if you're continuing from previous videos"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". So with that said, let's go ahead and get started. So I have a little starting code here that you might recognize if you're continuing from previous videos. But if you're not, then let me give a quick overview of the code here and what's, what's going on. Okay. So up here at the top of the code, I am importing pandas. I'm also importing, pyplot from matplotlib. I'm using the 538 style, for, just to make our plots look a little nicer. And here is the data that I'm gonna be using for this video. Right now, I just have a list of ages here between 18 and 55. Here's some data that I have commented out in a CSD file, and we'll look at this, once we get further along in the video and see how to plot out more data than just this small list. Okay? So down here at the bottom, we are also creating a title for our plot. We have x and y axis labels. We have a tight layout which just, gives our plot some padding. And also, we are doing plot dot show which will actually show our plot"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". We have x and y axis labels. We have a tight layout which just, gives our plot some padding. And also, we are doing plot dot show which will actually show our plot. Now as usual, if you'd like to follow along, then I will have this code available on my GitHub, and there's a link to that in the description section below. If you wanna go there and copy and paste this into your editor so that you can follow along with this exact data. And I'm also gonna have the data dot CSV file that I'm using in this video as well. Okay. So like I was saying, we're first gonna look at how to do this using this list of, data directly here in the Python script, and then we'll look at a real word example with data that I'll load in from a CSV file. So first, let's look at this small list of sample data. So let's pretend that we took a survey and we tracked the ages of all the people who responded. Now it might be useful to plot those ages to get an idea of which age groups are in our sample size"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". So let's pretend that we took a survey and we tracked the ages of all the people who responded. Now it might be useful to plot those ages to get an idea of which age groups are in our sample size. So how should we actually plot these? Well, off the top of your head, you might think that a bar chart would be a good idea for this. But if you think about it, we possibly have up to a 100 different possible ages, maybe even more. So if you plotted out how many responses we got from each age, then that would mean you'd have almost a 100 different columns, which definitely isn't useful. So this is where histograms come in. Histograms allow us to create bins for our data and plot how many values fall into those bins. So to see this, let's create a histogram of this list of ages that we have here. So to do this, I can simply say plt.hist, and we will plot out those ages. Now if I ran this now, then it would give us a plot, but really we wouldn't know what bins it's actually using"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". So to do this, I can simply say plt.hist, and we will plot out those ages. Now if I ran this now, then it would give us a plot, but really we wouldn't know what bins it's actually using. So I always like to pass those in manually and explicitly so that people know what those bins are. So when we specify bins, we can either pass in an integer or a list of values. If we pass in an integer, then it will just, make that number of bins and divide our data into those accordingly. So for example, if I was to say bins is equal to 5, then this will divide all of these ages up into 5 different bins and then tell us how many people fell into those age ranges. So if we run this, then we can see that we get a pretty simple histogram here. And what this is is a distribution here. Now I personally find it a bit difficult to read these sometimes if we don't have edge colors for each bin, because they all just kind of run together here. So I don't know exactly how many bins there are here and here"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". So I don't know exactly how many bins there are here and here. I'm guessing since we have 5 bins, it's 2 bins here and 3 bins here. But let's add in some edge colors so that's more clear. So we can add those in by going back to our plot here, and I'm just going to pass that as an argument. So edge color is equal to, I'll just say, black. So now let's run this, and now we can see those bins a bit more clearly. So let me make this a little larger and also to where you can see the ages up here at the top. And let me explain what this is actually doing. So we said that we wanted our data plotted on a histogram, and we wanted that broken up into 5 different bins. So it calculated those ages for us. So this looks like it's between, let's see, 18 and, like, 26 maybe, and then 26 to, like, 33, and so on. But what this is telling us here is that there are 4 people in our ages here that fall between 18 to 26. And there are 4 people that fall between 26 to 33 and so on"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". But what this is telling us here is that there are 4 people in our ages here that fall between 18 to 26. And there are 4 people that fall between 26 to 33 and so on. And then we just have one person, in these higher age ranges for each of those bins. So if you pass in an integer for our bins, then that's what we get. But we can also pass in our own list of values, and those values will be the bins. And I like passing in a list of bins for this kind of data because you have more control over the exact values. So for example, let's say that I wanted to plot the ages broken up into groups of, 10 year differences. So I could say right here above my plot, I'm gonna say bins is equal to, and I'm just going to say that we want a bin for 10, 20, 30, 40, 50, and 60. And now instead of passing in that we want 5 bins, I want to say that I want to use this list as my bins"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". And now instead of passing in that we want 5 bins, I want to say that I want to use this list as my bins. So now if I run this, then we can see that we still get 5 different bins here, but that's only because, we have 6 values here in our list. So it starts at 10, and then 10 to 20, 20 to 30, 30 to 40, 40 to 50, and 50 to 60. So that is 5 bins total. So if I open this back up, now the reason I like using my own bins for this kind of data is because now it doesn't have to try to guess where I want these broken up. So we can see that now we have from 10 to 20. It's a lot easier to read. We don't have guess. It's like 26 or something like that. So we're saying from 10 to 20, 2 people in our ages list fell into that bin. There were 4 people from 20 to 30, 3 from 30 to 40, 1 from 40 to 50, and 1 from 50 to 60. So that's how you plot and read a a histogram. And we can even exclude some data if we don't want, to add those ranges to our bins"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". So that's how you plot and read a a histogram. And we can even exclude some data if we don't want, to add those ranges to our bins. So for example, let's say that we didn't want to include the ages between, 10 to 20 in my results. Well, to do that, we can just simply remove 10 from the bin, and now 20 will be that leftmost value. So now if we run this, then now we can see that it's not even plotting out, the ages from 10 to 20 there. So this 19 and 20 don't even show up in our results here. So this is now just giving us our results for the people who fell into these age ranges, between 20 60. Okay. So now that we've looked at this small example, now let's look at a real world example, looking at some real data. So let me uncomment what I've got here. Let me remove ages here. So I'm just going to remove that data that is directly in our Python script. Now I'm going to uncomment out the data that I had down here. Let me cut that out and paste it here, above our bins and our plot. Okay"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". Now I'm going to uncomment out the data that I had down here. Let me cut that out and paste it here, above our bins and our plot. Okay. So I'm loading in this data dot CSV file, and I'm using this pandas dot read CSV method to do this. Now we've done this a few times so far in the series, but if this is your first video that you are watching in the series, then let me explain this really quick. So we are loading in this data dot CSV. So what this does is it goes to this c data dot CSV file here. So let me explain, what this survey data is. So we have these responder IDs, and this is just an ID for each person who responded to the survey. So this is one person here. This is another person here, another person here. And then our age column here is just the age for the people who responded to this survey. So this person was 14, this person was 19, 28, 22, and so on"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". And then our age column here is just the age for the people who responded to this survey. So this person was 14, this person was 19, 28, 22, and so on. So back here, we have our IDs variable, and we're setting that equal to data, and then we are passing in this responder ID key. So what that does is it sets those IDs equal to all of these IDs here that are in this responder ID column. And here, we're saying ages is equal to data age, and that is setting that ages variable there equal to, this entire column here for our ages. And the data that I'm using here are the responses from the 2019, Stack Overflow developer survey. So this is actually real data for people who answered that survey. So we have, let's see, over 79,000 responses here, in this data dot CSV file. Okay. So let's plot a histogram of the ages for this dataset and see what age ranges most people fall into who answered this survey"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". Okay. So let's plot a histogram of the ages for this dataset and see what age ranges most people fall into who answered this survey. So I'm going to expand the bins here a bit, and I'm gonna say, 10, 20, 30, 40, 50, 60 will also cover 70, 80, oops, 80, 90, and let's also put in a 100 there. Now since we called this ages variable here the same thing that we had before, we don't even need to change our histogram plot, because that is still just ages there. So now I should be able to run this and get some real data here from this, or some results here from that data. So we can see here that based on this plot, that almost 40,000 Now it might Now it might not look like, we have data for 70 to 80 and 80 to 90, but it's likely because there just weren't many responses with those ages. And compared to 40,000 responses for the 20 to 30 group, it's just too small to show up. But I bet if I was to zoom in on these values here, then we will start to see something. Okay. So here's 70 to 80"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". But I bet if I was to zoom in on these values here, then we will start to see something. Okay. So here's 70 to 80. If I zoom in here, then we can see 80 to 83. So there are some responses there, but they're just being dwarfed by, these numbers over here. Now when you have certain values that are a lot more than your other values, then you can plot this on a logarithmic scale to mon to not make this look so extreme. So to do this, we can add an argument of log equals true to our plot. So within our hist method, I'm just going to say log is equal to true. And now if I run this, then this is plotting this on a logarithmic scale and we can see that now, we do have that data visible for 70 to 80, 80 to 90, and 90 to a100. So we actually had more people who responded, to the survey that they were between the ages of 90 to a100 than the people who were between 8090. So I think that's kinda interesting there"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". So we actually had more people who responded, to the survey that they were between the ages of 90 to a100 than the people who were between 8090. So I think that's kinda interesting there. Now sometimes you might find it useful to add some additional information within these plots as well. So for example, let's just leave the, histogram how we have it for now, but let's say that we want to plot a vertical line where the median age of all the respondents is. And I've got this commented out down here, at the bottom here. So let me uncomment out this median age, and also I'm gonna uncomment this color and this legend as well. So I went through and I calculated the median age of all of the respondents, and it was 29 years old. So now, let's plot a vertical line on our existing plot, with that age. So to do that, just above our legend here, I wanna say plt.axvline. So I'm pretty sure that is, stands for axis vertical line, and we want that line to be plotted at the median age"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". So to do that, just above our legend here, I wanna say plt.axvline. So I'm pretty sure that is, stands for axis vertical line, and we want that line to be plotted at the median age. And now let's also I'm gonna add in a color here. And the custom color, I'm gonna add, as this. I think this is just a red color that I grabbed. And also let's put in a label so that we know what this, line represents. And I'm just gonna say age median. So now let's run this. And now we can see that within our histogram, we now have, this vertical line here, which is the age median. So this plot tells us a lot of things. It tells us how many people are falling within which age groups, who answered the survey and also where the median is for those survey results. And if you think that this line is a little bit thick and kind of obstructing the data anyway, then you can play around with how this looks. So for example, if you wanted to change the thickness there, instead we could say line width is equal to 2"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". So for example, if you wanted to change the thickness there, instead we could say line width is equal to 2. If I run that, then that's a little thinner there. So that's basically what these histogram plots are used for. We can use these for dropping our data into these different bins and see how many values fall into these certain bins. So that's what you would use a histogram for. Okay. So we are just about finished up here. But before we end, I'd like to mention the sponsor of this video, and that is brilliant.org. Brilliant is a problem solving website that helps you understand underlying concepts by actively working through guided lessons. They have computer science courses ranging from algorithms and data structures to machine learning and neural networks. They even have a coding environment built into their website so that you can run code directly in the browser"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". They even have a coding environment built into their website so that you can run code directly in the browser. And that's a great way to compliment watching my tutorials because you can apply what you've learned in their active problem solving environment, and that helps to solidify that knowledge. Their guided lessons will challenge you, but you also have the ability to get hints or even solutions if you need them. It's really tailored towards understanding that material. So their computer science material is fantastic, and I really like what they're doing. They also have plenty of courses depending on what you're most interested in. So they have courses in different fields of mathematics or astronomy, solar energy, computational biology, and all kinds of other great content. So to support my channel and learn more about Brilliant, you can go to brilliant.org forward slash cms to sign up for free"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". So to support my channel and learn more about Brilliant, you can go to brilliant.org forward slash cms to sign up for free. And, also, the first 200 people that go to that link will get 20% off the annual premium subscription, And you can find that link in the description section below. And, again, that's brilliant.orgforward/cms. Okay. So I think that is gonna do it for this video. I hope you feel like you got a good understanding of how to use histograms and also when it might be appropriate for different kinds of datasets. These are definitely nice when we have data like we did in this video where we wanna divide those, ages up into different bins and get an idea of those age distributions. And sometimes that just doesn't tell you, the information that you're looking for. And And sometimes that just doesn't tell you, the information that you're looking for, and these histograms, are better suited for that. Now in the next video, we're gonna be learning about scatter plots"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". Now in the next video, we're gonna be learning about scatter plots. So scatter plots are great when we wanna show the relationship between 2 sets of values and see how they're correlated. So for example, let's say that we wanted to see how salaries were correlated with age or something like that. Well, we would probably assume that on average, we'd see higher salaries with higher ages. But to be sure, we can plot that with a scatterplot and see what that data looks like. So definitely be sure to check out that video. But if anyone has any questions about what we covered in this video, then feel free to ask in the comment section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up. And, also, it's a huge help to share these videos with anyone who you think would find them useful"
    },
    {
        "title": "Matplotlib Tutorial (Part 6): Histograms",
        "text": ". The easiest way is to simply like the video and give it a thumbs up. And, also, it's a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute through Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": "Hey there. How's it going everybody? In this video, we're going to be going over subplots. So so far in this series, we've simply been creating our plots with the pyplot object and that works great for what we've done so far. But if you want additional plots or if you wanna work with plots in a more object oriented manner, then it's best to create your plots with the subplots method. A lot of people prefer to create their plots this way even if they're only creating a single plot. So in this video, we're gonna see how to create our plots using the subplots method and go back over some of the plots that we created earlier in the series and see what changes need to be made in order to use subplots for those examples. Now I would like to mention that we do have a sponsor for this series of videos, and that is brilliant.org"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". Now I would like to mention that we do have a sponsor for this series of videos, and that is brilliant.org. So I really wanna thank Brilliant for sponsoring this series, and it would be great if you all could go and check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay. So I've got some sample code pulled up here in my script. And if you've been following along with the series, then you'll likely recognize the other matplotlib code that I have here at the moment. But if not, then let me go over this really quick. So this is actually a plot that I created in the first, video of the series, but we're loading in this data, using a CSV file here instead. Okay. So let me go over this. So first, we're importing pandas here at the top, then we're also importing the, pyplot module from matplotlib"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". Okay. So let me go over this. So first, we're importing pandas here at the top, then we're also importing the, pyplot module from matplotlib. We are using the seaborne style for these plots to just make them look a little bit better here. And now we're loading in this data from this CSV file using Pandas, read CSV method. So what this is doing is it's going and getting the age column from that CSV file, which if we look at the CSV file, these are the median salaries for these ages, for the respondents who answered this survey. So for age 18, these are all the median salaries, 19, median salaries, and so on. So our ages here, when we say data is equal to age and getting that key, it's setting it equal to that entire age column. So dev salaries, we're getting the all devs column, py salaries, we're getting the python column, and js salaries, we're getting the JavaScript column. And then we are plotting all of these out. So since we have plt"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". And then we are plotting all of these out. So since we have plt.plot3 times, that means that we're gonna have 3 lines on our line plot. So the first plot here is the Python salaries with our label. The next is the JavaScript salaries and then the all developers plot, and we're also giving this one a custom color and a dash line style. Then we are printing out the legend so that we know what is what. We're giving this a title. We are setting the x label and the y label for our axes. We have a tight layout here, which, means that we are getting some automatic padding for our plot. And then finally, we're doing plt.show, which actually shows our plot. And as usual, I'm gonna put a link in the description section below, that links to this code on my GitHub if anybody wants to download that or copy and paste this and follow along. Okay. So let me just run this really quick using the plt.plot method that we're using now, to see what we can expect here"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". Okay. So let me just run this really quick using the plt.plot method that we're using now, to see what we can expect here. And we have seen a plot similar to this, earlier in the series, so this might not look new to all of you. Okay. So now let me close that down. So that's what we should expect there. Okay. So we can see that every time we're doing something with our plot, we are using the plt object that we imported. That's that pyplot object. We never actually created that object ourselves. Now that might be weird for some people who are used to doing coding in a more object oriented manner. We might think at some point we should have done something like this. So we maybe should have said, like, plt is equal to, plot and created a new instance of a plot. And we can do something like that, and that's what we'll be looking at in this video. So the way that we're doing it now is called stateful"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". And we can do something like that, and that's what we'll be looking at in this video. So the way that we're doing it now is called stateful. And it's called stateful because we're importing this pyplot object, and we, it has a current state in terms of what figure we're currently working with and what axes we're currently working with and things like that. Now we haven't talked much about figures and axes so far in the series because we've been working with a single figure and a single axis object. So what are the figure and axes? Well, the figure is the container holding our plots, so you can think of that as that whole window, that shows us when we that when we run our code. And the axes are the actual plots, so a figure can have multiple plots. In this series, we've seen how to work with one plot within one figure, so just one axis, but we can have more than one, and we'll see how to do that in this video"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". In this series, we've seen how to work with one plot within one figure, so just one axis, but we can have more than one, and we'll see how to do that in this video. So there have been a few times in this series where we have used these methods of pltdot, GCF to get the current figure, and we have also used GCA for get current axes. And, like I said, those will get the current figure and axes for your plot. And you can switch between different ones, so that's the stateful way of doing it. But many people prefer, myself included, to use the more object oriented approach when working with multiple figures and axes. So to do this, we can use the subplots method. So let's take a look at this. Right now, let's simply recreate the same plot that we currently have, but instead of using the pyplot object that we imported, we'll instead instantiate a figure and an axis. So to do this, I'm going to get rid of those examples there"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". So to do this, I'm going to get rid of those examples there. Down here below my data, I'm simply going to say fig, comma, ax for axes is equal to plt.subplots, and that is a method. Now our axes here, which you can just think of as plots, is only set to a single axis at the moment, or a single plot. That's because by default, subplots create a figure and then specify a certain number of rows and columns of axes. If we don't pass in our number of rows and columns, then it just defaults to a 1 by 1, so 1 row and 1 column, which is simply one axis. So let's update our code to plot on this axis that we just created instead of using our pyplot object. For some cases, this is as simple as just using your, axis here instead of thepyplot object. So for example, all of the places where we said plt.plot, we can just replace those with ax. Plot. And where we have plt.legend, we can simply change that to use ax too. So I'll say ax.legend"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". So for example, all of the places where we said plt.plot, we can just replace those with ax. Plot. And where we have plt.legend, we can simply change that to use ax too. So I'll say ax.legend. Now when it comes to the titles and on the x and y labels, these are a bit different. So instead of using plt dot title and xlabelandylabel, we're instead going to do set underscore with those. So I'll do set underscore title, set_xlabel, and set underscore ylabel. So I'm not exactly sure why they did that with the naming conventions, but that's just how it's done. Okay. And we're going to leave everything else the way that it is. Tight layout is a method for our pie plot object, so that stays the same, and so is the show method that is for the pie plot object. So we can leave those as is. Okay. So now if we run this whoops. And I made a mistake here. You guys probably saw that as I did it, but I never actually put ax here. So this is axsettitle, ax.setxlabelandax.set ylabel. Sorry about that"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". And I made a mistake here. You guys probably saw that as I did it, but I never actually put ax here. So this is axsettitle, ax.setxlabelandax.set ylabel. Sorry about that. Okay. So save that and run it. And now we can see that we get the same plot that we got before, but now we're using this new axis. Okay. So why is this useful? Why are we learning this? Well, let's say instead of having all of this data in one plot, maybe we want, this broken up into multiple plots. So let's say that we wanted the Python and JavaScript plots together on one plot, but then we wanted these, this all developers plot to be on its own. Well, to do this, we can just add more axes and do it that way. So the first argument to the subplot's method is the number of rows and the number of columns. By default, it's 1 by 1, so that's why we get 1 axis. But we can change that to be a 2 by 1 for 2 rows of axes and 1 column, or however we'd like to do it"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". By default, it's 1 by 1, so that's why we get 1 axis. But we can change that to be a 2 by 1 for 2 rows of axes and 1 column, or however we'd like to do it. I'm gonna do 2 rows and 1 column, but you could do, 1 row, 2 columns, or however you want. But this is also gonna change how the axes are returned. So to show you an example of this, let me comment out everything, below here. So I'm gonna comment out from data all the way down to show, and let's see what we are getting for this returned, axi here. So I'm going to print this out. So I will print ax, and I will run this. And now if I make this a little larger here, we can see that this ax variable is equal to a single axis subplot. But now let's say that I wanted 2 rows and 1 column. So to do that, I could simply say n rows is equal to 2 and ncols is equal to 1. So now if I run this, then now we can see that our ax variable is a list of axes subplots. And now let's also see what happens if we do 2 rows and 2 columns"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". So now if I run this, then now we can see that our ax variable is a list of axes subplots. And now let's also see what happens if we do 2 rows and 2 columns. So I will put in 2 rows and 2 columns and run this. And now this gets a little more complicated. Now we can see that we have an outer list here, and within, this outer list has 2 values. And those two values are a list, so this is one value here. It's a list of 2 axes subplots. So a total of 4 axes total. Now that might be a little confusing with those nested like that, but you'll need to know how these are getting returned if you wanna unpack those in a certain way. But let's keep it simple here, and let's go back to 2 rows and 1 column, which is just the list of 2 axes subplots here. Okay. So that gives us our 2 axes, which is what we wanted in order to break our data up onto 2 plots. Now these two plots will still be on the same figure, which is the overall window"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". Okay. So that gives us our 2 axes, which is what we wanted in order to break our data up onto 2 plots. Now these two plots will still be on the same figure, which is the overall window. If you want them to be on different figures, then we'll take a look at that in just a second as well. Okay. So instead of having these 2 axes in a single variable of a x like this, let's instead unpack these, And I can do that since we are returning, a list of 2 values here. We can then just unpack this here and I'll call this ax1 and this ax2. And now I will print out ax1 and I will print out ax2. So let's run that, and now we can see that we are getting those axesubplots individually. Now if you don't know what I did with that unpacking and would like to see more examples of how unpacking works, then I do have a section on unpacking in my Python quick tips video, so I'll leave a link to that video in the description section below if anyone is interested in learning more about that. Okay"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". Okay. So now let's uncomment out our other code here and plot this data on our different axes. So I'm going to uncomment out our data and uncomment out where, we plotted these out. Now I'm going to remove these print statements here, and I think I'm going to want the all developers plot to be on top. I don't have to move it on top in the code, but since I'm having it on axie 1, I just want to move it up so that it kinda makes more sense, visually. So I'm gonna say axone.plot and plot out that all developers plot there. And now I will do ax 2 plot for Python and JavaScript. And now we can do different legends and titles and x and y labels for these as well. So I can copy this and paste it down here. So now I can do let me, exit that output so that we can see here. So I'll do ax1 for all of these here, and I will do ax2 for all of these here. Okay. So now we have all of those changed. So now if we run this, then we can see that now we have one figure with 2 different plots"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". Okay. So now we have all of those changed. So now if we run this, then we can see that now we have one figure with 2 different plots. So these are the 2 rows of axes. Okay. So we managed to split these up how we liked, but a couple of things pop out to me here. So first, since we are on one figure together, we don't really need a title for both of these. We can see that we have a title here and a title here. So let's just see, let's just use the title on top and not do the title for the second one here. So I'm going to remove that for ax2. So down here, we're doing ax2.setTitle. I'm going to remove that. And also, we also have the x axis labeled on both plots as well, but I think labeling it on the bottom axis is good enough. So I'm also going to remove the x label from the axis 1 here. So I'm going to remove that. Okay. So now if we run that with those changes in place, then I think now this looks a little bit better"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". So I'm also going to remove the x label from the axis 1 here. So I'm going to remove that. Okay. So now if we run that with those changes in place, then I think now this looks a little bit better. We only have one title here, and now we only have one x label here for our bottom plot, and we can kind of insinuate that these are, you sharing this x axis here. Now if you also only wanted the x tick marks on the bottom plot also, then we can also do that. And we can do that by passing in an argument to the subplot's method called share x. So let me close this down. Let's go up to our subplots method, and I'm going to say share x oops. Let me spell that correctly. And I'm gonna set that equal to true. And there's also a share y. So share x will only label the bottom ticks for 2 rows, and share y will only label the leftmost ticks for 2 columns. So if we run this, then we can see that now, we were we did have, these x tick marks here on this plot as well"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". So if we run this, then we can see that now, we were we did have, these x tick marks here on this plot as well. But since we're sharing this x, now we can see that we only have these listed on the bottom. So we can see that's nice and cleaned up compared to the first time that we actually ran that. Okay. So we have a nice figure here with 2 different plots, but what if we wanted these plots to be on 2 different figures instead of the same plot? Well, that's easy to do also. We just need to create another figure and an axis, the same as we did before. So here at the top where I'm creating these using the subplots method, I wanna change this just so or so that it only returns, one figure and one axis. So I'm going to take out those 2 rows and that one column. And now I'm going to just set that equal to ax 1. Now I'm going to copy this and add in another figure. And, also, I want to call this Fig 1. So I want this to be Fig 2, and I want this to be, axis 2"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". Now I'm going to copy this and add in another figure. And, also, I want to call this Fig 1. So I want this to be Fig 2, and I want this to be, axis 2. And now we already had those axis ones, plotted down here, so we don't have to change anything there. We could add that title back in and that x label back in for ax1ax2 down here. But just to see what this looks like, let's go ahead and run this, and we can see that now we get 2 figures here. So with those small changes, we were actually able to create 2 different figures here, and we can interact with these, just like we would any other figures. So in the very first video of this series, I showed you how you could save a figure as an image using the save fig method. Well, if we wanted to save both of these figures, then we can simply run save fig, on those figure objects. So down here below everything, if we wanted to save those, I could simply say figone.savefig, and I could call this figone.png"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". So down here below everything, if we wanted to save those, I could simply say figone.savefig, and I could call this figone.png. Let me copy this, and I will do fig 2 here for the file name and for the variable there. And now if I run this, if, it's still gonna pop up with those plots, I'm gonna close those for now. But if I look in my directory here, then I have a fig 1 and I have a fig 2. So it saved both of those. So it's nice being able to generate multiple plots at a time like this and save them to our file system. So this would be great for automating data analysis, where you're plotting data in a background script, and you could just have it save the plots for you, and then view them that way, rather than jumping into the code, and then view them that way, rather than jumping into the code and, looking at them that way. So there's tons of use cases for things like this. Okay. So we're just about finished up here"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". So there's tons of use cases for things like this. Okay. So we're just about finished up here. But before we end, I'd like to mention the sponsor of this video, and that is brilliant.org. So in this series, we've been learning about matplotlib and how to plot data in Python, and Brilliant would be an excellent way to supplement what you learn here with their hands on courses. They have some excellent courses covering the fundamentals of statistics, and these lessons do a deep dive on how to think about and analyze data correctly. They even use Python in their statistics courses and will quiz you on how to correctly analyze the data within the language. Their guided lessons will challenge you, but you also have the ability to get hints or even solutions if you need them. It's really tailored towards understanding the material"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". Their guided lessons will challenge you, but you also have the ability to get hints or even solutions if you need them. It's really tailored towards understanding the material. They've also recently released a programming with Python course, and they even have a coding environment built into their website so that you can run code directly in the browser. And that is a great way to compliment watching my tutorials because you can apply what you've learned in their active problem solving environment, and that helps to solidify that knowledge. So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/cms to sign up for free. And also, the first 200 people that go to that link will get 20% off the annual premium subscription, and you can find that link in the description section below. Again, that's brilliant.orgforward/ cms. Okay. So I think that's gonna do it for this video"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". Again, that's brilliant.orgforward/ cms. Okay. So I think that's gonna do it for this video. So I think everything that we've covered about matplotlib up to this point covers many of the basics for creating nice looking plots from your data, and also how to customize those in different ways. So from this point, I'm going to begin working on a series of videos covering the Pandas library and how to do in-depth data analysis with that. Pandas actually uses matplotlib for plotting out information itself. So knowing matplotlib will be a great thing to know for anyone who thinks they're interested in watching the panda series when I finish that and it's released. But if anyone would like to see me add to this matplotlib series, then please let me know if there's anything you are wanting to learn that I didn't cover in this series, or if there's anything that I just forgot and didn't cover. And if I get enough requests, then I can always continue adding to this series in the future"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". And if I get enough requests, then I can always continue adding to this series in the future. And I'm also gonna try to do a video in the near future showing exactly how I downloaded and parsed out a lot of this data. So a lot of this, like I said, I got from the 2019 Stack Overflow developer survey that I used in a lot of these videos. And it's definitely a good practice going out there and grabbing real world data and seeing how to get, what you want out from that data, and write your own scripts to plot out exactly what you want there. So be on the lookout for that video because I think that'll be a great exercise for most people. But with that said, if anyone has any questions about what we covered in this video, then feel free to ask in the comments section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up"
    },
    {
        "title": "Matplotlib Tutorial (Part 10): Subplots",
        "text": ". And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up. And, also, it's a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute through Patreon, there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": "Hey there. How's it going everybody? In this video, we're gonna be going over stack plots, and you may have also heard these called area plots. They are very similar to pie charts in the sense that they show you how the portions of the different values contribute to the whole. But instead of doing this just once, like on a pie chart, a stack plot shows us this over time. So for example, in the last video, we looked at a pie chart that showed us the popularity of different programming languages for a specific year. In this video, we'll show how that how we can make similar comparisons, but over a course of a certain time. Now real quick, I'd like to also mention that we do have a sponsor for this series of videos, and that is brilliant.org. So I really wanna thank Brilliant for sponsoring these videos, and it would be great if you all could check them out using the link in the starting code here that you might recognize if you're continuing from my other previous videos"
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": ". But if you're not, let me give a quick overview of this code and what's going on. Okay. So up here at the top, I am importing pyplot from matplotlib. I am using the 538 style just to make our, plots look a little bit nicer. I'm going to gloss over this data just for now. That's the data that we're gonna plot in this series. We'll take a look at that in just a sec. Here we have, plt.py, so this makes a pie chart, and we'll look how the stack plots are different from pie charts here in just a second. Also we have a title for our plot here. We have a tight layout which just changes the padding a little bit and makes it look a little nicer. And also we have the plt.show that actually shows our plot. Now as usual, I'm gonna have this code and also the snippets code for this video available for download. That's in the description section below. So if you wanna follow along, you can just go there and copy and paste it into your editor and follow along with this. Okay"
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": ". That's in the description section below. So if you wanna follow along, you can just go there and copy and paste it into your editor and follow along with this. Okay. So these stack plots are really good for data where you wanna track a total and also see the breakdown of that total by a specific category. So for example, let's say that you're playing a video game where you have teams, and you want to keep track of the total points for the whole team and also how many points each individual player has contributed. Now this is the kind of data that would be really great for a stack plot, and I've got an example of this kind of data, right here. So here's what this data represents. So we have a list here, a list of values of 1 through 9, and I have this labeled minutes. So this is the 1st minute of the game, 2nd minute, 3rd minute, 4th minute, so on. And for the player 123, their list is how many points they have scored, in the entire game up to that point"
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": ". So this is the 1st minute of the game, 2nd minute, 3rd minute, 4th minute, so on. And for the player 123, their list is how many points they have scored, in the entire game up to that point. So in the first minute, they all 3 scored a point. In the second minute, player 1 scored another point, so his total is 2, and so on. It goes all the way to the end. So if we were keeping track of the total points for the entire team in the first minute, then it would total 3, because you have one point from each player. But we we might also wanna see the breakdown of who scored those points. So in the 9th minute here, we have a total of let's see. That's 9 plus 3, so 12 points total. But player 1 scored 5, player 2 scored 4, and player 3 scored 3. So if we wanted to see the distribution of who's scoring the points at just one point in time, then we could just use a pie chart like we saw in the last video. And I have an example pie chart already written out here to show this"
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": ". And I have an example pie chart already written out here to show this. So if we wanted to see the distribution of points in the first minute for our slices, I'm just hard coding this in as a list of 111, which are the points all 3 players had in that first minute. And then I'm just giving them some labels of player 1, 2, and 3. So if I run this, then we can see it's a pretty simple pie chart. We just have an even distribution of 3 points here. But now let's use a stack plot to look at these distributions over an entire series of minutes. So to do this, I'm just going to erase my PIP plot there, and instead we're going to create a stack plot. So we can do a stack pot plot by saying, plt dot stack plot. And first we want to pass in the x axis values that represent the progression. So in this case, that's the minutes. And if this was based on time, which we'll look at in a bit, then this could just be a list of years or something like that. So I'm gonna pass in those minutes"
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": ". So in this case, that's the minutes. And if this was based on time, which we'll look at in a bit, then this could just be a list of years or something like that. So I'm gonna pass in those minutes. And now we can just pass in our list 1 by 1 as additional arguments. Now this can also be a multidimensional array if your data is arranged that way, But ours are currently individual 1 by in lists. So we're just gonna pass those in 1 at a time. So I'll pass pass in the player 1 list, the player 2 list, and lastly, the player 3 list. And that's all we need for a basic stack plot. So if I run this, then we can see here let me make this a little larger. This is what a stack plot looks like. So we can see our minutes down here, 1 through 9, and then each color breaks up the points scored by each individual player. So we can see here in the first minute that the total stack plot comes up to 3 here. But then if we look at how many each individual player has, then that's 1 a piece"
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": ". So we can see here in the first minute that the total stack plot comes up to 3 here. But then if we look at how many each individual player has, then that's 1 a piece. So we can see here by the end of the game that this blue section here, we don't have labels for this yet, but the blue section contributes the most, and then this red, and then this yellow. And we can easy easily add in labels to our plot just by passing in a list of desired labels into the labels argument. So let's go back to our code here, and I'm just going to, say right above our stack plot here, I'm gonna say labels is equal to, and we will make a list of 3 here and I'm just going to copy in players 1, 2, 3 and put them here in these labels. And now in our stack plot, we can simply say labels is equal to that labels list. So oh, and also, real quick, I almost forgot, we also need to actually say plt.legend, and, that will take those labels into account"
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": ". So oh, and also, real quick, I almost forgot, we also need to actually say plt.legend, and, that will take those labels into account. So if I save that and run it, then now we can see that we get the legend for player 1, player 2, and player 3. Now the legend should try to pick the best location by default, but if ever ends up in a location where you don't like it, then we can always hard code in at that location. So in this case, I feel like the upper left here would always be the best location for this specific data that we currently have. If your data was declining instead of increasing, then you'd probably want it in the upper right, but I'm gonna hard code this to where it's in the upper left. So the way we can do that is within our legend method, we can simply say loc for location, and just pass in upper left as a string. So if I run that, then now we can see that looks a lot better. Now we have our legend up there in the top left of our stack plot"
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": ". So if I run that, then now we can see that looks a lot better. Now we have our legend up there in the top left of our stack plot. And just like some of the other plots we've seen, we can customize the colors the same way that we customize the labels by passing in a list of colors that correspond to the values that we want to have that color. So I have some custom hex colors down here at the bottom. So let's say that I wanted player 1 to be green, I wanted player 2 to be red, and I wanted player 3 to be blue. So I could create a colors list here, and let's pass in those hex values. So I have those copied. Let me see if those paste in in order, and they didn't. So let me change that real quick. So I want player 1 to be green, so so I'll paste that in. I want player 2 to be red, and I'll paste that in. And I want player 3 here to be blue. So now if I run that, then we can see oops. And that actually didn't work because I didn't add colors to our, list of arguments here"
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": ". And I want player 3 here to be blue. So now if I run that, then we can see oops. And that actually didn't work because I didn't add colors to our, list of arguments here. So I need to pass in colors is equal to colors. So now this should work. Okay. So now we can see that our colors, look good. We have player 1 as green, player 2 as red, and player 3 as blue. Now another common use case for a stack plot is to visualize something that it, maintains a constant total. So what do I mean by that? Well, for example, let's say that you have a project and your team is only allowed to bill 8 hours to that project every day or something like that. So you could use a stack plot to track who's working on that project the most. So for example, let me grab, some code from my snippets, and I have my snippets file here. And then I will talk about what this means. And I'm also gonna have the snippets file available in the description section below if you would like to copy and paste this as well"
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": ". And then I will talk about what this means. And I'm also gonna have the snippets file available in the description section below if you would like to copy and paste this as well. So I'm just gonna overwrite our old values there. Now I'm keeping these variables here as players and minutes just for simplicity, but we can think of this as days and developers instead of players. So the example that I have here could be an example of someone handing off a project off to 2 other developers over a course of time. So each index for all of these developers adds up to a total of 8 hours, And one of the developers slowly fades out while the other 2, are taking over that project. Now that might not be obvious just by looking at these numbers here, but that's why we have plots so that we can plot these sort of things out, and we can see it visually instead of needing to pour through the data manually"
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": ". Now I know I'm running, or I know from running this earlier that the legend is going to be in a bad spot here in the upper left. So instead, I'm just gonna move this to the lower left. So instead of upper left, I'm gonna say lower left. And now let me plot out this new data. So let me make this a little larger here. Now we can see that the legend is still a little wonky. If you still don't like the location of the legend, then you can give it a more specific location by passing in coordinates to place the bottom left corner. And if you wanna see exactly how this works, then you can, Google Matplotlib legend, and it'll give you more details on how this works. But, basically, if I go back to my legend here, instead of passing in a string, if I pass in a tuple so let me pass in a tuple. I'll just do 0.07 and 0.05. And, again, if you'd like to know exactly what that's doing, then you can Google matplotlib legend and take a more detailed look at exactly what those coordinates mean"
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": ". I'll just do 0.07 and 0.05. And, again, if you'd like to know exactly what that's doing, then you can Google matplotlib legend and take a more detailed look at exactly what those coordinates mean. But for now oops. But for now, let's just continue, looking at our stack plot here. So let me rerun this. Now I think that legend is in a better location there. Let me make this a little larger. Basically, what that tuple meant was that we are putting the bottom left of the legend 7% from the bottom, or from the left, and 5% from the bottom. So we can see that now we can kind of visualize that data a little bit better, and see how one person's time fades out as the other 2 slowly add on. So we have player 1 here, which was our developer, who had a full 8 hours on this project in the 1st day here. And then as he moved on, he had 6 in the 2nd day. It looks like the other 2 picked up 1 hour at a time here"
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": ". And then as he moved on, he had 6 in the 2nd day. It looks like the other 2 picked up 1 hour at a time here. And then slowly, it looks like, the red player 2 here, developer 2, picked up more time in this project than player 3, but then at the end, they both have 4 hours apiece. So that's an overview of how these stack plots will work and the types of data that you would use with these stack plots. Like I said, it's great for visualizing these things over a certain amount of time and breaking down the total into individual parts over that course of time. Okay. So we're just about finished up here, but before we end, I'd like to mention the sponsor of this video, and that is brilliant.org. Brilliant is a problem solving website that helps you understand underlying concepts by actively working through guided lessons. They have computer science courses ranging from algorithms and data structures to machine learning and neural networks"
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": ". They have computer science courses ranging from algorithms and data structures to machine learning and neural networks. They even have a coding environment built into their website so that you can run code directly in the browser. And that's a great way to compliment watching my tutorials because you can apply what you've learned in their active problem solving environment, and that helps to solidify that knowledge. Their guided lessons will challenge you, but you also have the ability to get hints or even solutions if you need them. It's really tailored towards understanding that material. So their computer science material is fantastic, and I really like what they're doing. They also have plenty of courses depending on what you're most interested in. So they have courses in different fields of mathematics or astronomy, solar energy, computational biology, and all kinds of other great content. So to support my channel and learn more about Brilliant, you can go to brilliant"
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": ". So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/ cms to sign up for free. And, also, the first 200 people that go to that link will get 20% off the annual premium subscription, And you can find that link in the description section below. And, again, that's brilliant.orgforward/cms. Okay. So I think that is gonna do it for this video. I hope you feel like you got a good idea for when you use a stack plot and how this can be useful. I see these in different analytics all the time. So for example, the YouTube analytics will use these for our video views and traffic sources and things like that. So it would use a plot like this to show you your total views, but then it could also break down those total views broken up into, you know, traffic coming from recommended videos versus the homepage versus external sources and things like that. So there's, definitely a lot of real world use cases for these types of stack plots"
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": ". So there's, definitely a lot of real world use cases for these types of stack plots. Now Now in the next video, we're gonna be learning how to use fill betweens to enhance our line plots that we saw previously in the series. Fill betweens not only make our line plots look more professional, but we can also add in some conditionals that will color code values above or below a certain threshold. So definitely be sure to check that out. But But if anyone has any questions about what we covered in this video, then feel free to ask in the comment section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is simply like the video and give it a thumbs up. And also, it's a huge help to share these videos with anyone who you think would find them useful"
    },
    {
        "title": "Matplotlib Tutorial (Part 4): Stack Plots",
        "text": ". The easiest way is simply like the video and give it a thumbs up. And also, it's a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute through Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": "Hey there. How's it going everybody? In this video, we're gonna continue learning more about Pandas, and specifically, we're gonna be learning about the data frame and series data types. So like I said in the last video, these are basically the backbone of Pandas and are the 2 primary data types that you'll likely be using the most. So in this video, we're gonna go over how we can think of data frames and series data types in a different way, and then we'll look at the basics of getting information from these data types. Now I would like to mention that we do have a sponsor for this series of videos, and that is brilliant.org. So I really wanna thank Brilliant for sponsoring the series, and it would be great if you all can check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". And I'll talk more about their services in just a Okay. So first, let's look at what a data frame is, and then we'll learn more about how we can think about this in terms of a Python object. So we saw data frames briefly in our last video when we checked to make sure that our data was loaded in correctly. So these, were the objects that were displayed in Jupyter as rows and columns, basically a table. So let's take a look at what this looks like. So if you were following along with the last video, this is basically, the same Jupyter Notebook that I had before, except this is just cleaned up a bit. So we're importing pandas here. We are reading in our CSV files. So one is just our main data frame for our survey results. One is our schema data frame for the, schema results. And then we are setting some options here where we have the max column set to 85, so we can see all the columns, and the max row set to 85, so that we can see all of the schema"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". And then we are setting some options here where we have the max column set to 85, so we can see all the columns, and the max row set to 85, so that we can see all of the schema. Now if you haven't been following along with the video so far, then I do have a link in the description section below that links to where you can download this data and follow along with this. Okay. So, this is a data frame here. So where we are printing out df.head, this is what this returns. So this here is the first five rows of our data frame. So you can see that a data frame frame is made up of multiple rows here, and we also have multiple columns. So in the case of this data, these are survey results, but your data can be, you know, whatever your data is. But it's most likely gonna be in rows and columns, kinda like a table. So for this data, with these being survey results, each row is a survey is one person who answered the survey, and each question was their answer for that question on the survey"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". So for this data, with these being survey results, each row is a survey is one person who answered the survey, and each question was their answer for that question on the survey. So for example, this respondent number 1 here, they answered that, yes, they were a hobbyist. And if you wanna know what hobbyist means, then we just like we saw in the last video, we can look at our schema data frame. So let me go ahead and print this out here. And let's look at this. So if I look at what a hobbyist is, then we can see that that question was, do you code as a hobby? So that's what this data is, and that kinda gives us an idea of what a data frame is. Basically, a data frame is just rows and columns. But now let me explain how I like to think of DataFrames using native Python"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". Basically, a data frame is just rows and columns. But now let me explain how I like to think of DataFrames using native Python. So if we were only using Python and not using Pandas to store information in rows and columns, then how would we do this? Well, for those of you familiar with dictionaries, you might think that it's a good idea to store information that way. So let me pull up a new notebook here, that I have open here, with some snippets, and let's take a look at this. Okay. So let's look at this first cell here. So a lot of us are probably familiar with Python dictionaries where we have keys and values. So if I'm representing some data, in this example, it's a person, then we can use a dictionary. So first off, I have a key of first, which is gonna be the first name, and then, that has a value of Corey. And then we also have keys and values for the last name and the email as well. Okay. So this dictionary here, represents data for a single person"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". And then we also have keys and values for the last name and the email as well. Okay. So this dictionary here, represents data for a single person. But how would we represent data for multiple people? Well, there are probably a couple of different ways that we could do this, but the way that I like to think of this in terms of learning Pandas, is to make all of our values and our dictionaries a list. So let's take a look in the second cell here to see what this would look like. So here in the second cell, now we can see that we have a pretty similar dictionary, to what we had above. But now, instead of just a single string here for the values, I instead have a list, and our list currently just has one person. But now since this is a list, we can add more first names and information in here. So the first value of our list is going to be our first person"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". But now since this is a list, we can add more first names and information in here. So the first value of our list is going to be our first person. So if I go to the 3rd cell down here at the bottom, then now we can use this as an example to see what this would look like, with multiple people. So the second value in our list will be our second person, and the third value in the list will be our third person. So if we look here, we have people, we have a key of first. So if we want the second person here, we go to the second value, that's Jane. The last name is Doe. And the email, go to the second value here, is janedoe@email.com. If you want the 3rd person, that would be John, and then 3rd value and last would be doe, then 3rd value in email is johndoe@email.com. So we can kinda think of this like rows and columns. The keys are the columns and the values are the rows"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ".com. So we can kinda think of this like rows and columns. The keys are the columns and the values are the rows. Now if you look up the definition of a Pandas data Frame online, then you'll see a lot of definitions that just say something like it's a 2 dimensional data structure. Now that might sound a little confusing, but in layman's terms, that basically just means rows and columns. Okay. So like I said here, the key for email here would be our email column and contain all of the email values. And if we wanted to see, the email column, then we can just access that key. So if I come down here, into actually, let me run all of these really quick here. I think I opened this up without running these, so I wanna make sure that we have this registered. Okay. So if I wanted to see that email column, then I could simply say people and then access that email key. If I run that, then we can see that we got all of the emails"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". Okay. So if I wanted to see that email column, then I could simply say people and then access that email key. If I run that, then we can see that we got all of the emails. Now the reason that I wanted to show you this is because I feel like this really helped me in terms of how I think about data frames. So data frames are very similar to this, but with more functionality than what we have here in standard Python. Now, we can actually create a data frame from this dictionary and see what this looks like. So let's do that and look at some basic, dataframe functionality, and then we'll look at this more using the Stack Overflow data from the last video. So here in this bottom cell, in order to create a data frame from the information that we have here, I'm gonna go ahead and import pandas. So I'm gonna say import pandas as pd, and now we can create a data frame actually using this dictionary, that we have up here. So to do that, I can just say df is equal to pd"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". So I'm gonna say import pandas as pd, and now we can create a data frame actually using this dictionary, that we have up here. So to do that, I can just say df is equal to pd.dataframe and check the casing there, that's a capital d and a capital f, and then we'll just pass in, that dictionary that has, values as list. So if I run this, and that seemed to run okay without any errors, and now let me just print out df here. And And if I print that out, then we can see that now our data frame is, representing this in a way to where we do have rows and columns that we can visualize. So we get these people printed out in a nice table of rows and columns. Now we also have these over here, to the far left that don't have column names, this 0, 1, and 2. Now, this is an index. Now, I'm not going to go much into indexes right now, because that's what the next video is going to cover, but, basically, it's a unique value for our rows"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". Now, this is an index. Now, I'm not going to go much into indexes right now, because that's what the next video is going to cover, but, basically, it's a unique value for our rows. Now it doesn't need to be unique, but, again, we'll talk more about that in the video specifically on indexes. So now that we have a bit of an idea of how to think about data frames, now let's take a look at how to access information here within the data frame. So first, let's just access the values of a single column. So just like we did with the dictionary, we can access a single column just like we were accessing, the key of a dictionary. So just like I did people and email up here, I can do very similar down here and just say that I want that email column of my data frame. Now that's not actually a key, that is going to access the column of a data frame, but we can see here, that we get all of the emails back from that data frame"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". Now that's not actually a key, that is going to access the column of a data frame, but we can see here, that we get all of the emails back from that data frame. So again, I do wanna emphasize that I only use the pure Python example so that we could get an idea of how to think about a data frame. But like I said, a data frame is much, much more than just a dictionary of lists. So, for example, we can see that when, we displayed the email column here, it doesn't look the same as when we displayed, the list of values from that dictionary, And that's because this is actually returning a series, and we can see this if we check the type. So if I check the type of this, email column here, so let me run that, we can see that this is pandas.core.series.series. So this is a series object. So what is a series? So a series is still basically a list of data, but just like with a data frame, it has a lot more functionality than just that"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ".core.series.series. So this is a series object. So what is a series? So a series is still basically a list of data, but just like with a data frame, it has a lot more functionality than just that. Now if you look up the definition of a series online, then you'll see a lot of definitions that just say it's a 1 dimensional array. And that might sound a little confusing, but in layman's terms, that basically just means that it's rows of data. So again, you can think of a DataFrame as being rows and columns, and a series as being rows of a single column. So a DataFrame is basically a container for multiple of these Series objects. So again, that's important, so let me go over that one more time. So we can see that a data frame here is 2 dimensional, because it has rows and columns. So we can see here that it has, you know, first name, last name, email. Now whenever we access just the email, then we can see that we get all these emails here"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". So we can see here that it has, you know, first name, last name, email. Now whenever we access just the email, then we can see that we get all these emails here. Now this is a series, and I said that a data frame basically contains is a container for multiple series objects. So we can think of this email column here as a series, this last column here as a series, and this first column as a series. And also we can see where we printed out this series here for the emails, we can see that this series also has an index as well, just like our data frame did. So this index is over here on the left, the 0, 1, and 2. Okay. So we can access a single column of a data frame, like we're accessing a key, just like we did here, in this cell. But you might also see some people use dot notation to do the same thing. So you might see some people do it like this. So, they might do df.email. And if I run this cell, then we can see that let me get rid of this cell here and just so we can compare these 2"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". So you might see some people do it like this. So, they might do df.email. And if I run this cell, then we can see that let me get rid of this cell here and just so we can compare these 2. We can see that this gives us the same thing. Whether we access this like a key or whether we use dot notation, this returns, the same Series object of the email values. Now whichever way that you wanna do this is really just a personal preference. I actually prefer the first way of using the brackets, and there are a couple of reasons that I prefer to use that over dot notation. First is that I like using the brackets because there is a chance that one of your columns is named the same thing as one of the attributes or methods of a data frame. And if that's the case, then using the dot notation might give you some errors. So for example, if a data frame, a data frame has a method called count"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". And if that's the case, then using the dot notation might give you some errors. So for example, if a data frame, a data frame has a method called count. So if you had a column named count, and you did and you were trying to access that count column using dot notation, then that's actually, going to access the count method from data frame instead of that count column. So that actually wouldn't work, how we did it here if you wanted to access the actual column called count, which we don't have one in this specific data frame, but if we did, then we would have to access it like this. So that's kinda why I prefer, brackets. So I'm going to be using, brackets throughout this series, but I wanted you to know about dot notation. Because if you're working with other people using Pandas, then you might see them, access columns in, using dot notation. So you need to know that it's at least a possibility. And, again, that doesn't mean that they're doing it wrong. It's just a personal preference"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". So you need to know that it's at least a possibility. And, again, that doesn't mean that they're doing it wrong. It's just a personal preference. I just prefer using the brackets. Okay. So I said that data frames have a lot more functionality than what we saw using, you know, standard Python. So let's look at some other stuff that we can do here. So let's say that we wanted to access multiple columns. Now, in order to access multiple columns, we can use the bracket notation and pass in a list of columns that we want. So if I wanted both the Last Name and Email columns, then we could say df and use our brackets just like we saw before. But now I'm going to put in a set of inner brackets here as a list of columns that I want to access. So for the first value, I'll put last for the last name. And for the second value, I'll put email for the email. So if I run this, then we can see that now, we have a data frame returned here of the last column and the email column"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". And for the second value, I'll put email for the email. So if I run this, then we can see that now, we have a data frame returned here of the last column and the email column. Now I want to emphasize again here, that I passed a list inside of these brackets here. So there are 2 pairs of brackets. You can't leave off the inner brackets, because you will likely get a key error, because Pandas will think that you are passing in both of those strings as a single column name. And another thing that I want to point out here is that now that we're getting multiple columns, this can no longer be a series, Because remember, a series is basically a single column of rows. So when we get multiple columns like this, it's just returning another data frame. And in this case, it's a filtered down data frame, with just these specific columns. So we filtered out the first name column here, and we just have the last and the email. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". And in this case, it's a filtered down data frame, with just these specific columns. So we filtered out the first name column here, and we just have the last and the email. Okay. So that's how we get a specific column or multiple columns, and we can slice these as well, similar similar to how we slice a list. But I'll show that on our larger Stack Overflow dataset here in a second. Now, if you have a lot of columns and want to see all of them easily, then we can just grab the columns specifically by saying df.columns. And we can run this, and we can see here, that this gives us all of our columns here. So our columns are an index of first, last, and email. Okay. So now we've seen how to get a column, but how would we get a row? So in order to get rows, we can use the loc and iloc indexers. So that is loc and iloc. So let's take a look at these. So first, let's take a look at iloc. So iLook allows us to access rows by integer location, hence the name. ILook is integer location"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". So that is loc and iloc. So let's take a look at these. So first, let's take a look at iloc. So iLook allows us to access rows by integer location, hence the name. ILook is integer location. So if I wanted to get the first row, then we can just say d f dot iloc and then use brackets here to since this is an indexer. Use brackets and pass in a 0, and that will give us the first row. So if I run this, then we can see that the first row has a first name of Corey, last name of Shaffer, and email of coreymshaffer@gmail.com. So what that did is it returns a series that contains the values of that first row of data, which, like I said, is the first name, last name, and email, of the first person in this example. And again, we haven't discussed, indexes yet, that will be in the next video, but the index here is the column names, so that we know what those values are. So up here, our index was 0, 12"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". And again, we haven't discussed, indexes yet, that will be in the next video, but the index here is the column names, so that we know what those values are. So up here, our index was 0, 12. But whenever we're actually accessing a row, it's gonna set that index to the column name so that we know what those values are. Because if this just said 0, 1, and 2, then we might not know what these are. And just like when we selected multiple columns, we can select multiple rows as well by passing in a list of integers. So if I want the 1st and second row, then we can just say and again, this is gonna be a pair of brackets within these brackets, because we're passing in a list to our index here. And I'm just gonna pass in a list of 0 and 1. So if I run this, then we can see that now we get the first two rows of data. And again, be sure to pass in an inner list, inside those brackets so that it does what you expect it to do"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". So if I run this, then we can see that now we get the first two rows of data. And again, be sure to pass in an inner list, inside those brackets so that it does what you expect it to do. And also, we can see that now we're getting a data frame with these multiple rows. Now with these iloc and loc indexers, we can also select columns as well, and that is going to be the second value that we pass into these outer brackets. So if we thought of iloc and loc as functions, then we can think of the rows that we want as the first argument and the columns as the second argument. So let me show you what this looks like. So here, we have our inner bracket. Those are the rows that we want. But now after that list, we can put a comma, and now we can specify the column that we want. Now with iloc, we can't specify an actual column name because these use integers, integer locations, so these are for integers only"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". Now with iloc, we can't specify an actual column name because these use integers, integer locations, so these are for integers only. So remember, our first name is the first column, the last name is the second column, and the email is the 3rd column. So if we wanted to grab the email address of the first two rows, then we can grab the column at index 2, which will be the 3rd column since all of these start at 0. So if I was to pass in a 2 here and run that, then we can see that now we get the email addresses of these first two rows. Okay. So that's iloc. So now let's look at loc. So with iloc, we were searching by integer location. With loc, we are going to be searching by label. And when we are talking about labels for rows, these will be the indexes. And again, we don't have custom indexes right now, so this index is just a default range of integers"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". And when we are talking about labels for rows, these will be the indexes. And again, we don't have custom indexes right now, so this index is just a default range of integers. So at the moment, this will somewhat be similar with Iloc, the Iloc indexer, but we'll look at, uses or use cases with loc with actual labels in the next video when we cover indexes. So real quick, let's look at our entire data frame again. So I'm just going to print that out down here. So like I said, over here on the far left, these are our indexes. So these are the labels for that row. So if I want the 1st row, then by default, this just has a label of 0. So I can say, df.loc and pass in a 0 there. And if I run that, then we can see that we get that row with that label of 0. And again, I know that that looks similar to iloc at the moment, but we'll see how to use indexes with labels in the next video. And just like with EyeLOC, we can also pass in a list to specify multiple rows"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". And just like with EyeLOC, we can also pass in a list to specify multiple rows. So if I wanted the 1st and second row, then just like with EyeLock, I can pass in an inner list here. So let's say that I want the 1st row and the 2nd row. So I'll run that. We can see that now we get the 1st and the second row. And again, now we can see that we are getting a data frame back, with now that we have multiple rows. And just like with iloc, we can also pass in a second value into our indexer to select specific columns for these rows. Now with iloc, we used integers, to select the columns, but now that we're using loc, we can use labels. So if we want the email column of these first two rows, then now we can just pass in a value of email. So if I run that, then we can see that now, we get the email value of these first two rows. Now I didn't show this with EyeLook, but we can also pass in a list for the columns as well"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". So if I run that, then we can see that now, we get the email value of these first two rows. Now I didn't show this with EyeLook, but we can also pass in a list for the columns as well. So if I want the last name and the email for these rows, then instead of just passing in a string as this second value here, then we can pass in a list of strings of the columns that we want. So I'm gonna wrap this in brackets here. I know that this can get a little confusing with all these inner brackets, but let's say that we want email and we want last name. So if I run this, then now we can see that we got these specific columns here, email and last name, for these specific rows, the row with label 0 and the row with the label of 1. And also notice that the, columns display in the order that we used in our list up here within loc, which is a different, order from our original data frame. So up here, it's first, last, email"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". And also notice that the, columns display in the order that we used in our list up here within loc, which is a different, order from our original data frame. So up here, it's first, last, email. But we asked for email and last, and it gave us back in that order of email and last. Okay. So now that we've seen the basics of grabbing certain rows and columns from a small dataset, now let's go back to our dataset from the last video and see how we grabbed some rows and columns from the Stack Overflow dataset. So I am going to go over here to, back to our Pandas demo here. And again, just a quick overview of the data that we have here. We're importing pandas. We have df as our main survey results here, our schema df as our schema results. We are setting some options here. This is what our main data frame, head looks like, which is the first five rows, and then this is what our schema looks like. So I'm gonna go down below our schema here, and now let's mess around with this a little bit"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". So I'm gonna go down below our schema here, and now let's mess around with this a little bit. So let s go over a bit of what we learned and pluck out certain rows and columns. But first, let s see how many rows and columns that we have in this data frame. Now, we saw a couple of different ways to do this in the last video, but the easiest way to do this is to use the shape attribute. So if I say df dot shape and run this, then we can see that we have 88,000 rows and 85 columns. So let's grab all of the responses for the hobbyist column. So again, what I'm trying to do here is if we look at our main data frame, I wanna grab all of the responses for this column right here, hobbyist. Okay? So how would we do that? Now if you remember, if you want to see what columns are available, then you could just say df dot columns to see all of these. We can see that these are kind of long. We have 85 here. But here, we have hobbyist, which is the one that we want"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". We can see that these are kind of long. We have 85 here. But here, we have hobbyist, which is the one that we want. And that is the question where people answered if they code as a hobby or not. And in the next video, we're going to, cover indexes. I'll show how we can, you know, search, a schema data frame to find exact questions, so that we can, see what questions are what specific columns in the data frame. But right now, let's just grab those hobbyist responses. So if you remember from that small dataset that we just saw, in order to grab that hobbyist column, we can just access that like a key. So if I say d f and then pass in hobbyist there, then we get a series of all of those responses. And luckily, that doesn't display the entire 89,000 rows in our browser here, but we do get the head and the tail of that data to get an idea of what those responses look like"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". And luckily, that doesn't display the entire 89,000 rows in our browser here, but we do get the head and the tail of that data to get an idea of what those responses look like. Now real quick, let me show you something that we will cover more of further into the series, but I want to give you an idea of how powerful something like Pandas is. So let's say that we wanted to know how many of these responses were answered yes and how many were answered no. Now if we were using regular Python, then we might import the counter class or write a quick function or a loop to do this, but pandas has so much of this stuff already built in. So to get the count of unique values in this column, I can just use this value counts method to calculate this. So right up here, I can just tack on a method of value_ counts. Now, again, this is going to be for a future video, but I just want to give you an idea of what Pandas can do"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". So right up here, I can just tack on a method of value_ counts. Now, again, this is going to be for a future video, but I just want to give you an idea of what Pandas can do. So whenever I add this value counts method, we can see that out of this series that we returned here for all of our answers for this hobbyist question, the value counts are 71,000 people said, yes, they do code as a hobby, and about 18,000 said, no, they don't code as a hobby. And again, we'll cover more of this in future videos when we learn more about analyzing data in-depth, but I wanted to give you a quick taste as to why it's beneficial to even learn Pandas like we're doing here. It makes this type of stuff really easy, and we could go further and plot that out and everything. Okay. But with that quick sidetrack out of the way, let s keep going and, go over the other things that we learned earlier. So we got a column here. So let me get rid of that value counts. So we have our column here"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". So we got a column here. So let me get rid of that value counts. So we have our column here. So now, let's let's grab a specific row and a specific column. So let's grab the 1st row, and we'll also grab that same hobbyist column for that row. So how do we grab rows? So remember, if we wanna grab rows, that we use the loc or iloc or indexers. So I'm going to go ahead and use loc because remember that that's the one that allows me to use labels, and I'm going to use a label instead of an integer, for the hobbyist column name. Now, again, since we're just using a default index, and we can see the indexes here, 01234, since we're just using a default index instead of a custom one, our current labels for our indexes are just a range of values from 0 to 88,000 something. So in order to get the first row, I can say df.loc and pass in that label of that first index, which in this case is just a 0, and these are all of the responses from the first respondent"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". So in order to get the first row, I can say df.loc and pass in that label of that first index, which in this case is just a 0, and these are all of the responses from the first respondent. So this is one person's entire, survey results here. Now if we wanted to see their results for just that hobbyist question, then remember, within the brackets here, I can pass in a second value, for the columns that I would like. So if I pass in hobbyist, then we can see that their answer to that whether they code as a hobby is yes. And, also, like we saw earlier, I can also pass in a list of multiple rows or multiple columns, to get the exact rows and columns that we want to see. So to get the first three responses for the hobbyist column, then instead of just passing in a single value here, then I can put in some inner brackets here and pass in a list of multiple rows. So if I pass in a list of 3 rows here and run this, then these are the first three results for that hobbyist column"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". So if I pass in a list of 3 rows here and run this, then these are the first three results for that hobbyist column. Now one thing that we haven't seen yet is that we can also use slicing to grab multiple rows and columns as well. Now if you're familiar with list slicing, then this is pretty much the same thing. The only difference is that our last value is going to be inclusive, at least with loc. So if we wanted the first three rows, then we could say that we want from 0 and then slice to the index of 2. And if I run this whoops. And I accidentally made a mistake here. Actually, whenever we're using slicing, we do not wrap these in brackets, So I'm gonna take that out. So for our first value, we're just saying we're no longer passing in a list of values, we're just passing in the slice of 0 and then colon 2. So if I run that, then we can see that now we get the same result that we got before. And we can do this with the columns as well"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". So if I run that, then we can see that now we get the same result that we got before. And we can do this with the columns as well. So right now, we're only getting the hobbyist column, but let's go back and look at our columns and see what columns come after the hobbyist column. So up here, these are all of our columns here where we printed them out. So let's look at a few columns after Hobbyist here. So we have open sourcer, open source, Employment. So let's say that we wanted to get all of the columns from Hobbyist all the way up to this Employment column. So to do that, I'm just going to copy that. We can come down here and we can just pass in a colon and then employment, and that will do a slice from hobbyist to employment. Now I also want to point out that this is the reason that, slicing is inclusive, for these values, because imagine how much of a pain it would be if we wanted all of the columns from hobbyist to employment, but the last value here wasn't inclusive"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". And we had to come up here and say, well, if I went from hobbyist to employment, then I really need to pass in, you know, hobbyist to country, and country is not inclusive. That would just be way too confusing. So it's so much easier for this to be, inclusive here. So if you are wondering why they did that, then that's why they do it. So if I run this, then we can see that now for, we get these first three rows here. And for the first three rows, we get all of those, responses for the columns of hobbyist, open sourcer, all the way up to employment. So now we've seen an overview of everything that we've learned about exploring our data frames and series objects so far, and how we can pluck some, you know, basic information out of these. Now there's still tons to learn about data frames and series objects, and we'll continue learning more, learning more about these throughout the Pandas series, since these two data types are the main data types that we'll be using in Pandas"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". So we'll be learning more about advanced filtering, queries, how to see which data type each column of our data contains, and a lot more. Now before we end here, I do want to mention that we have a sponsor for this video, and that is brilliant.org. Brilliant is a problem solving website that helps you understand underlying concepts by actively working through guided lessons. And Brilliant would be an excellent way to supplement what you learn here with their hands on courses. They have some courses and lessons on data science that do a deep dive on how to think about and analyze data correctly. So if you're watching my Panda series because you're getting into the Data Science field, then I would highly recommend also checking out Brilliant and seeing what other data science skills you can learn. They even use Python in their statistics course and will quiz you on how to correctly analyze the data within the language"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". They even use Python in their statistics course and will quiz you on how to correctly analyze the data within the language. Their guided lessons will challenge you, but you'll also have the ability to get hints or even solutions if you need them. It's really tailored towards understanding the material. So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/ cms to sign up for free. And also, the first 200 people to go to that link will get 20% off the annual premium subscription. And you can find that link in the description section below. Again, that's brilliant.orgforward/cms. Okay. So I think that's gonna do it for this Pandas video. I hope you feel like you got a good introduction to the data frame and series objects, and how to navigate through some of your data. Now, like I said, there's a lot more to learn about these data types, and some advanced filtering that we'll learn in future videos, so be sure to stick around for that"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". Now, like I said, there's a lot more to learn about these data types, and some advanced filtering that we'll learn in future videos, so be sure to stick around for that. Now in the next video, we are going to be learning more about indexes. So we saw basic default indexes in this video, but we'll learn how to set the index to specific columns and the benefits of doing that in the next video. But if anyone has any questions about what we covered here, then feel free to ask in the comments section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up, and also it's a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute through Patreon, and there's a link to that page in the description section below"
    },
    {
        "title": "Python Pandas Tutorial (Part 2): DataFrame and Series Basics - Selecting Rows and Columns",
        "text": ". And if you have the means, you can contribute through Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": "Hey there. How's it going everybody? In this series of videos, we're gonna be learning how to use the Pandas library in Python. So Pandas is a data analysis library that allows us to easily read in and work with different types of data. So we can use this to analyze CSV files, Excel files, and other similar formats. So if you're getting into the data science field, then this library is going to be essential to learn. It's one of the most downloaded packages for Python, and that's for a great reason. So not only does it allow us to easily read in and analyze data, but it also has great performance since it built on top of NumPy. And we'll be learning how to do different types of an analysis or of data analysis in this series. So in this video, we're going to be going over how to get Pandas installed, how to download the data that I'll be using for most of this series, and also how to get all of this open in a Jupyter notebook so that we're ready to do some coding and analysis"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". Now, I'd also like to mention that we do have a sponsor for this series of videos, and that is brilliant.org. So I really wanna thank Brilliant for sponsoring this series, and it would be great if you all could check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. So first of all, let's install Pandas. So I am using a clean virtual environment for this series, but you don't have to use a virtual environment if you don't want to. If you don't know what a virtual environment is and would like to learn more about those, then I'll be sure to leave a link, to my video on that topic in the description section below if anyone is interested. So it's really easy to install pandas here. All we need to do is say pip install pandas, and we will let this run through"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". So it's really easy to install pandas here. All we need to do is say pip install pandas, and we will let this run through. And once we have Pandas installed, then let's also install Jupyter so that we can use Jupyter Notebooks. Now I was a bit hesitant to use Jupyter for this series, because some people find it difficult to get the hang of. But honestly, if you're gonna be doing a lot of work with pandas, then it's definitely a nice tool, to use for this. So now, it's not necessary, so you should be able to follow along with this series just fine if you're using a regular editor. But Jupyter Notebooks allows us to actually see our data more easily by using the browser to print out our data in tables that make it easier to visualize. So I'm gonna use it in the series, but you don't have to in order to follow along. So to install Jupyter, I'm gonna say pip install, and this is going to be, JupyterLab. And this is spelled, j u pyter l a b, JupyterLab. So we'll get that installed"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". So to install Jupyter, I'm gonna say pip install, and this is going to be, JupyterLab. And this is spelled, j u pyter l a b, JupyterLab. So we'll get that installed. Now, I'm not going to go into a deep dive in how to use Jupyter in this series. I'm mainly going to focus on Pandas, but if you'd like a detailed overview of how to use Jupyter, then I do have a video on how to use Jupyter in-depth, and and I'll leave a link to that video in the description section below if anyone would like to learn more, about the details of using that. Okay. So now we have Pandas and Jupyter Notebooks installed. Now we're going to need to download the data that I'll be using for most of this series. Now for anyone who's been watching my latest videos, you know that I like to use the Stack Overflow developer survey for different kinds of data analysis"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". Now for anyone who's been watching my latest videos, you know that I like to use the Stack Overflow developer survey for different kinds of data analysis. Now, the reason that I like to use this data is because it's real world data, and it has a lot of data in there that I think would be interesting to most people who are watching these types of videos. I've seen some other tutorials where the data just seems kind of unrealistic and not very relatable. So, hopefully, using this data will keep people interested and also give you a good idea of what it's like to actually download, download real data from a source and start analyzing it with Pandas. So to download this data, I have this pulled up here in the browser. We can go over to the Stack Overflow survey results page. Now, this is easy to find if you just Google it, but just to keep things easy, I'll have a link to this download page in the description section as well. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". Now, this is easy to find if you just Google it, but just to keep things easy, I'll have a link to this download page in the description section as well. Okay. Now on this page, you can download the data in CSV form for any year that they have available. And now I'm gonna go ahead and download the 2019 data, which is the, top data here. So I'm going to download this CSV here, and then we'll click on download again, and this should, go ahead and download this for us. Okay. It did. And now I'm going to open this in my finder here, and I'm going to unzip this data. It comes in a zip drive. And once that data is downloaded and unzipped, I'm going to go ahead and drag that folder to a folder here on my desktop, and that's where we'll also create a notebook and analyze this data. So real quick, I don't have this open. Let me open up, this pandas demo folder, and this will open this in Finder. And now I will take the data and drag this into this pandasdemo folder that is on my desktop"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". Let me open up, this pandas demo folder, and this will open this in Finder. And now I will take the data and drag this into this pandasdemo folder that is on my desktop. So your projects can be anywhere, but I just had I just created a, project folder here on my desktop called pandas demo, and it's completely empty except for the data that we just dragged in here. So now I'm going to rename this since this is kind of a long name here. I'm just gonna rename this to Data. That was, named Developer Survey 2019, but I'm just gonna call that Data so that it's easy for us to, find that within our script. Okay. So what files do we have here in the directory that we unzipped in this data directory? Let me make this a little larger here. Okay. So first of all, if you download, data that comes with a Readme, then this is usually helpful. We have a Readme file right here. It tells you what these other files are going to be"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". Okay. So first of all, if you download, data that comes with a Readme, then this is usually helpful. We have a Readme file right here. It tells you what these other files are going to be. So in this case, we have this survey results public dot CSV, and that contains the main survey results, one respondent per row and one column per answer. And the survey results schema here, has the questions that correspond to each column name in the results. Now, if any of this doesn't make sense now, then it then it will once we open up this data in Jupyter. So I'm just giving a broad overview here. Don't let this, overwhelm you by everything that I'm saying here. This will make a lot more sense once we open this up in Jupyter. So let's go ahead and do that. So to open this in a Jupyter notebook, I'm going to go back to my terminal. So I'm gonna go ahead and close these finder windows open here, go back to my terminal"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". So let's go ahead and do that. So to open this in a Jupyter notebook, I'm going to go back to my terminal. So I'm gonna go ahead and close these finder windows open here, go back to my terminal. And now within here, I'm going to navigate to my folder where I placed that data. And this should be the same command on Mac, Linux, and Windows. So I'm gonna say cd, and I'm gonna go to my desktop. This is gonna be wherever your, project directory is, but mine is in this pandas demo on my desktop. And once I am navigated to that directory, to start up a Jupyter Notebook, we just need to say Jupyter, notebook and run that. And we should see a server start up here, and it seems like it's taking a second. Okay. There we go. Now back in our terminal here, this will run a Jupyter server, and you will need to leave that terminal open while you're working in Jupyter. So Jupyter Run runs in the browser, so if you shut down this server, then you won't be able to access our notebook. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". So Jupyter Run runs in the browser, so if you shut down this server, then you won't be able to access our notebook. Okay. So let's go back here to the browser, and this is where we have our Jupyter Notebooks. So let me zoom in here so that we can, so that everybody can read this fairly well. Okay. I'll zoom in to about right there. I think it's good. Okay. So we can see our data folder here that we downloaded and placed in our, Jupyter demo folder a little bit ago. But now let's create a new notebook. So to create a new notebook, I'm gonna click on new up here at the top right, and then I'm gonna use Python 3. And now, we can name our notebook. So up here where it says untitled, I'm gonna click here, and I'm just gonna call this, pandas demo and rename that. Okay. So now we're ready to start using Pandas. So we can import this by saying import pandas as p d. Now importing pandas as p d is just a common convention when using pandas, so let's run that"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". Okay. So now we're ready to start using Pandas. So we can import this by saying import pandas as p d. Now importing pandas as p d is just a common convention when using pandas, so let's run that. And I ran that cell by pressing shift and enter. And again, I'm not gonna go into the specifics of working here within Jupyter in this series, but if you'd like a rundown of the features and shortcuts that I'll be using, then I do have a link to my Jupyter video in the description section below. Okay. So for the rest of this video, we'll see how to load in our data and look at some information about that data. So our data is in a CSV format. So in order to read in that CSV, we can simply say, df, which is going to stand for data frame, we'll learn about all about data frames here in a bit, we're going to say df is equal to pd dot read_csv. We're gonna use the read CSV method from, Pandas here, and now we just wanna pass in a path to our CSV file"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". We're gonna use the read CSV method from, Pandas here, and now we just wanna pass in a path to our CSV file. Now mine was within that data folder, and that was within the file survey underscore results underscore public dot CSV. So now, if I hit shift enter, then that will run that cell. So right off the bat, we can see that this is pretty simple to work with. So when using native Python, in order to read in a csv file, we need to use the csv module to create a csv reader and things like that, But here, we're just doing this all in one line. So when it reads this in, it's going to read it in as a DataFrame. So data frames are pretty much the backbone of Pandas, and we'll go more into, we'll go over data frames and, series objects in-depth in the next video. But for the basics, a data frame is basically just rows and columns of data. We can see what a data frame looks like just by printing it out"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". But for the basics, a data frame is basically just rows and columns of data. We can see what a data frame looks like just by printing it out. And this is the great thing about using Jupyter Notebooks because it allows us to visualize, these things in ways that we can't do in other editors. So here in Jupyter, I can simply just say df and run that, and it will print out, our data frame here. So we didn't even need to, wrap this here in a print function. Now, if you're using a normal editor, then you can still print out, data frame information, but it is not going to look as good as it does here in Jupyter, where we get this interactive table. So this is a small look at our data. Now this is actually 85 columns here, but if I scroll through these, then it doesn't look like there's actually 85 columns printed out here. So this is actually concatenated, by default just to give us a broad overview of the data. So by default, Jupyter is displaying 20 columns from our, data frame"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". So this is actually concatenated, by default just to give us a broad overview of the data. So by default, Jupyter is displaying 20 columns from our, data frame. Now how did I know that there was 85 columns for this data frame? Well, there are a few attributes and methods that we can use, to get an idea of what our data looks like. So first, we have the shape attribute, and shape, gives us the number of rows and columns in a tuple form. So let's look at this. So in our next cell down here, I'm gonna say df dot shape, and I will run that. Now this is an attribute here. It's not a method, so you don't wanna put parentheses. So d f dot shape, and we can see that we, have 88,000 rows and 85 columns. Now if you wanted a, bit more information, then we can use the info method. The info method will give us the number of rows and columns and also all of the data types of all the columns as well. Now before I run that, it looks like, my text is getting cut off here a little bit"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". Now before I run that, it looks like, my text is getting cut off here a little bit. Sometimes this happens whenever I'm within, Jupyter. In order to fix this, I usually just come up here and restart and run all my cells again. That usually takes care of the problem. Let's see if that works. Okay. So that seemed to work. Another thing that you can do here is just to totally reload the page in the browser. And when you reload the page, I think it's just because of how my I have this, text enlarged, so it's kinda messing with, how these look. But now we can see these just fine. Okay. So like I was saying, we can see here that we have 88,883 rows and 85 columns. Now if you wanted, more information, then we can use the info method, and that will give us the number of rows and the number of columns, but also all of the data types of the columns. So let's run that. So if I do df.info whoops.df.info. Now this actually is a method, so we do want to, put the parenthesis there"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". So let's run that. So if I do df.info whoops.df.info. Now this actually is a method, so we do want to, put the parenthesis there. And let me run this. And now let's go over this output. So we can see here that it says that we have 88,883 entries, so those are our rows. We have a total of 85 columns, and then it lists all of our columns here for our data. So these are all the columns in our CSV file that we have loaded in. Now, it also gives us the data types of each of these columns, and we're gonna go over data types in a future video. But for the most part, objects usually mean strings, and then we have other things as well. So int 64 is just an integer. Float is a float, so a probably a decimal number. And there are no other data types in this dataset. But there are more data types in general, so I will be sure to do a video on, data types specifically, in the near future. Okay"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". And there are no other data types in this dataset. But there are more data types in general, so I will be sure to do a video on, data types specifically, in the near future. Okay. So now that we know the number of rows and columns, let's change a setting here within Jupyter so that we can see all of the columns. So I think it would be useful to see all of these, if we'd like to, even if there are a lot of these to scroll through. So to do this, we can change a setting, and I'm gonna come down here to the bottom here, and I'm gonna change a setting by saying pdot set underscore option. And within here, I will say display dot max underscore columns, and I will set that equal to 85 so that we can see all of our columns. And I will run that. And now if we print out our data frame so I'm going to go back up here, to where we printed out this data frame, and I will rerun that cell"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". And I will run that. And now if we print out our data frame so I'm going to go back up here, to where we printed out this data frame, and I will rerun that cell. And now if I scroll through these columns, then we can see that now it looks like we actually have these 85, different columns here. So I can keep scrolling and keep scrolling, and it didn't just chop us off at that 20 like it was before. Now, obviously, the rows are also being concatenated here, and we definitely don't wanna print out all 89,000 of these rows, but, there probably are some examples with certain datasets where you might wanna see all of the rows as well. So for example, I said that the survey results results schema dot CSV file that was included in our download, gives the matching questions for all of these, column names here. So if we wanted to see what these column names here, mean for this data, then we can load in that schema CSV file as well. So let me do this"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". So if we wanted to see what these column names here, mean for this data, then we can load in that schema CSV file as well. So let me do this. I'll go down to the bottom of our notebook, and I will just load this in by saying schema underscore df. Now, I don't wanna just call this, df because we don't wanna overwrite our other data frame. And I will load this in just like we saw before by saying pd dot read underscore CSV, and this is within the data folder, and this was called survey underscore results underscore schema dot CSV. So I will run this, and now let's look at, this schema data frame that we just loaded in. So here, we on, this column column here, this gives us all of the columns in our other data frame. So we have respondent, main branch, hobbyist. And if I scroll up to that data frame here I'm gonna delete this info here since we'd no longer need that. If I scroll up to this data frame here, then we can see respondent, main branch, hobbyist"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". And if I scroll up to that data frame here I'm gonna delete this info here since we'd no longer need that. If I scroll up to this data frame here, then we can see respondent, main branch, hobbyist. So if we want to know what these mean, then that's what we use the schema for. So we can see that main branch or hobbyist means do you code as a hobby? Main branch means which of the following options best describes now it actually concatenates the text too. In order to actually see this the full text, we could either change an option or we could just access this value directly. And I will be showing you how to do that in the next video. But for now, we can see that we can't see all of the rows, to the questions that correlate to each column name here. Remember, we have 85 columns. But for here, we can only see the first five, and then we get this ellipses here, and then we can see the last 5"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". Remember, we have 85 columns. But for here, we can only see the first five, and then we get this ellipses here, and then we can see the last 5. So let's set this up so that we can view 85 rows and then reprint this so that we can see all of these. So back in the same cell where we set our max columns, now let's also add one for rows as well. So I'm just gonna copy and paste that, but instead of max columns here, I'm gonna have this be max rows, and I will run that. And now we will rerun this schema here, and now we can see that we can see all of the columns and the corresponding, question text. So if you wanted to know what any of these columns mean, then this is how we do it. So we can see IT person. The question was, are you the IT support person for your family? So that's probably a yes or no question. So that is what those mean"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". So we can see IT person. The question was, are you the IT support person for your family? So that's probably a yes or no question. So that is what those mean. So if you're going through this data on your own, then you can use this as a reference, anytime you don't know what a certain column means in our survey data. And if you don't know, or if you don't want to look through all of these to find a specific row for a specific, column name, then in a future video, we're gonna learn about filtering data frames and see how we can just grab a specific row where the column equals equals a certain value. Okay. So now we have all 85 rows visible of our schema data frame here. But you might be thinking, well, that's nice, but I don't want to see 85 rows of my survey data every time I want to look at it"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". So now we have all 85 rows visible of our schema data frame here. But you might be thinking, well, that's nice, but I don't want to see 85 rows of my survey data every time I want to look at it. But there are a couple of methods that we can use to only see a certain number of rows, which you'll most likely use a lot just to get an idea, that your filters and data frames seem to be working correctly. So we can see the first five rows by saying, instead of doing, df here, we can say df.head. And if I run that, then we just get the first five rows here. Okay? And you can pass in a value if you want to see a certain number of values. So if you wanted to see the first 10 rows, then we could pass in a 10 to df.head, and this gives us the first 10 rows. So we can see it goes all the way down, 0 through 9 there. Now if you'd like to see the last rows instead of the first rows, then we can use the tail method instead. So if we say df.tail, and, we could use it without a number also"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". Now if you'd like to see the last rows instead of the first rows, then we can use the tail method instead. So if we say df.tail, and, we could use it without a number also. But if we pass in a number just like with head, then now we're gonna say that we want the last 10, entries here in our data. So those are the last 10 items of our data. Okay. So this is a brief overview of getting pandas installed and then downloading our data and loading our data into Jupyter, and how to read this in. Now before we end here, I'd like to mention the sponsor of this video, and that is brilliant dot org. So in this series, we've been learning about Pandas and how to analyze data in Python. And Brilliant would be an excellent way to supplement what you learn here with their hands on courses. They have some excellent courses and lessons that do a deep dive on how to think about and analyze data correctly"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". They have some excellent courses and lessons that do a deep dive on how to think about and analyze data correctly. For data analysis fundamentals, I would really recommend checking out their statistics course, which shows you how to analyze graphs and determine significance in the data. And I would also recommend their machine learning course, which takes data analysis to a new level, where you'll learn about the techniques being used that allow machines to make decisions where there's just too many variables for a human to consider. So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/cms to sign up for free. And also, the first 200 people that go to that link will get 20% off the annual premium subscription, and you can find that link in the description section below. Again, that's brilliant.orgforward/cms. Okay. So I think that is gonna do it for our first Pandas video"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". Again, that's brilliant.orgforward/cms. Okay. So I think that is gonna do it for our first Pandas video. I hope you feel like you got a good introduction on how to install Pandas and load in your data to a Jupyter Notebook. In the next video, we're going to be learning more about data frames and also learn about the series data type. So we'll learn how we can think about data frames in a way that's easier to understand, and also see how we can grab certain elements, columns, and rows from these as well, so be sure to stick around for that. But if anyone has any questions about what will be covered in this video, then feel free to ask in the comments section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up, and also it's a huge help to share these videos with anyone who you think would find them useful"
    },
    {
        "title": "Python Pandas Tutorial (Part 1): Getting Started with Data Analysis - Installation and Loading Data",
        "text": ". The easiest way is to simply like the video and give it a thumbs up, and also it's a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute to patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": "Hey there. How's it going everybody? In this video we're gonna be going over scatter plots. So scatter plots are great when you wanna show the relationship between 2 sets of values and see if they are correlated. So, first, we're going to look at a basic example of a scatterplot using some data within our Python script here, and then we'll look at some real world data that I have within a CSV file. And the data within the CSV file are the views and likes of YouTube videos on the trending page, the day that I made this video. So that might be interesting to plot out. Now I would like to mention that we have a sponsor for this series of videos, and that is brilliant.org. So I really wanna thank Brilliant for sponsoring this series, and it would be great if you all could go check them out using the link in the description section below to support the sponsors. And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay. So I've got some sample code pulled up here in my script. Now first, we'll see how to, use these scatter plots using this list of data directly within my script, and then we'll look at a real world example with data that I'll load in from a CSV file. Now if you've been following along with the series, then you'll likely recognize the other matplotlib code that I've got here at the moment. But if not, then let me go go ahead and go over this real quick. So here at the top of the file, I'm importing pandas. I'm also importing pyplot from the matplotlib library. We are using a, plot style here of seaborne. We've been using 538 a lot throughout the series, but I wanna show what some of these different styles look like. Now we just have, some x and y data here of some random points between 110. I've got, some other code commented out here for now. Don't worry about that"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". Now we just have, some x and y data here of some random points between 110. I've got, some other code commented out here for now. Don't worry about that. We'll talk more about that when we get to it. We also have a title here for our plot, x and y label. Those are commented out at the moment. We also have a tight layout here with just with just, adds some automatic padding to our plots. And also we're doing plt.show, which will actually show our plot. Okay. So now let's look at how to create a basic scatterplot. Okay. So I've got a random list of values here for an x axis and a random list of values here for a y axis, and some of these values are repeated. So to create a scatterplot out of these values, it's as simple as saying plt.scatter, and we wanna do our x and our y values. So if I run this, and let me make this a little larger here, then we can see that we have a scatterplot of these random values"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ".scatter, and we wanna do our x and our y values. So if I run this, and let me make this a little larger here, then we can see that we have a scatterplot of these random values. Now scatterplots are really nice for seeing different trends or outliers or things like that. Now since these are random, then we don't really have any trends here, but sometimes that's important to know also that there's not a trend. So our scatterplot, since it looks random like this, then this likely tells us that there's no correlation between our two lists of random values. And we'll see data, dataset here in a bit that is more correlated, with the values. But for now, let's look at some basic customizations that we can make to our scatterplot. So, first of all, I feel like the sizes of the dots here are a bit small on this plot, and you can change that, by setting the size, and that is an s argument. So we'll set s equal to these sizes are always a bit weird"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". So we'll set s equal to these sizes are always a bit weird. I have to always look up in the documentation, how these are related. But, if we run this, then now we can see that these dots are a little bit larger here on our scatterplot. Now if you bump that up to, like, 500 or something, then it would really be noticeable. So we can also change the color and the marker styles of these plots as well. So to change the color, we can simply pass in a c argument. So we'll say c is equal to green. And there are all kinds of different marker styles that we can use as well. I'm gonna leave a link, to the page where you can go find the different styles. I'll leave a link to that in the description section below if you'd like to see the different styles. But for example, if I wanted to have, like, an x symbol then as our marker, then I could simply say marker is equal to, x"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". But for example, if I wanted to have, like, an x symbol then as our marker, then I could simply say marker is equal to, x. So if we save that and we run it, then we can see that now we have green markers, and these green markers are shaped like x's. So let me close that out. Now I almost never use anything other than the default markers, but the option is available there if you want it. But I'm gonna remove that for now and just go back to those default, circle markers. Now another thing about scatter plots is that I think they look a lot nicer if we add edges to the circles and also give them some alpha so that we can see through them a bit. So to show you what this looks like, let me add an edge and a color. So I'll say edge color is equal to we'll just set that equal to black. That's gonna be the edges of the circles. And for the, line width, let's also set the line width of that edge equal to 1"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". So I'll say edge color is equal to we'll just set that equal to black. That's gonna be the edges of the circles. And for the, line width, let's also set the line width of that edge equal to 1. And to give an alpha to our color, so that it softens it up a little bit, it's as easy as just saying, alpha is equal to, let's do 0.75. So if I run this, then we can see that now this looks a bit nicer here. I think that these, dots with these black edges looks a lot better. Now if your color is a bit too soft, then you can always play around with that alpha. Okay. So another thing that I want to show you is how the colors and sizes can actually be on a per mark basis rather than applying them to all of the marks. So what would, why would you want multiple colors or sizes? Well, having the ability to have multiple colors and sizes actually allows us to add additional datasets into our plot"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". So what would, why would you want multiple colors or sizes? Well, having the ability to have multiple colors and sizes actually allows us to add additional datasets into our plot. So for example, let's say that we have our current plot that we just looked at, but we wanted to add some additional information. So for example, let's pretend that our current plot is some survey data about a bunch of people, and we wanted to break down the data further into something more specific. So for example, let's say that we had, these people rate something from 1 to 10, and we wanted to somehow plot their rating as well. Well-to-do that, we could simply assign different numbers to these different possibilities, and those will then give you different colors on your scatterplot as long as you pass that into your method. So I have a colors variable commented out here, so let me uncomment this and let me move this above our scatterplot. And I think this will make a bit more sense once we plot this out"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". So I have a colors variable commented out here, so let me uncomment this and let me move this above our scatterplot. And I think this will make a bit more sense once we plot this out. Okay. So the numbers in this colors list, these are numbers between 110. Now, like I said before, maybe this could be a person's answer to how satisfied they are with a certain product or something like that. So each of these values will correspond to a data point in our x and y variables. So now, if we pass this into our scatter method as the color argument, so I'm going to say whoops, I accidentally repasted that. I'm going to say c, instead of being equal to green, I want it to be equal to colors. So now I'm going to run this. Then we can see that we get different color dots. So what this is doing here is whenever we plot this x and y value here of 57, it also has a color of 7. And these different colors here, 7, 5, 9, all of those, are going to correspond to different colors here on our chart"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". And these different colors here, 7, 5, 9, all of those, are going to correspond to different colors here on our chart. Now I really don't like the colors that we're getting here. These are just shades of gray. We can actually change these by using a color map. And just like the marker symbols, there are a ton of built in color maps that we can use. And I'll be sure to leave leave a link, in the description section below to all of the color map options if you'd like to play around with these as well. One that I personally like is called greens. So if I come down here after colors and I say c map is that argument, c map is equal to, and that is greens with a capital g. Be sure I put in a comma there. Now let me run that. And now we can see that now we're getting these different shades of green as the intensity. So I think the lighter ones are closer to 0 and the dark ones are closer to, 10. But we really don't know based on, how this is represented here"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". So I think the lighter ones are closer to 0 and the dark ones are closer to, 10. But we really don't know based on, how this is represented here. So you're probably gonna wanna add a label for your color map too, so that people viewing our chart know what these colors represent. So to do that, we can add a color bar legend. So I'm going to close this down. And below our scatterplot, we can just say c bar is equal to, and this is going to be plt.colorbar, and that is a method. And now I'm going to say cbar.set_label, and now we can set a label for this. So like I said, maybe this could be like a satisfaction level or something, so I'll just say satisfaction. So now let me run that, And now we can see that we have a color bar here on the right side, and now we have multiple points of information here. So we can see our x y data, but then we can also see, okay, depending on how these are colored, is that person's satisfaction level"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". So we can see our x y data, but then we can also see, okay, depending on how these are colored, is that person's satisfaction level. So these dark ones are very satisfied and the lighter color ones were not satisfied. Now we can also change the sizes of our data points as well. So just like with the color, this can add in an another way of explaining our data even further. So, for example, I see a lot of scatterplots that use the size of the dot for things like population and things like that, or maybe even the sample size for that data point. So I've got a random list of sizes commented out down here as well. So let me grab these and let me move those up underneath colors. And just like with the colors, this is a list of 20 different sizes here that correspond to the data points in the x and y variables that we're plotting. So if I was to pass in this sizes list here as my sizes so let's see. I took sizes out oh, no. Sizes right here. Sorry. So I will paste that in as sizes there"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". So if I was to pass in this sizes list here as my sizes so let's see. I took sizes out oh, no. Sizes right here. Sorry. So I will paste that in as sizes there. And now if we run this, then we can see that now each of these individual plots have a size as well, and you can use that for different types of data. Okay. So now that we've seen how to do these things with our simple sample data here, let's now look at how we can plot out some real world data from a CSV file that I have here in my current directory. So in the CSV file, I pulled down some of the data from, the YouTube API, and these were the 200 the top 200 trending videos on the day that I recorded this video. And I wanted to do a scatterplot of their total views and their total likes. And I also calculated out the ratio of likes to dislikes as well. Now in a future video, I'll actually cover the YouTube API and show how I grab data like that from there"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". And I also calculated out the ratio of likes to dislikes as well. Now in a future video, I'll actually cover the YouTube API and show how I grab data like that from there. But that's really a different topic, So let's just continue focusing on matplotlib here for now, and we'll save that for a future video. So let me pull up this CSV file here, and let's see what this looks like. So I've got that CSV file open here, and we can see that these are just the top 200 trending videos, on YouTube the day that I recorded this. So I didn't grab the the the titles or anything like that. I just wanted to see if there was a correlation between their view count and their likes. So here, we have the view count of the video. And so each one of these is a different video. This one had 8,000,000 views, this one had 9,000,000 views, and so on. We have the likes for that video in the second column here, and we also have the ratio of likes to dislikes"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". This one had 8,000,000 views, this one had 9,000,000 views, and so on. We have the likes for that video in the second column here, and we also have the ratio of likes to dislikes. Now since this is on the trending page, a lot of these have a high, like to dislike ratio. So this one has 96 percent likes to dislikes, 98%, and so on. So we can probably take a guess that the more views a video has, the more likes it's gonna have. But to see exactly what that correlation looks like, we're gonna have to plot it out. So I've got some code commented out down here at the bottom, that'll pull in some data from that CSV. So let's remove the sample code that we were working with earlier and uncomment out that other code. So I'm gonna keep our scatterplot here. So I'm going to cut that out, and I'm just gonna paste that, down here between the ratio and the title. Now for everything else, I'm just going to remove all of this sample data that we were using before"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". Now for everything else, I'm just going to remove all of this sample data that we were using before. Okay? And now let me uncomment out, where I'm loading in that data and also these titles and, x and y labels here. So let me describe how, what we're doing when we're loading in this data here. Now I've been using Pandas read CSV method throughout this series, but for those of you who haven't seen the rest of the series and are just watching this video, let me quickly explain what this is doing. So I'm reading in this CSV file, and this is the name of the CSV file here. And, again, this will be included, in the description section below if you'd like to download this and follow along. So it reads in that CSV and grabs all that data. Then we're setting this view count variable here equal to data and the view count key. Now what that does is it sets this view count equal to that entire column. So it's setting it equal to all of these view counts here"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". Now what that does is it sets this view count equal to that entire column. So it's setting it equal to all of these view counts here. And also with likes, it's setting that equal to the likes column. So it'll be equal to the first value is, you know, 300,000, 5,60,000, and so on. And lastly, ratio, same thing. It's getting that ratio key and setting it equal to that ratio column. Okay. So to plot this out using the same scatterplot that we used before, we can simply say that we want the view count. Let's put this on the x axis, and I'll put the likes on the y axis. Now let me remove the, size, colors, and the color map for now. And I will leave the edge color set to black and the line width and the alpha, but the sizes, colors, and color map, I'm gonna take out for now. Okay. So let me run this. Okay. So we can see here that we get a scatterplot. Now like I said, this is the top 200 videos on the trending page, so there should be 200 dots here"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". Okay. So let me run this. Okay. So we can see here that we get a scatterplot. Now like I said, this is the top 200 videos on the trending page, so there should be 200 dots here. Now it looks like some of our data has bunched here in the bottom left, and that's because we have one outlier here in the top right that was a video that had a lot more views and a lot more likes than the other views on the trending page. I actually went back to the original data to see what video was messing up my nice little scatter plot here, and it was the new Old Town Road music video by, Lil Nas X and Billy Ray Cyrus. So that's who to blame for that outlier. But I'm actually glad that there was an outlier, because it reminded me that we can use a log scale with scatterplots as well, to lessen how much those outliers actually skew the plot"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". But I'm actually glad that there was an outlier, because it reminded me that we can use a log scale with scatterplots as well, to lessen how much those outliers actually skew the plot. So, to make this look a bit better and use a log scale for our axis, we can simply say, down here below our scatter method, let's say plt dot xscale, and we will use a log scale for our x axis, and we will also use a log scale for our y axis. So I've got those, put in there. Now if I run this, then now that it's using a log scale instead of a regular scale, now we can see that those outliers don't skew the data so much and that we can kind of see the correlation better here. So the correlation between how many views a video has and how many likes it has really stands out here in this plot. So now let's also use the ratio of likes and dislikes in this plot"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". So the correlation between how many views a video has and how many likes it has really stands out here in this plot. So now let's also use the ratio of likes and dislikes in this plot. I think that would be a good metric to use for the color of our points, And we could also try to use that for size as well, but I think that the ratios might be a little bit too close for us to really tell the difference in sizes like we, can for the colors. So I'm just gonna use the colors and not worry about the sizes. So to do this, I can close down our current plot. And now I'm also gonna use another color map so that we can see another example of a different color map. So here within our scatterplot, right after our likes, this doesn't have to be in any particular order, I just wanna put them here, I will say c is equal to, and we want the color to be equal to the ratio. So that will, come in, and it'll set the colors, on a color map scale using these ratio values here for each of our markers"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". So that will, come in, and it'll set the colors, on a color map scale using these ratio values here for each of our markers. So now that we have that, I'm also going to pass in a c map, a color map, and let's use a color map of summer. I think that's a color map that I liked alright. And also, below scatter, let's also put a color bar so that we know what this represents. So I'm going to say c bar is equal to plt dot color bar, and now we want to set a label for that as well. So I'll see cbar.label, and we will say like, dislike ratio. Okay. Whoops. Not ration, ratio. Okay. So let me run this and make this a little larger here. And I think that this looks really nice. We can see now that, we get those colors representing the like to dislike ratio, and we have our color bar here telling us, what these numbers actually represent. So the ones that are more bluish green have, you know, performed less well. The ones that are bright yellow, performed better"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". So the ones that are more bluish green have, you know, performed less well. The ones that are bright yellow, performed better. So the bright ones are up in the nineties, and the ones that are a little darker and bluish green are kinda down in the fifties and sixties, which would mean that they had almost as many dislikes as likes on that video. But since I got these from the trending page, most of these are actually gonna be on the higher end since those are more popular videos anyway. But we can see that we do have, some dark ones, mixed in here, and most of those dark ones do fall on the bottom side, of our page here. So using a scatterplot like this is a great way to get the correlation for the values that you're plotting out, and also using colors and sizes can, you know, add it to where you are adding in even more metrics and putting more information into your plots. Okay. So we're just about finished up here"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". Okay. So we're just about finished up here. But before we end, I'd like to mention the sponsor of this video and that is brilliant dot org. So in this series, we've been learning about matplotlib and how to plot data in Python, and Brilliant would be an excellent way to supplement what you'd learn here with their hands on courses. They have some excellent courses covering the fundamentals of statistics, and these lessons do a deep dive on how to think about and analyze data correctly. They even use Python in their statistics courses and will quiz you on how to correctly analyze the data within the language. Their guided lessons will challenge you, but you also have the ability to get hints or even solutions if you need them. It's really tailored towards understanding the material. They've also recently released a programming with Python course, and they even have a coding environment built into their website so that you can run code directly in the browser"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". They've also recently released a programming with Python course, and they even have a coding environment built into their website so that you can run code directly in the browser. And that is a great way to compliment watching my tutorials because you can apply what you've learned in their active problem solving environment, and that helps to solidify that knowledge. So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/cms to sign up for free. And, also, the first 200 people that go to that link will get 20% off the annual premium subscription, and you can find that link in the description section below. Again, that's brilliant.orgforward/cms. Okay. So I think that is gonna do it for this video. I hope you feel like you got a good understanding of how to use scatter plots and the kind of data that this type of plot is good for"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". Okay. So I think that is gonna do it for this video. I hope you feel like you got a good understanding of how to use scatter plots and the kind of data that this type of plot is good for. Now like I said, it's really nice for seeing these correlations in the data, like how the views and likes were related for the trending pages. Now in the next video, we'll be going over time series plots. And these are very similar to the line plots that we saw before, but they're focused on data over a certain amount of time instead. So definitely be sure to check that out. But if anyone has any questions about what we covered in this video, then feel free to ask in the comment section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is simply like the video and give it a thumbs up. And, also, it's a huge help to share these videos with anyone who you think would find them useful"
    },
    {
        "title": "Matplotlib Tutorial (Part 7): Scatter Plots",
        "text": ". The easiest way is simply like the video and give it a thumbs up. And, also, it's a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute to Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": "Hey there. How's it going everybody? In this video, we're gonna be looking over time series data and plotting dates in Matplotlib. Now there's a ton of data out there that contains date information, so knowing how to plot this properly is definitely gonna be a huge help when creating these graphs. So first, we're gonna look at some basic examples using some dates that I have directly here within my Python code, and then we'll see an example using data from a CSV file. And the data within the CSV file, are Bitcoin prices over a couple of weeks. Now I would like to mention that we do have a sponsor for this series of videos, and that is brilliant.org. So I really wanna thank Brilliant for sponsoring this series, and it would be great if you all could go check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay. So I've got some sample code pulled up here in my script. So first, we'll look at these time series plots using this list of data directly in my script, and then we'll look at a real world example with data that I'll load in from a CSV file. Now if you've been following along with the series, then you'll likely recognize a lot of the other matplotlib code that I have here at the moment. But if not, then let me go over all this real quick. So here at the top, we have some imports. So we're importing pandas. We're also importing, datetime from the standard library We are importing pyplot from matplotlib, and we're also importing, dates from matplotlib. And we're importing that as npldates, because I was afraid I was going to, override it with a variable like I did here called this dates. Anyways, we are also using a style here. We're using seaborne style with matplotlib"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". Anyways, we are also using a style here. We're using seaborne style with matplotlib. These are the data that we're gonna be using, but I'm gonna gloss over this for now and just point out the rest of this code here. We have a plt.tight layout here that adds a padding to our plot, and plt.show will just show us our plot. And we'll go over this other data once we are actually ready to plot that. And as usual, all of this is gonna be available for download on my GitHub, and there's a link to that in the description section below if anyone would like to copy and paste this into their editor and follow along with this series. Okay. So for my sample data here, I've got a list of 7 dates, and I'm using Python's built in datetime module to create these. So these are just 7 days back to back. And then below, I've got a y variable here for our y axis, And this is just a list of 7 random values. So to plot these dates, we can simply say, down here below our y axis, plt.plot"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". And then below, I've got a y variable here for our y axis, And this is just a list of 7 random values. So to plot these dates, we can simply say, down here below our y axis, plt.plot. And we want to do oops. That is plot date. And we want dates to be the x axis, and we want y to be the y axis. So if I run this, then we can see here that it plots those out. Now if you get some warnings in your output down here, then don't worry about that. Mine is just warning me about some future change in pandas that will be taking place. But we can see that we get those dates and values plotted out. Now I'm not sure why, but by default, this plot has markers instead of being connected by a line. But we can fix that easily just by saying that we want the line style line style of this plot to be solid. So now if I run that I wanna make this small again now that we've seen that warning. So now we can see that these are now connected by a line"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". So now if I run that I wanna make this small again now that we've seen that warning. So now we can see that these are now connected by a line. And if you wanted to, then you could also go ahead and turn off these markers by setting marker to none, but I'm going to go ahead and leave those here for now. Okay. So now that we have some dates to work with, let's look at some different ways that we can format our plot to make this look a bit better. So one way that we can do this is to run the auto format x date method on our figure, and this will rotate our dates so that they fit a bit nicer and change their alignments and things like that. Now we haven't talked much about figures and axes in this series yet. That is gonna be in the subplots video in a couple more videos. But basically, this is going to be a method on our figure and not on this, pyplot object that we have been using. So to get the current figure from pyplot, we can say plt.gcf, which is get current figure"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". So to get the current figure from pyplot, we can say plt.gcf, which is get current figure. And now to run this auto format method, we can just run it on that current figure and say auto fmt for format, then underscore x date. Okay. So now if I run this, then we can see that now these dates, are rotated and they have different alignments. That just makes it so that these are, you know, not so bunched together and it makes it easier to read. Okay. So now that we've got that auto formatting in place, let's also see how we can change the format of our dates. So what if instead of how they're displayed now with the year, month, day, what if instead we wanted them to start with the name of the month and then the day and then the year? So to do this, we have to use some date time formatting. So to do this, I've already imported this line up here at the top, from matplotlib import dates as MPL dates"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". So to do this, I've already imported this line up here at the top, from matplotlib import dates as MPL dates. And from that imported module, we're gonna use the date formatter class, and we're gonna be passing in any format string that you could also pass into the strftime method from the datetime class. Now if you don't know how to format dates, then I do have a separate video on Python datetime, on the datetime module that goes into more detail about that. So I'll leave a link to that video in the description section below if anyone is interested in that. And I'll also leave a link to the Python documentation where you can find the formatting codes for the format that you're looking for. So for this example, let me write out the format that we want. So down here below where we, ran that get current figure, now I'm gonna say date underscore format is equal to MPL dates that's what we imported at the top and we're going to use the date formatter class from that imported module"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". And now we're gonna pass in our format string. And again, I'm gonna leave a link, in the description section below to the Python documentation where you can find these formatting codes. But I have mine written down here. I always need to look these up. But for the abbreviated name of the month, that is, percent sign lowercaseb, and then for the days, that's percent sign d, and then the year is percent sign, capital y to do all 4 digits of the year. And, again, I will leave a link to that documentation so that you can look up other formatting codes if you wanna change it up. So now we need to set this as the format for our x axis. So just like I grabbed the figure to run the auto format method, I'm going to need to grab the axis to run this format method. So to grab the current axis, it's a lot similar to getting the current figure. We'll say plt"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". So to grab the current axis, it's a lot similar to getting the current figure. We'll say plt.gca, which is get current axis, and then we can format the x axis by saying dotxaxisdot set_major_formatter, and we will set that equal to our date format here. So now if I formatted that correctly, if I run this, then we can see that now we don't have that year month date that we had before. Now this is formatted to say May 24th, May 25th, May 26th, and so on. So you can format your dates however you like to show up in your chart. Okay. So now that we've seen how to work with date times using this simple example here, now let's look at some data that I have here in a CSV file and see if we can load that in and plot it. So let me remove what we have now and I'll uncomment this code that I have here at the bottom. So I'm going to, copy these two lines here where we are doing our plot date and also our auto format. So I'm going to cut those out so that I can paste them in later"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". So I'm going to, copy these two lines here where we are doing our plot date and also our auto format. So I'm going to cut those out so that I can paste them in later. And now I am going to remove from dates all the way down to where we, set that formatter. I just wanted to show how to format those dates, but, I'm not gonna format this next example. Okay. So now I'm going to uncomment out the other code that I have here, and we will explain what this is doing here in just a sec. But first, let me paste in, where we were plotting that data and also setting the auto format date there. Okay. So up here, we are loading in a CSV file here using Pandas. And if you've been following along with this series, then this probably looks familiar to you since we've loaded in CSV data a few times in the series so far. But just in case, let me go ahead and show you the CSV data and also go over how we're loading this in"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". But just in case, let me go ahead and show you the CSV data and also go over how we're loading this in. So we are loading in the data from data dot CSV, and I have this pulled open here in the other tab. So this is the data that we're loading loading in. So these are the headers here. The first value is the date. The next value is the open price. The next value is the high price for that day, low price, close, adjusted close, and volume. And like I was saying, this is just Bitcoin data for about, I think 2 weeks or so. So, this I just pulled offline. And, actually, this line here at the bottom, that's not supposed to be there. I'm gonna add that in later. I just had that there for a while I was testing. Okay. So let me go back to the code and explain how we're loading this in. So when we read this in, it's loading this in as a Pandas data frame"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". I just had that there for a while I was testing. Okay. So let me go back to the code and explain how we're loading this in. So when we read this in, it's loading this in as a Pandas data frame. And whenever we say price date is equal to data and then pass in that key of date, what it's doing is it's setting price date equal to all of these dates here. So it's basically setting it equal to that date column. Now when we do price close and set it to data close, I'm grabbing all of the closing prices for those days. So we've got the price date and the price close data loaded in from that CSV file. So to plot this, it's as easy as passing those into the plot date method. So I'm going to, pass in price date as the x, which is the first value here, and the price close will be the y value. So I will paste that in there. And if we run that, then we can see that we get that data plotted out. Now right now this might look okay, but it's not actually plotting out our x axis as dates"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". So I will paste that in there. And if we run that, then we can see that we get that data plotted out. Now right now this might look okay, but it's not actually plotting out our x axis as dates. It's actually plotting these out as strings. So to show this, let me add a line to the end of the data of our CSV file, and I'm gonna add it out of order. So that's what, that line was there before whenever I was doing some testing. So what I'm gonna do is I'm just going to copy my top line here, and my top line is May 18th. So at the very bottom, I'm gonna paste in another line, and I'm gonna make this May 17th. And I'm just going to leave the prices and everything the same as the 1st day. So now if I run this, then we can see that we don't have a May 17th here at the beginning. It's putting it here at the end. So that doesn't really make any sense. Now, like I said, the reason it's doing this is because those are being read in as a string and not dates"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". It's putting it here at the end. So that doesn't really make any sense. Now, like I said, the reason it's doing this is because those are being read in as a string and not dates. So to fix this, we're actually gonna use some Pandas methods to set that, to a date, and then we'll also sort that as well. Now this isn't a Pandas tutorial, so I'm not gonna go into much detail here. But I just wanted to show this in case anyone is working with dates that are out of order. This is a pretty common thing to do is to need to, sort by dates by data that you're loading in. So to do this, underneath our data here, make a couple of blank lines. So I'm going to take this data date column here and I'm going to set that equal to, and I'm going to say that I want to do, pandas and then a method called to_datetime, and I want to convert that date column to a datetime"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". So what we're doing here is we are converting that date column to a date time using the to date time method from pandas, and then we are just replacing all those values, which are strings, with those converted date times. And now if we wanna sort that, then we can simply say data dot sort. And now that those are date times, we can just sort by date. And also, I want this to just sort in place, so I'm gonna say in place equals true. In place just basically means that it goes ahead and modifies that data instead of us needing to say, like, data equals data dot sort or something like that. So we don't have to do that since we're changing that in place. So now with those two changes there, if I save that and run it now, let me see if I'm getting an error for some reason. Date is not defined. Oh, you guys probably caught that as I was typing it, but I said date date. What I meant was data dot date. Did I make that mistake anywhere else? No. Okay. So let me try that. And, well, let's see"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". Oh, you guys probably caught that as I was typing it, but I said date date. What I meant was data dot date. Did I make that mistake anywhere else? No. Okay. So let me try that. And, well, let's see. Well and I made another mistake here. Sorry about that. In a Pandas DataFrame, that is not sort. That is sort values. Sorry to confuse you all there. Hopefully, that is all the mistakes that I made. So now if I rerun that, then we can see let me take that output, down there a little bit. Now we can see that our date here at the beginning, we gave it the same value as the next day. So we can see that, now it's showing up here at the beginning instead of being put at the end. So that's how you're gonna work with date times, in Pandas using that plot date method. Like I said, it's a lot like any other line plot, but you're working with dates here. So there's a few different things with how the formatting works and things like that"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". Like I said, it's a lot like any other line plot, but you're working with dates here. So there's a few different things with how the formatting works and things like that. But, basically, this is what you do for time series data in Matplotlib. Okay. So we're just about finished up here. But before we end, I'd like to mention the sponsor of this video, and that is brilliant.org. Brilliant is a problem solving website that helps you understand underlying concepts by actively working through guided lessons. They have computer science courses ranging from algorithms and data structures to machine learning and neural networks. They even have a coding environment built into their website so that you can run code directly in the browser. And that's a great way to compliment watching my tutorials because you can apply what you've learned in their active problem solving environment, and that helps to solidify that knowledge"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". And that's a great way to compliment watching my tutorials because you can apply what you've learned in their active problem solving environment, and that helps to solidify that knowledge. Their guided lessons will challenge you, but you also have the ability to get hints or even solutions if you need them. It's really tailored towards understanding that material. So their computer science material is fantastic, and I really like what they're doing. They also have plenty of courses depending on what you're most interested in. So they have courses in different fields of mathematics or astronomy, solar energy, computational biology, and all kinds of other great content. So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/cms to sign up for free. And, also, the first 200 people that go to that link will get 20% off the annual premium subscription, and you can find that link in the Okay. So I think that's gonna do it for this video"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". And, also, the first 200 people that go to that link will get 20% off the annual premium subscription, and you can find that link in the Okay. So I think that's gonna do it for this video. I hope you feel like you got a good introduction to working with dates in matplotlib and how we'd plot that type of data. In the next video, we're gonna be learning how to plot live data in real time. Now these real time plots can be used in a lot of different applications for monitoring things that are constantly being changed or updated. So that can be data that you're pulling down from an online API or maybe something that you're reading from a sensor or something like that. There's a lot of different types of applications for that. So definitely be sure to check that out. But if anyone has any questions about what we covered in this video, then feel free to ask in the comment section below, and I'll do my best to answer those"
    },
    {
        "title": "Matplotlib Tutorial (Part 8): Plotting Time Series Data",
        "text": ". So definitely be sure to check that out. But if anyone has any questions about what we covered in this video, then feel free to ask in the comment section below, and I'll do my best to answer those. And if you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up. And, also, it's a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute through Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching."
    }
]